/*
Quant Overledger API

Quant's Overledger API allows developers to create applications for multiple DLT's using a single standard set of operations and data structures.In order to maintain the security of private keys, most operations have two steps â€“ prepare and execute. The prepare step is the point at which all arguments are specified and standardised payloads are sent. Overledger converts this standard payload into a DLT-specific transaction object. In the execute step, the SDK signs the transaction object that Overledger created and submits it to Overledger to perform the operation  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ManageMonitoredResourcesApiService ManageMonitoredResourcesApi service
type ManageMonitoredResourcesApiService service

type ApiDeleteEventMonitoringRequest struct {
	ctx _context.Context
	ApiService *ManageMonitoredResourcesApiService
	authorization *string
	resourceMonitoringId string
}

func (r ApiDeleteEventMonitoringRequest) Authorization(authorization string) ApiDeleteEventMonitoringRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteEventMonitoringRequest) Execute() (SmartContractMonitoringSchema, *_nethttp.Response, error) {
	return r.ApiService.DeleteEventMonitoringExecute(r)
}

/*
DeleteEventMonitoring Stop monitoring a smart contract

Deletes the tracking record in Overledger to stop Overledger from recording updates for a smart contract based on the given Resource Monitoring ID

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resourceMonitoringId
 @return ApiDeleteEventMonitoringRequest
*/
func (a *ManageMonitoredResourcesApiService) DeleteEventMonitoring(ctx _context.Context, resourceMonitoringId string) ApiDeleteEventMonitoringRequest {
	return ApiDeleteEventMonitoringRequest{
		ApiService: a,
		ctx: ctx,
		resourceMonitoringId: resourceMonitoringId,
	}
}

// Execute executes the request
//  @return SmartContractMonitoringSchema
func (a *ManageMonitoredResourcesApiService) DeleteEventMonitoringExecute(r ApiDeleteEventMonitoringRequest) (SmartContractMonitoringSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SmartContractMonitoringSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageMonitoredResourcesApiService.DeleteEventMonitoring")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/resourcemonitoring/smartcontractevent/{resourceMonitoringId}"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceMonitoringId"+"}", _neturl.PathEscape(parameterToString(r.resourceMonitoringId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return localVarReturnValue, nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 5010 {
		return localVarReturnValue, nil, reportError("authorization must have less than 5010 elements")
	}
	if strlen(r.resourceMonitoringId) < 0 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have at least 0 elements")
	}
	if strlen(r.resourceMonitoringId) > 36 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalServerErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteResourceMonitoringAddressRequest struct {
	ctx _context.Context
	ApiService *ManageMonitoredResourcesApiService
	authorization *string
	resourceMonitoringId string
}

func (r ApiDeleteResourceMonitoringAddressRequest) Authorization(authorization string) ApiDeleteResourceMonitoringAddressRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDeleteResourceMonitoringAddressRequest) Execute() (DeleteResourceMonitoringAddressSchema, *_nethttp.Response, error) {
	return r.ApiService.DeleteResourceMonitoringAddressExecute(r)
}

/*
DeleteResourceMonitoringAddress Stop monitoring an address

Deletes the tracking record in Overledger to stop Overledger from recording updates for an address based on the given Resource Monitoring ID

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resourceMonitoringId
 @return ApiDeleteResourceMonitoringAddressRequest
*/
func (a *ManageMonitoredResourcesApiService) DeleteResourceMonitoringAddress(ctx _context.Context, resourceMonitoringId string) ApiDeleteResourceMonitoringAddressRequest {
	return ApiDeleteResourceMonitoringAddressRequest{
		ApiService: a,
		ctx: ctx,
		resourceMonitoringId: resourceMonitoringId,
	}
}

// Execute executes the request
//  @return DeleteResourceMonitoringAddressSchema
func (a *ManageMonitoredResourcesApiService) DeleteResourceMonitoringAddressExecute(r ApiDeleteResourceMonitoringAddressRequest) (DeleteResourceMonitoringAddressSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeleteResourceMonitoringAddressSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageMonitoredResourcesApiService.DeleteResourceMonitoringAddress")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/resourcemonitoring/address/{resourceMonitoringId}"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceMonitoringId"+"}", _neturl.PathEscape(parameterToString(r.resourceMonitoringId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return localVarReturnValue, nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 5010 {
		return localVarReturnValue, nil, reportError("authorization must have less than 5010 elements")
	}
	if strlen(r.resourceMonitoringId) < 0 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have at least 0 elements")
	}
	if strlen(r.resourceMonitoringId) > 36 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalServerErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListOfAddressesRequest struct {
	ctx _context.Context
	ApiService *ManageMonitoredResourcesApiService
	authorization *string
}

func (r ApiGetListOfAddressesRequest) Authorization(authorization string) ApiGetListOfAddressesRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetListOfAddressesRequest) Execute() ([]ResourceMonitoringAddressSchema, *_nethttp.Response, error) {
	return r.ApiService.GetListOfAddressesExecute(r)
}

/*
GetListOfAddresses Retrieve a list of addresses being monitored

Returns a list of addresses being monitored for your application and the corresponding Resource Monitoring ID

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetListOfAddressesRequest
*/
func (a *ManageMonitoredResourcesApiService) GetListOfAddresses(ctx _context.Context) ApiGetListOfAddressesRequest {
	return ApiGetListOfAddressesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ResourceMonitoringAddressSchema
func (a *ManageMonitoredResourcesApiService) GetListOfAddressesExecute(r ApiGetListOfAddressesRequest) ([]ResourceMonitoringAddressSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ResourceMonitoringAddressSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageMonitoredResourcesApiService.GetListOfAddresses")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/resourcemonitoring/addresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return localVarReturnValue, nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 5010 {
		return localVarReturnValue, nil, reportError("authorization must have less than 5010 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalServerErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListOfResourcesRequest struct {
	ctx _context.Context
	ApiService *ManageMonitoredResourcesApiService
	authorization *string
}

func (r ApiGetListOfResourcesRequest) Authorization(authorization string) ApiGetListOfResourcesRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetListOfResourcesRequest) Execute() ([]SmartContractMonitoringSchema, *_nethttp.Response, error) {
	return r.ApiService.GetListOfResourcesExecute(r)
}

/*
GetListOfResources Retrieve a list of all resources being monitored

Returns a list of all of the resources being monitored for your application and the corresponding Resource Monitoring ID

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetListOfResourcesRequest
*/
func (a *ManageMonitoredResourcesApiService) GetListOfResources(ctx _context.Context) ApiGetListOfResourcesRequest {
	return ApiGetListOfResourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SmartContractMonitoringSchema
func (a *ManageMonitoredResourcesApiService) GetListOfResourcesExecute(r ApiGetListOfResourcesRequest) ([]SmartContractMonitoringSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []SmartContractMonitoringSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageMonitoredResourcesApiService.GetListOfResources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/resourcemonitoring"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return localVarReturnValue, nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 5010 {
		return localVarReturnValue, nil, reportError("authorization must have less than 5010 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalServerErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListOfSmartContractEventsRequest struct {
	ctx _context.Context
	ApiService *ManageMonitoredResourcesApiService
	authorization *string
}

func (r ApiGetListOfSmartContractEventsRequest) Authorization(authorization string) ApiGetListOfSmartContractEventsRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetListOfSmartContractEventsRequest) Execute() ([]SmartContractMonitoringSchema, *_nethttp.Response, error) {
	return r.ApiService.GetListOfSmartContractEventsExecute(r)
}

/*
GetListOfSmartContractEvents Retrieve a list of smart contracts being monitored

Returns a list of smart contracts being monitored for your application and the corresponding Resource Monitoring ID

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetListOfSmartContractEventsRequest
*/
func (a *ManageMonitoredResourcesApiService) GetListOfSmartContractEvents(ctx _context.Context) ApiGetListOfSmartContractEventsRequest {
	return ApiGetListOfSmartContractEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SmartContractMonitoringSchema
func (a *ManageMonitoredResourcesApiService) GetListOfSmartContractEventsExecute(r ApiGetListOfSmartContractEventsRequest) ([]SmartContractMonitoringSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []SmartContractMonitoringSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageMonitoredResourcesApiService.GetListOfSmartContractEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/resourcemonitoring/smartcontractevents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return localVarReturnValue, nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 5010 {
		return localVarReturnValue, nil, reportError("authorization must have less than 5010 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalServerErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitoredAddressRequest struct {
	ctx _context.Context
	ApiService *ManageMonitoredResourcesApiService
	authorization *string
	resourceMonitoringId string
}

func (r ApiGetMonitoredAddressRequest) Authorization(authorization string) ApiGetMonitoredAddressRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetMonitoredAddressRequest) Execute() (AddressMonitoringDetailsSchema, *_nethttp.Response, error) {
	return r.ApiService.GetMonitoredAddressExecute(r)
}

/*
GetMonitoredAddress Retrieve recorded updates for a specific monitored address

Returns the update information recorded in Overledger for an address being monitored by your application for a given Resource Monitoring ID

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resourceMonitoringId
 @return ApiGetMonitoredAddressRequest
*/
func (a *ManageMonitoredResourcesApiService) GetMonitoredAddress(ctx _context.Context, resourceMonitoringId string) ApiGetMonitoredAddressRequest {
	return ApiGetMonitoredAddressRequest{
		ApiService: a,
		ctx: ctx,
		resourceMonitoringId: resourceMonitoringId,
	}
}

// Execute executes the request
//  @return AddressMonitoringDetailsSchema
func (a *ManageMonitoredResourcesApiService) GetMonitoredAddressExecute(r ApiGetMonitoredAddressRequest) (AddressMonitoringDetailsSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AddressMonitoringDetailsSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageMonitoredResourcesApiService.GetMonitoredAddress")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/resourcemonitoring/address/{resourceMonitoringId}"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceMonitoringId"+"}", _neturl.PathEscape(parameterToString(r.resourceMonitoringId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return localVarReturnValue, nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 5010 {
		return localVarReturnValue, nil, reportError("authorization must have less than 5010 elements")
	}
	if strlen(r.resourceMonitoringId) < 0 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have at least 0 elements")
	}
	if strlen(r.resourceMonitoringId) > 36 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalServerErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitoredSmartContractEventDetailsRequest struct {
	ctx _context.Context
	ApiService *ManageMonitoredResourcesApiService
	authorization *string
	resourceMonitoringId string
}

func (r ApiGetMonitoredSmartContractEventDetailsRequest) Authorization(authorization string) ApiGetMonitoredSmartContractEventDetailsRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetMonitoredSmartContractEventDetailsRequest) Execute() (SmartContractMonitoringDetailsSchema, *_nethttp.Response, error) {
	return r.ApiService.GetMonitoredSmartContractEventDetailsExecute(r)
}

/*
GetMonitoredSmartContractEventDetails Retrieve recorded updates for a specific monitored smart contract

Returns the update information recorded in Overledger for asmart contract being monitored by your application for a given Resource Monitoring ID

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resourceMonitoringId
 @return ApiGetMonitoredSmartContractEventDetailsRequest
*/
func (a *ManageMonitoredResourcesApiService) GetMonitoredSmartContractEventDetails(ctx _context.Context, resourceMonitoringId string) ApiGetMonitoredSmartContractEventDetailsRequest {
	return ApiGetMonitoredSmartContractEventDetailsRequest{
		ApiService: a,
		ctx: ctx,
		resourceMonitoringId: resourceMonitoringId,
	}
}

// Execute executes the request
//  @return SmartContractMonitoringDetailsSchema
func (a *ManageMonitoredResourcesApiService) GetMonitoredSmartContractEventDetailsExecute(r ApiGetMonitoredSmartContractEventDetailsRequest) (SmartContractMonitoringDetailsSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SmartContractMonitoringDetailsSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageMonitoredResourcesApiService.GetMonitoredSmartContractEventDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/resourcemonitoring/smartcontractevent/{resourceMonitoringId}"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceMonitoringId"+"}", _neturl.PathEscape(parameterToString(r.resourceMonitoringId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return localVarReturnValue, nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 5010 {
		return localVarReturnValue, nil, reportError("authorization must have less than 5010 elements")
	}
	if strlen(r.resourceMonitoringId) < 0 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have at least 0 elements")
	}
	if strlen(r.resourceMonitoringId) > 36 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have less than 36 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalServerErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateEventMonitoringRequest struct {
	ctx _context.Context
	ApiService *ManageMonitoredResourcesApiService
	authorization *string
	resourceMonitoringId string
	statusUpdateMonitoringRequestSchema *StatusUpdateMonitoringRequestSchema
}

func (r ApiUpdateEventMonitoringRequest) Authorization(authorization string) ApiUpdateEventMonitoringRequest {
	r.authorization = &authorization
	return r
}
func (r ApiUpdateEventMonitoringRequest) StatusUpdateMonitoringRequestSchema(statusUpdateMonitoringRequestSchema StatusUpdateMonitoringRequestSchema) ApiUpdateEventMonitoringRequest {
	r.statusUpdateMonitoringRequestSchema = &statusUpdateMonitoringRequestSchema
	return r
}

func (r ApiUpdateEventMonitoringRequest) Execute() (SmartContractMonitoringSchema, *_nethttp.Response, error) {
	return r.ApiService.UpdateEventMonitoringExecute(r)
}

/*
UpdateEventMonitoring Update the monitoring status of a smart contract

Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to be inactive will pause Overledger recording updates for the requested smart contract

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resourceMonitoringId
 @return ApiUpdateEventMonitoringRequest
*/
func (a *ManageMonitoredResourcesApiService) UpdateEventMonitoring(ctx _context.Context, resourceMonitoringId string) ApiUpdateEventMonitoringRequest {
	return ApiUpdateEventMonitoringRequest{
		ApiService: a,
		ctx: ctx,
		resourceMonitoringId: resourceMonitoringId,
	}
}

// Execute executes the request
//  @return SmartContractMonitoringSchema
func (a *ManageMonitoredResourcesApiService) UpdateEventMonitoringExecute(r ApiUpdateEventMonitoringRequest) (SmartContractMonitoringSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SmartContractMonitoringSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageMonitoredResourcesApiService.UpdateEventMonitoring")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/resourcemonitoring/smartcontractevent/{resourceMonitoringId}"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceMonitoringId"+"}", _neturl.PathEscape(parameterToString(r.resourceMonitoringId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return localVarReturnValue, nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 5010 {
		return localVarReturnValue, nil, reportError("authorization must have less than 5010 elements")
	}
	if strlen(r.resourceMonitoringId) < 0 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have at least 0 elements")
	}
	if strlen(r.resourceMonitoringId) > 36 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have less than 36 elements")
	}
	if r.statusUpdateMonitoringRequestSchema == nil {
		return localVarReturnValue, nil, reportError("statusUpdateMonitoringRequestSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.statusUpdateMonitoringRequestSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalServerErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateResourceMonitoringAddressRequest struct {
	ctx _context.Context
	ApiService *ManageMonitoredResourcesApiService
	authorization *string
	resourceMonitoringId string
	statusUpdateMonitoringRequestSchema *StatusUpdateMonitoringRequestSchema
}

func (r ApiUpdateResourceMonitoringAddressRequest) Authorization(authorization string) ApiUpdateResourceMonitoringAddressRequest {
	r.authorization = &authorization
	return r
}
func (r ApiUpdateResourceMonitoringAddressRequest) StatusUpdateMonitoringRequestSchema(statusUpdateMonitoringRequestSchema StatusUpdateMonitoringRequestSchema) ApiUpdateResourceMonitoringAddressRequest {
	r.statusUpdateMonitoringRequestSchema = &statusUpdateMonitoringRequestSchema
	return r
}

func (r ApiUpdateResourceMonitoringAddressRequest) Execute() (UpdateAddressMonitoringSchema, *_nethttp.Response, error) {
	return r.ApiService.UpdateResourceMonitoringAddressExecute(r)
}

/*
UpdateResourceMonitoringAddress Update the monitoring status of an address

Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to beinactive will pause Overledger recording updates for the requested address

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resourceMonitoringId
 @return ApiUpdateResourceMonitoringAddressRequest
*/
func (a *ManageMonitoredResourcesApiService) UpdateResourceMonitoringAddress(ctx _context.Context, resourceMonitoringId string) ApiUpdateResourceMonitoringAddressRequest {
	return ApiUpdateResourceMonitoringAddressRequest{
		ApiService: a,
		ctx: ctx,
		resourceMonitoringId: resourceMonitoringId,
	}
}

// Execute executes the request
//  @return UpdateAddressMonitoringSchema
func (a *ManageMonitoredResourcesApiService) UpdateResourceMonitoringAddressExecute(r ApiUpdateResourceMonitoringAddressRequest) (UpdateAddressMonitoringSchema, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdateAddressMonitoringSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageMonitoredResourcesApiService.UpdateResourceMonitoringAddress")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/resourcemonitoring/address/{resourceMonitoringId}"
	localVarPath = strings.Replace(localVarPath, "{"+"resourceMonitoringId"+"}", _neturl.PathEscape(parameterToString(r.resourceMonitoringId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return localVarReturnValue, nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 5010 {
		return localVarReturnValue, nil, reportError("authorization must have less than 5010 elements")
	}
	if strlen(r.resourceMonitoringId) < 0 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have at least 0 elements")
	}
	if strlen(r.resourceMonitoringId) > 36 {
		return localVarReturnValue, nil, reportError("resourceMonitoringId must have less than 36 elements")
	}
	if r.statusUpdateMonitoringRequestSchema == nil {
		return localVarReturnValue, nil, reportError("statusUpdateMonitoringRequestSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.statusUpdateMonitoringRequestSchema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorList
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalServerErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

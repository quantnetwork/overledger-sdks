/* tslint:disable */
/* eslint-disable */
/**
 * Quant Overledger API
 * Quant’s Overledger API allows developers to create applications for multiple DLT’s using a single standard set of operations and data structures.In order to maintain the security of private keys, most operations have two steps – prepare and execute. The prepare step is the point at which all arguments are specified and standardised payloads are sent. Overledger converts this standard payload into a DLT-specific transaction object. In the execute step, the SDK signs the transaction object that Overledger created and submits it to Overledger to perform the operation
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Account Details of the tokens
 * @export
 * @interface AccountDetails
 */
export interface AccountDetails {
    /**
     * 
     * @type {string}
     * @memberof AccountDetails
     */
    'parentAccountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDetails
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDetails
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDetails
     */
    'owningInstitutionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDetails
     */
    'accountType'?: string;
}
/**
 * 
 * @export
 * @interface AddSecondaryAccountRequestDetailsSchema
 */
export interface AddSecondaryAccountRequestDetailsSchema {
    /**
     * 
     * @type {SecondaryAccountOwnerSchema}
     * @memberof AddSecondaryAccountRequestDetailsSchema
     */
    'owner'?: SecondaryAccountOwnerSchema;
    /**
     * 
     * @type {SecondaryAccountAdditionalOwnerSchema}
     * @memberof AddSecondaryAccountRequestDetailsSchema
     */
    'additionalOwner'?: SecondaryAccountAdditionalOwnerSchema;
}
/**
 * Who is authorized as an operator on behalf of the Owner.
 * @export
 * @interface AdditionalOwner
 */
export interface AdditionalOwner {
    /**
     * 
     * @type {string}
     * @memberof AdditionalOwner
     */
    'accountId'?: string;
}
/**
 * Who are the additional owner of this transaction
 * @export
 * @interface AdditionalOwnerRemoveSecondarySchema
 */
export interface AdditionalOwnerRemoveSecondarySchema {
    /**
     * Unique Identifier of the owner
     * @type {string}
     * @memberof AdditionalOwnerRemoveSecondarySchema
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface AddressBalanceResponse
 */
export interface AddressBalanceResponse {
    /**
     * 
     * @type {string}
     * @memberof AddressBalanceResponse
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressBalanceResponse
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface AddressMonitoringDetailsSchema
 */
export interface AddressMonitoringDetailsSchema {
    /**
     * 
     * @type {Location}
     * @memberof AddressMonitoringDetailsSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {ResourceMonitoredAddressDetails}
     * @memberof AddressMonitoringDetailsSchema
     */
    'addressDetails'?: ResourceMonitoredAddressDetails;
    /**
     * 
     * @type {string}
     * @memberof AddressMonitoringDetailsSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressMonitoringDetailsSchema
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface AddressMonitoringRequestSchema
 */
export interface AddressMonitoringRequestSchema {
    /**
     * 
     * @type {Location}
     * @memberof AddressMonitoringRequestSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof AddressMonitoringRequestSchema
     */
    'callBackURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressMonitoringRequestSchema
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface AddressMonitoringResponseSchema
 */
export interface AddressMonitoringResponseSchema {
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof AddressMonitoringResponseSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
    /**
     * 
     * @type {ResourceMonitoringSubscriptionDetails}
     * @memberof AddressMonitoringResponseSchema
     */
    'subscriptionDetails'?: ResourceMonitoringSubscriptionDetails;
    /**
     * 
     * @type {ResourceMonitoringSubscription}
     * @memberof AddressMonitoringResponseSchema
     */
    'subscription'?: ResourceMonitoringSubscription;
}
/**
 * Alias Details of an account
 * @export
 * @interface AliasDetails
 */
export interface AliasDetails {
    /**
     * 
     * @type {string}
     * @memberof AliasDetails
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AliasDetails
     */
    'unit'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AliasDetails
     */
    'disposableAlias'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AliasDetails
     */
    'aliasHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof AliasDetails
     */
    'aliasType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AliasDetails
     */
    'esipId'?: string;
}
/**
 * 
 * @export
 * @interface ApproveRequestDetailsSchema
 */
export interface ApproveRequestDetailsSchema {
    /**
     * Who are the payers of this transaction
     * @type {Array<PayerCreditSchema>}
     * @memberof ApproveRequestDetailsSchema
     */
    'payer'?: Array<PayerCreditSchema>;
    /**
     * Who are the payees of this transaction
     * @type {Array<PayeeCreditSchema>}
     * @memberof ApproveRequestDetailsSchema
     */
    'mandate'?: Array<PayeeCreditSchema>;
    /**
     * 
     * @type {string}
     * @memberof ApproveRequestDetailsSchema
     */
    'overledgerSigningType'?: string;
}
/**
 * 
 * @export
 * @interface AutoExecSearchAddressSequenceResponseSchema
 */
export interface AutoExecSearchAddressSequenceResponseSchema {
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof AutoExecSearchAddressSequenceResponseSchema
     */
    'prepareAndExecuteOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
    /**
     * 
     * @type {ExecuteSearchSequenceResponse}
     * @memberof AutoExecSearchAddressSequenceResponseSchema
     */
    'executionAddressSequenceSearchResponse'?: ExecuteSearchSequenceResponse;
    /**
     * 
     * @type {PrepareSearchResponseSchema}
     * @memberof AutoExecSearchAddressSequenceResponseSchema
     */
    'preparationAddressSequenceSearchResponse'?: PrepareSearchResponseSchema;
}
/**
 * 
 * @export
 * @interface AutoExecuteSearchAddressBalanceResponseSchema
 */
export interface AutoExecuteSearchAddressBalanceResponseSchema {
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof AutoExecuteSearchAddressBalanceResponseSchema
     */
    'prepareAndExecuteOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
    /**
     * 
     * @type {PrepareAndExecuteSearchAddressBalanceResponse}
     * @memberof AutoExecuteSearchAddressBalanceResponseSchema
     */
    'executionAddressBalanceSearchResponse'?: PrepareAndExecuteSearchAddressBalanceResponse;
    /**
     * 
     * @type {PrepareSearchResponseSchema}
     * @memberof AutoExecuteSearchAddressBalanceResponseSchema
     */
    'preparationAddressBalanceSearchResponse'?: PrepareSearchResponseSchema;
}
/**
 * 
 * @export
 * @interface AutoExecuteSearchBlockResponseSchema
 */
export interface AutoExecuteSearchBlockResponseSchema {
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof AutoExecuteSearchBlockResponseSchema
     */
    'prepareAndExecuteOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
    /**
     * 
     * @type {ExecuteSearchBlockResponse}
     * @memberof AutoExecuteSearchBlockResponseSchema
     */
    'executionBlockSearchResponse'?: ExecuteSearchBlockResponse;
    /**
     * 
     * @type {PrepareSearchResponseSchema}
     * @memberof AutoExecuteSearchBlockResponseSchema
     */
    'preparationBlockSearchResponse'?: PrepareSearchResponseSchema;
}
/**
 * 
 * @export
 * @interface AutoExecuteSearchUTXOResponseSchema
 */
export interface AutoExecuteSearchUTXOResponseSchema {
    /**
     * 
     * @type {ExecuteSearchUTXOResponse}
     * @memberof AutoExecuteSearchUTXOResponseSchema
     */
    'executionUtxoSearchResponse'?: ExecuteSearchUTXOResponse;
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof AutoExecuteSearchUTXOResponseSchema
     */
    'prepareAndExecuteOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
    /**
     * 
     * @type {PrepareTransactionResponse}
     * @memberof AutoExecuteSearchUTXOResponseSchema
     */
    'preparationUtxoSearchResponse'?: PrepareTransactionResponse;
}
/**
 * The Destination of this transaction
 * @export
 * @interface Beneficiary
 */
export interface Beneficiary {
    /**
     * The unique identifiers of the account
     * @type {string}
     * @memberof Beneficiary
     */
    'accountId'?: string;
    /**
     * 
     * @type {Mint}
     * @memberof Beneficiary
     */
    'mint'?: Mint;
}
/**
 * Who is the beneficiary of this transaction
 * @export
 * @interface BeneficiaryMintSchemaQrc20
 */
export interface BeneficiaryMintSchemaQrc20 {
    /**
     * The unique identifiers of the beneficiaries
     * @type {string}
     * @memberof BeneficiaryMintSchemaQrc20
     */
    'accountId'?: string;
    /**
     * 
     * @type {MintSchemaQrc20}
     * @memberof BeneficiaryMintSchemaQrc20
     */
    'mint'?: MintSchemaQrc20;
}
/**
 * Who is the beneficiary of this transaction
 * @export
 * @interface BeneficiaryMintSchemaQrc721
 */
export interface BeneficiaryMintSchemaQrc721 {
    /**
     * The unique identifiers of the beneficiaries
     * @type {string}
     * @memberof BeneficiaryMintSchemaQrc721
     */
    'accountId'?: string;
    /**
     * 
     * @type {MintSchemaQrc721}
     * @memberof BeneficiaryMintSchemaQrc721
     */
    'mint'?: MintSchemaQrc721;
}
/**
 * 
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'blockId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Block
     */
    'number'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Block
     */
    'transactionIds'?: Array<string>;
    /**
     * 
     * @type {Array<BlockSize>}
     * @memberof Block
     */
    'size'?: Array<BlockSize>;
    /**
     * 
     * @type {Array<BlockHash>}
     * @memberof Block
     */
    'hashes'?: Array<BlockHash>;
    /**
     * 
     * @type {LinkedBlocks}
     * @memberof Block
     */
    'linkedBlocks'?: LinkedBlocks;
    /**
     * 
     * @type {number}
     * @memberof Block
     */
    'numberOfTransactions'?: number;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'timestamp'?: string;
    /**
     * 
     * @type {object}
     * @memberof Block
     */
    'nativeData'?: object;
}
/**
 * 
 * @export
 * @interface BlockHash
 */
export interface BlockHash {
    /**
     * 
     * @type {string}
     * @memberof BlockHash
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockHash
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BlockSize
 */
export interface BlockSize {
    /**
     * 
     * @type {string}
     * @memberof BlockSize
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockSize
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockSize
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface Burn
 */
export interface Burn {
    /**
     * Name of the token
     * @type {string}
     * @memberof Burn
     */
    'tokenName'?: string;
    /**
     * The amount of a currency
     * @type {string}
     * @memberof Burn
     */
    'amount'?: string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof Burn
     */
    'unit'?: string;
    /**
     * (Optional) String of metadata
     * @type {string}
     * @memberof Burn
     */
    'metadata'?: string;
    /**
     * Unique identifier for the specific token
     * @type {string}
     * @memberof Burn
     */
    'tokenId'?: string;
}
/**
 * 
 * @export
 * @interface BurnRequestDetailsSchema
 */
export interface BurnRequestDetailsSchema {
    /**
     * Who is the owner of the tokens
     * @type {Array<OwnerBurnSchema>}
     * @memberof BurnRequestDetailsSchema
     */
    'owner'?: Array<OwnerBurnSchema>;
    /**
     * Any text-based element of the data payload
     * @type {string}
     * @memberof BurnRequestDetailsSchema
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BurnRequestDetailsSchema
     */
    'overledgerSigningType'?: string;
}
/**
 * 
 * @export
 * @interface BurnRequestDetailsSchemaQrc721
 */
export interface BurnRequestDetailsSchemaQrc721 {
    /**
     * 
     * @type {OwnerBurnSchema}
     * @memberof BurnRequestDetailsSchemaQrc721
     */
    'owner'?: OwnerBurnSchema;
    /**
     * 
     * @type {string}
     * @memberof BurnRequestDetailsSchemaQrc721
     */
    'overledgerSigningType'?: string;
}
/**
 * 
 * @export
 * @interface BurnSchema
 */
export interface BurnSchema {
    /**
     * The amount of a currency
     * @type {string}
     * @memberof BurnSchema
     */
    'amount': string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof BurnSchema
     */
    'unit'?: string;
}
/**
 * Who is the collector of the tokens.
 * @export
 * @interface Collector
 */
export interface Collector {
    /**
     * 
     * @type {string}
     * @memberof Collector
     */
    'accountId'?: string;
    /**
     * 
     * @type {Transfer}
     * @memberof Collector
     */
    'transfer'?: Transfer;
}
/**
 * 
 * @export
 * @interface CreateSmartContractMonitoringSchema
 */
export interface CreateSmartContractMonitoringSchema {
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof CreateSmartContractMonitoringSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
    /**
     * 
     * @type {ResourceMonitoringSubscriptionDetails}
     * @memberof CreateSmartContractMonitoringSchema
     */
    'subscriptionDetails'?: ResourceMonitoringSubscriptionDetails;
    /**
     * 
     * @type {ResourceMonitoringSubscription}
     * @memberof CreateSmartContractMonitoringSchema
     */
    'subscription'?: ResourceMonitoringSubscription;
}
/**
 * 
 * @export
 * @interface CreateWebhookSubscriptionRequestSchema
 */
export interface CreateWebhookSubscriptionRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookSubscriptionRequestSchema
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateWebhookSubscriptionRequestSchema
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookSubscriptionRequestSchema
     */
    'callbackUrl'?: string;
}
/**
 * 
 * @export
 * @interface CreateWebhookSubscriptionResponseSchema
 */
export interface CreateWebhookSubscriptionResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookSubscriptionResponseSchema
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {WebhookSubscriptionDetailsSchema}
     * @memberof CreateWebhookSubscriptionResponseSchema
     */
    'scubscriptionDetails'?: WebhookSubscriptionDetailsSchema;
}
/**
 * Where is this transaction coming from
 * @export
 * @interface Creator
 */
export interface Creator {
    /**
     * 
     * @type {string}
     * @memberof Creator
     */
    'accountId'?: string;
}
/**
 * Who is the creator of this transaction
 * @export
 * @interface CreatorMintSchema
 */
export interface CreatorMintSchema {
    /**
     * Unique Identifier of the creator
     * @type {string}
     * @memberof CreatorMintSchema
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface CreditRequestDetailsSchema
 */
export interface CreditRequestDetailsSchema {
    /**
     * Who are the payees of this transaction
     * @type {Array<PayeeCreditSchema>}
     * @memberof CreditRequestDetailsSchema
     */
    'payee'?: Array<PayeeCreditSchema>;
    /**
     * Any text-based element of the data payload
     * @type {string}
     * @memberof CreditRequestDetailsSchema
     */
    'message'?: string;
    /**
     * Who are the payers of this transaction
     * @type {Array<PayerCreditSchema>}
     * @memberof CreditRequestDetailsSchema
     */
    'payer'?: Array<PayerCreditSchema>;
    /**
     * 
     * @type {string}
     * @memberof CreditRequestDetailsSchema
     */
    'overledgerSigningType'?: string;
}
/**
 * 
 * @export
 * @interface DeleteResourceMonitoringAddressSchema
 */
export interface DeleteResourceMonitoringAddressSchema {
    /**
     * 
     * @type {ResourceMonitoringAddressDetails}
     * @memberof DeleteResourceMonitoringAddressSchema
     */
    'addressMonitoringDetails'?: ResourceMonitoringAddressDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof DeleteResourceMonitoringAddressSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
}
/**
 * The Destination of this transaction
 * @export
 * @interface Destination
 */
export interface Destination {
    /**
     * 
     * @type {Payment}
     * @memberof Destination
     */
    'payment'?: Payment;
    /**
     * 
     * @type {Transfer}
     * @memberof Destination
     */
    'transfer'?: Transfer;
    /**
     * The unique identifier of the destination
     * @type {string}
     * @memberof Destination
     */
    'destinationId'?: string;
    /**
     * 
     * @type {SmartContract}
     * @memberof Destination
     */
    'smartContract'?: SmartContract;
}
/**
 * List of the recipients of this transaction.  **Warning:** Bitcoin transaction fees will be deducted from the last destination provided in the transaction payment request. If the last destination payment value is not enough to cover the fees, your Bitcoin payment transaction will fail
 * @export
 * @interface DestinationPaymentSchema
 */
export interface DestinationPaymentSchema {
    /**
     * Unique identifier of the destination/recipient
     * @type {string}
     * @memberof DestinationPaymentSchema
     */
    'destinationId': string;
    /**
     * 
     * @type {PaymentSchema}
     * @memberof DestinationPaymentSchema
     */
    'payment': PaymentSchema;
}
/**
 * 
 * @export
 * @interface DestinationTransferSchema
 */
export interface DestinationTransferSchema {
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferSchema
     */
    'destinationId'?: string;
    /**
     * 
     * @type {TransferSchema}
     * @memberof DestinationTransferSchema
     */
    'transfer'?: TransferSchema;
}
/**
 * 
 * @export
 * @interface Erc20DTO
 */
export interface Erc20DTO {
    /**
     * 
     * @type {boolean}
     * @memberof Erc20DTO
     */
    'isQrc20'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Erc20DTO
     */
    'tokenUnit'?: string;
    /**
     * 
     * @type {number}
     * @memberof Erc20DTO
     */
    'decimalPlaces'?: number;
    /**
     * 
     * @type {Array<TierFunctionDTO>}
     * @memberof Erc20DTO
     */
    'functions'?: Array<TierFunctionDTO>;
    /**
     * 
     * @type {string}
     * @memberof Erc20DTO
     */
    'tokenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Erc20DTO
     */
    'smartContractAddress'?: string;
    /**
     * 
     * @type {LocationDTO}
     * @memberof Erc20DTO
     */
    'location'?: LocationDTO;
    /**
     * 
     * @type {string}
     * @memberof Erc20DTO
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Erc20DTO
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Erc20DTO
     */
    'auditDate'?: string;
}
/**
 * 
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetails
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetails
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetails
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface ErrorList
 */
export interface ErrorList {
    /**
     * 
     * @type {Array<Error>}
     * @memberof ErrorList
     */
    'errors'?: Array<Error>;
    /**
     * 
     * @type {number}
     * @memberof ErrorList
     */
    'errorCount'?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponseMessage
 */
export interface ErrorResponseMessage {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponseMessage
     */
    'code'?: number;
    /**
     * 
     * @type {object}
     * @memberof ErrorResponseMessage
     */
    'errorMessageExtraDetails'?: object;
    /**
     * 
     * @type {number}
     * @memberof ErrorResponseMessage
     */
    'subCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseMessage
     */
    'logTraceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseMessage
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseMessage
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseMessage
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface EventSubscriptionResponse
 */
export interface EventSubscriptionResponse {
    /**
     * Name of the token
     * @type {string}
     * @memberof EventSubscriptionResponse
     */
    'tokenName'?: string;
    /**
     * 
     * @type {EventSubscriptionResponseDetails}
     * @memberof EventSubscriptionResponse
     */
    'subscriptionDetails'?: EventSubscriptionResponseDetails;
    /**
     * 
     * @type {Location}
     * @memberof EventSubscriptionResponse
     */
    'location'?: Location;
    /**
     * Type of event
     * @type {string}
     * @memberof EventSubscriptionResponse
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface EventSubscriptionResponseDetails
 */
export interface EventSubscriptionResponseDetails {
    /**
     * 
     * @type {string}
     * @memberof EventSubscriptionResponseDetails
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscriptionResponseDetails
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSubscriptionResponseDetails
     */
    'createdDate'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteSearchBalanceResponse
 */
export interface ExecuteSearchBalanceResponse {
    /**
     * 
     * @type {Array<AddressBalanceResponse>}
     * @memberof ExecuteSearchBalanceResponse
     */
    'balances'?: Array<AddressBalanceResponse>;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchBalanceResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchBalanceResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchBalanceResponse
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteSearchBlockResponse
 */
export interface ExecuteSearchBlockResponse {
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchBlockResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {Block}
     * @memberof ExecuteSearchBlockResponse
     */
    'block'?: Block;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteSearchBlockResponse
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface ExecuteSearchSequenceResponse
 */
export interface ExecuteSearchSequenceResponse {
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchSequenceResponse
     */
    'sequence'?: string;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchSequenceResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchSequenceResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchSequenceResponse
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteSearchTransactionResponse
 */
export interface ExecuteSearchTransactionResponse {
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchTransactionResponse
     */
    'location'?: Location;
    /**
     * The type of the transaction object returned
     * @type {string}
     * @memberof ExecuteSearchTransactionResponse
     */
    'type'?: string;
    /**
     * 
     * @type {Transaction}
     * @memberof ExecuteSearchTransactionResponse
     */
    'transaction'?: Transaction;
    /**
     * The unix time to read the object from
     * @type {string}
     * @memberof ExecuteSearchTransactionResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteSearchTransactionResponse
     */
    'status'?: Status;
    /**
     * 
     * @type {object}
     * @memberof ExecuteSearchTransactionResponse
     */
    'extraFields'?: object;
}
/**
 * 
 * @export
 * @interface ExecuteSearchUTXOResponse
 */
export interface ExecuteSearchUTXOResponse {
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchUTXOResponse
     */
    'utxoId'?: string;
    /**
     * 
     * @type {Array<Destination>}
     * @memberof ExecuteSearchUTXOResponse
     */
    'destination'?: Array<Destination>;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchUTXOResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchUTXOResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteSearchUTXOResponse
     */
    'status'?: Status;
    /**
     * 
     * @type {object}
     * @memberof ExecuteSearchUTXOResponse
     */
    'nativeData'?: object;
}
/**
 * 
 * @export
 * @interface ExecuteSearchUTXOResponseSchema
 */
export interface ExecuteSearchUTXOResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'utxoId'?: string;
    /**
     * 
     * @type {Array<UTXODestination>}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'destination'?: Array<UTXODestination>;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'timestamp'?: string;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'status'?: Status;
    /**
     * 
     * @type {UTXONativeData}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'nativeData'?: UTXONativeData;
}
/**
 * 
 * @export
 * @interface ExecuteSmartContractReadResponseSchema
 */
export interface ExecuteSmartContractReadResponseSchema {
    /**
     * 
     * @type {SmartContractReadSchema}
     * @memberof ExecuteSmartContractReadResponseSchema
     */
    'smartContract'?: SmartContractReadSchema;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSmartContractReadResponseSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface ExecuteTransactionRequest
 */
export interface ExecuteTransactionRequest {
    /**
     * The raw data after transaction signing
     * @type {string}
     * @memberof ExecuteTransactionRequest
     */
    'signed'?: string;
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof ExecuteTransactionRequest
     */
    'requestId': string;
}
/**
 * 
 * @export
 * @interface ExecuteTransactionResponse
 */
export interface ExecuteTransactionResponse {
    /**
     * 
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'urgency'?: string;
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'requestId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'overledgerTransactionId'?: string;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteTransactionResponse
     */
    'location'?: Location;
    /**
     * The type of the transaction executed
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'type'?: string;
    /**
     * The ID assigned by Overledger to a transaction submitted to a DLT via Overledger
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'transactionId'?: string;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteTransactionResponse
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface ExtraFields
 */
export interface ExtraFields {
    /**
     * 
     * @type {number}
     * @memberof ExtraFields
     */
    'requiredSignatures'?: number;
}
/**
 * 
 * @export
 * @interface Fee
 */
export interface Fee {
    /**
     * The amount of a currency
     * @type {string}
     * @memberof Fee
     */
    'amount': string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof Fee
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface Function
 */
export interface Function {
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    'api'?: string;
}
/**
 * 
 * @export
 * @interface FunctionDTO
 */
export interface FunctionDTO {
    /**
     * 
     * @type {string}
     * @memberof FunctionDTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionDTO
     */
    'api'?: string;
}
/**
 * 
 * @export
 * @interface FungibleTokenResponseDTO
 */
export interface FungibleTokenResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof FungibleTokenResponseDTO
     */
    'documentationUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof FungibleTokenResponseDTO
     */
    'unit'?: string;
    /**
     * 
     * @type {number}
     * @memberof FungibleTokenResponseDTO
     */
    'decimalPlaces'?: number;
    /**
     * 
     * @type {Array<FunctionDTO>}
     * @memberof FungibleTokenResponseDTO
     */
    'functions'?: Array<FunctionDTO>;
    /**
     * 
     * @type {string}
     * @memberof FungibleTokenResponseDTO
     */
    'contractType'?: FungibleTokenResponseDTOContractTypeEnum;
    /**
     * 
     * @type {LocationDTO}
     * @memberof FungibleTokenResponseDTO
     */
    'location'?: LocationDTO;
    /**
     * 
     * @type {string}
     * @memberof FungibleTokenResponseDTO
     */
    'smartContractId'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum FungibleTokenResponseDTOContractTypeEnum {
    Erc20 = 'ERC20',
    Qrc20 = 'QRC20'
}

/**
 * 
 * @export
 * @interface InternalServerErrorSchema
 */
export interface InternalServerErrorSchema {
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorSchema
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorSchema
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorSchema
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorSchema
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalServerErrorSchema
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface LinkedBlocks
 */
export interface LinkedBlocks {
    /**
     * 
     * @type {string}
     * @memberof LinkedBlocks
     */
    'parent'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedBlocks
     */
    'child'?: string;
}
/**
 * 
 * @export
 * @interface ListWebhookSubscriptionResponseSchema
 */
export interface ListWebhookSubscriptionResponseSchema {
    /**
     * 
     * @type {WebhookSubscriptionDetailsSchema}
     * @memberof ListWebhookSubscriptionResponseSchema
     */
    'subscriptionDetails'?: WebhookSubscriptionDetailsSchema;
    /**
     * 
     * @type {string}
     * @memberof ListWebhookSubscriptionResponseSchema
     */
    'lastUpdatedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListWebhookSubscriptionResponseSchema
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListWebhookSubscriptionResponseSchema
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListWebhookSubscriptionResponseSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListWebhookSubscriptionResponseSchema
     */
    'subscribedTime'?: string;
}
/**
 * Unique reference to the ledger on a particular ledger network (optionally accessed from a particular node)
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * The technology used by the desired network
     * @type {string}
     * @memberof Location
     */
    'technology': string;
    /**
     * The network that the ledger resides on
     * @type {string}
     * @memberof Location
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface LocationDTO
 */
export interface LocationDTO {
    /**
     * 
     * @type {string}
     * @memberof LocationDTO
     */
    'technology'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocationDTO
     */
    'network'?: string;
}
/**
 * Lock Details of the tokens
 * @export
 * @interface LockDetails
 */
export interface LockDetails {
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'lockId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'accountOwningInstitutionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'lockDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'payeeId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'payeeOwningInstitutionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof LockDetails
     */
    'lockOwningInstitutionId'?: string;
}
/**
 * The Destination of this transaction
 * @export
 * @interface Mandate
 */
export interface Mandate {
    /**
     * 
     * @type {Payment}
     * @memberof Mandate
     */
    'payment'?: Payment;
    /**
     * The unique identifiers of the payee
     * @type {string}
     * @memberof Mandate
     */
    'payeeId'?: string;
}
/**
 * 
 * @export
 * @interface Mint
 */
export interface Mint {
    /**
     * Name of the token
     * @type {string}
     * @memberof Mint
     */
    'tokenName'?: string;
    /**
     * The amount of a currency
     * @type {string}
     * @memberof Mint
     */
    'amount'?: string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof Mint
     */
    'unit'?: string;
    /**
     * (Optional) String of metadata
     * @type {string}
     * @memberof Mint
     */
    'metadata'?: string;
    /**
     * Unique identifier for the specific token
     * @type {string}
     * @memberof Mint
     */
    'tokenId'?: string;
}
/**
 * 
 * @export
 * @interface MintRequestDetailsSchemaQrc20
 */
export interface MintRequestDetailsSchemaQrc20 {
    /**
     * 
     * @type {CreatorMintSchema}
     * @memberof MintRequestDetailsSchemaQrc20
     */
    'creator'?: CreatorMintSchema;
    /**
     * 
     * @type {BeneficiaryMintSchemaQrc20}
     * @memberof MintRequestDetailsSchemaQrc20
     */
    'beneficiary'?: BeneficiaryMintSchemaQrc20;
    /**
     * Any text-based element of the data payload
     * @type {string}
     * @memberof MintRequestDetailsSchemaQrc20
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof MintRequestDetailsSchemaQrc20
     */
    'overledgerSigningType'?: string;
}
/**
 * 
 * @export
 * @interface MintRequestDetailsSchemaQrc721
 */
export interface MintRequestDetailsSchemaQrc721 {
    /**
     * 
     * @type {BeneficiaryMintSchemaQrc721}
     * @memberof MintRequestDetailsSchemaQrc721
     */
    'beneficiary'?: BeneficiaryMintSchemaQrc721;
    /**
     * 
     * @type {CreatorMintSchema}
     * @memberof MintRequestDetailsSchemaQrc721
     */
    'creator'?: CreatorMintSchema;
    /**
     * 
     * @type {string}
     * @memberof MintRequestDetailsSchemaQrc721
     */
    'overledgerSigningType'?: string;
}
/**
 * 
 * @export
 * @interface MintSchemaQrc20
 */
export interface MintSchemaQrc20 {
    /**
     * The amount of a currency
     * @type {string}
     * @memberof MintSchemaQrc20
     */
    'amount': string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof MintSchemaQrc20
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface MintSchemaQrc721
 */
export interface MintSchemaQrc721 {
    /**
     * Unique identifier for the specific token
     * @type {string}
     * @memberof MintSchemaQrc721
     */
    'tokenId'?: string;
    /**
     * Name of the token
     * @type {string}
     * @memberof MintSchemaQrc721
     */
    'tokenName'?: string;
    /**
     * (Optional) String of metadata
     * @type {string}
     * @memberof MintSchemaQrc721
     */
    'metadata'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'service'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface MonitorSmartContractEventParam
 */
export interface MonitorSmartContractEventParam {
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractEventParam
     */
    'selectedIntegerLength'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractEventParam
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractEventParam
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface MonitorSmartContractRequestSchema
 */
export interface MonitorSmartContractRequestSchema {
    /**
     * 
     * @type {Array<MonitorSmartContractEventParam>}
     * @memberof MonitorSmartContractRequestSchema
     */
    'eventParams'?: Array<MonitorSmartContractEventParam>;
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractRequestSchema
     */
    'eventName'?: string;
    /**
     * 
     * @type {Location}
     * @memberof MonitorSmartContractRequestSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractRequestSchema
     */
    'callBackURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractRequestSchema
     */
    'smartContractId'?: string;
}
/**
 * 
 * @export
 * @interface NonFungibleTokenDTO
 */
export interface NonFungibleTokenDTO {
    /**
     * 
     * @type {Array<TierFunctionDTO>}
     * @memberof NonFungibleTokenDTO
     */
    'functions'?: Array<TierFunctionDTO>;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleTokenDTO
     */
    'tokenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleTokenDTO
     */
    'smartContractAddress'?: string;
    /**
     * 
     * @type {LocationDTO}
     * @memberof NonFungibleTokenDTO
     */
    'location'?: LocationDTO;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleTokenDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleTokenDTO
     */
    'tokenType'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleTokenDTO
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface NonFungibleTokenResponse
 */
export interface NonFungibleTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof NonFungibleTokenResponse
     */
    'tokenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleTokenResponse
     */
    'documentationUrl'?: string;
    /**
     * 
     * @type {Location}
     * @memberof NonFungibleTokenResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {Array<Function>}
     * @memberof NonFungibleTokenResponse
     */
    'functions'?: Array<Function>;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleTokenResponse
     */
    'contractType'?: string;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleTokenResponse
     */
    'smartContractId'?: string;
}
/**
 * Where is this transaction coming from
 * @export
 * @interface Origin
 */
export interface Origin {
    /**
     * 
     * @type {string}
     * @memberof Origin
     */
    'sequence'?: string;
    /**
     * 
     * @type {SmartContract}
     * @memberof Origin
     */
    'smartContract'?: SmartContract;
    /**
     * The unique identifier of the origin
     * @type {string}
     * @memberof Origin
     */
    'originId'?: string;
}
/**
 * List of where this transaction is coming from
 * @export
 * @interface OriginPaymentSchema
 */
export interface OriginPaymentSchema {
    /**
     * Unique Identifier of the origin/sender
     * @type {string}
     * @memberof OriginPaymentSchema
     */
    'originId': string;
}
/**
 * 
 * @export
 * @interface OriginTransferSchema
 */
export interface OriginTransferSchema {
    /**
     * 
     * @type {string}
     * @memberof OriginTransferSchema
     */
    'originId'?: string;
}
/**
 * 
 * @export
 * @interface OverledgerTransactionResponseSchema
 */
export interface OverledgerTransactionResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'requestId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'overledgerTransactionId'?: string;
    /**
     * 
     * @type {Location}
     * @memberof OverledgerTransactionResponseSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {Array<Status>}
     * @memberof OverledgerTransactionResponseSchema
     */
    'transactionHistory'?: Array<Status>;
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'transactionId'?: string;
    /**
     * 
     * @type {Status}
     * @memberof OverledgerTransactionResponseSchema
     */
    'status'?: Status;
}
/**
 * Who is the owner of the tokens.
 * @export
 * @interface Owner
 */
export interface Owner {
    /**
     * 
     * @type {string}
     * @memberof Owner
     */
    'accountId'?: string;
    /**
     * 
     * @type {Burn}
     * @memberof Owner
     */
    'burn'?: Burn;
    /**
     * 
     * @type {string}
     * @memberof Owner
     */
    'unit'?: string;
}
/**
 * Who is the owner of the tokens
 * @export
 * @interface OwnerBurnSchema
 */
export interface OwnerBurnSchema {
    /**
     * Unique Identifier of the owner
     * @type {string}
     * @memberof OwnerBurnSchema
     */
    'accountId'?: string;
    /**
     * 
     * @type {BurnSchema}
     * @memberof OwnerBurnSchema
     */
    'burn'?: BurnSchema;
}
/**
 * Who are the owner of this transaction
 * @export
 * @interface OwnerRemoveSecondarySchema
 */
export interface OwnerRemoveSecondarySchema {
    /**
     * Unique Identifier of the owner
     * @type {string}
     * @memberof OwnerRemoveSecondarySchema
     */
    'accountId'?: string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof OwnerRemoveSecondarySchema
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'page'?: number;
}
/**
 * 
 * @export
 * @interface Parameter
 */
export interface Parameter {
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    'type'?: string;
    /**
     * 
     * @type {object}
     * @memberof Parameter
     */
    'value'?: object;
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    'key'?: string;
}
/**
 * The Destination of this transaction
 * @export
 * @interface Payee
 */
export interface Payee {
    /**
     * 
     * @type {Payment}
     * @memberof Payee
     */
    'payment'?: Payment;
    /**
     * The unique identifiers of the payee
     * @type {string}
     * @memberof Payee
     */
    'payeeId'?: string;
}
/**
 * Who are the payees of this transaction
 * @export
 * @interface PayeeCreditSchema
 */
export interface PayeeCreditSchema {
    /**
     * 
     * @type {PaymentSchema}
     * @memberof PayeeCreditSchema
     */
    'payment'?: PaymentSchema;
    /**
     * The unique identifiers of the payees
     * @type {string}
     * @memberof PayeeCreditSchema
     */
    'payeeId'?: string;
}
/**
 * Where is this transaction coming from
 * @export
 * @interface Payer
 */
export interface Payer {
    /**
     * 
     * @type {string}
     * @memberof Payer
     */
    'payerId'?: string;
}
/**
 * Who are the payers of this transaction
 * @export
 * @interface PayerCreditSchema
 */
export interface PayerCreditSchema {
    /**
     * Unique Identifier of the payer
     * @type {string}
     * @memberof PayerCreditSchema
     */
    'payerId'?: string;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * The amount of a currency
     * @type {string}
     * @memberof Payment
     */
    'amount'?: string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof Payment
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'issuer'?: string;
}
/**
 * The payload request
 * @export
 * @interface PaymentRequestDetailsSchema
 */
export interface PaymentRequestDetailsSchema {
    /**
     * List of the recipients of this transaction.  **Warning:** Bitcoin transaction fees will be deducted from the last destination provided in the transaction payment request. If the last destination payment value is not enough to cover the fees, your Bitcoin payment transaction will fail
     * @type {Array<DestinationPaymentSchema>}
     * @memberof PaymentRequestDetailsSchema
     */
    'destination': Array<DestinationPaymentSchema>;
    /**
     * Any text-based element of the data payload
     * @type {string}
     * @memberof PaymentRequestDetailsSchema
     */
    'message'?: string;
    /**
     * The method of signing used to submit the transaction
     * @type {string}
     * @memberof PaymentRequestDetailsSchema
     */
    'overledgerSigningType'?: PaymentRequestDetailsSchemaOverledgerSigningTypeEnum;
    /**
     * List of where this transaction is coming from
     * @type {Array<OriginPaymentSchema>}
     * @memberof PaymentRequestDetailsSchema
     */
    'origin': Array<OriginPaymentSchema>;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentRequestDetailsSchemaOverledgerSigningTypeEnum {
    OverledgerJavascriptLibrary = 'overledger-javascript-library'
}

/**
 * The payload for each recipient
 * @export
 * @interface PaymentSchema
 */
export interface PaymentSchema {
    /**
     * The payload amount. The exact format depends on the unit of the token.
     * @type {string}
     * @memberof PaymentSchema
     */
    'amount': string;
    /**
     * The currency or token code
     * @type {string}
     * @memberof PaymentSchema
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface PrepareAddSecondaryAccountRequestSchema
 */
export interface PrepareAddSecondaryAccountRequestSchema {
    /**
     * 
     * @type {Location}
     * @memberof PrepareAddSecondaryAccountRequestSchema
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PrepareAddSecondaryAccountRequestSchema
     */
    'type': PrepareAddSecondaryAccountRequestSchemaTypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PrepareAddSecondaryAccountRequestSchema
     */
    'urgency': PrepareAddSecondaryAccountRequestSchemaUrgencyEnum;
    /**
     * 
     * @type {AddSecondaryAccountRequestDetailsSchema}
     * @memberof PrepareAddSecondaryAccountRequestSchema
     */
    'requestDetails'?: AddSecondaryAccountRequestDetailsSchema;
}

/**
    * @export
    * @enum {string}
    */
export enum PrepareAddSecondaryAccountRequestSchemaTypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PrepareAddSecondaryAccountRequestSchemaUrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface PrepareAndExecuteBalanceDetails
 */
export interface PrepareAndExecuteBalanceDetails {
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteBalanceDetails
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteBalanceDetails
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface PrepareAndExecuteOverledgerErrorResponse
 */
export interface PrepareAndExecuteOverledgerErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteOverledgerErrorResponse
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteOverledgerErrorResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteOverledgerErrorResponse
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface PrepareAndExecuteSearchAddressBalanceResponse
 */
export interface PrepareAndExecuteSearchAddressBalanceResponse {
    /**
     * 
     * @type {Array<PrepareAndExecuteBalanceDetails>}
     * @memberof PrepareAndExecuteSearchAddressBalanceResponse
     */
    'balances'?: Array<PrepareAndExecuteBalanceDetails>;
    /**
     * 
     * @type {Location}
     * @memberof PrepareAndExecuteSearchAddressBalanceResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteSearchAddressBalanceResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteSearchAddressBalanceResponse
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface PrepareAndExecuteTransactionResponse
 */
export interface PrepareAndExecuteTransactionResponse {
    /**
     * 
     * @type {PrepareTransactionResponse}
     * @memberof PrepareAndExecuteTransactionResponse
     */
    'preparationTransactionSearchResponse'?: PrepareTransactionResponse;
    /**
     * 
     * @type {ExecuteSearchTransactionResponse}
     * @memberof PrepareAndExecuteTransactionResponse
     */
    'executionTransactionSearchResponse'?: ExecuteSearchTransactionResponse;
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof PrepareAndExecuteTransactionResponse
     */
    'executionTransactionSearchOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
}
/**
 * 
 * @export
 * @interface PrepareApproveDebitTransactionRequestSchema
 */
export interface PrepareApproveDebitTransactionRequestSchema {
    /**
     * 
     * @type {Location}
     * @memberof PrepareApproveDebitTransactionRequestSchema
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PrepareApproveDebitTransactionRequestSchema
     */
    'type': PrepareApproveDebitTransactionRequestSchemaTypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PrepareApproveDebitTransactionRequestSchema
     */
    'urgency': PrepareApproveDebitTransactionRequestSchemaUrgencyEnum;
    /**
     * 
     * @type {ApproveRequestDetailsSchema}
     * @memberof PrepareApproveDebitTransactionRequestSchema
     */
    'requestDetails'?: ApproveRequestDetailsSchema;
}

/**
    * @export
    * @enum {string}
    */
export enum PrepareApproveDebitTransactionRequestSchemaTypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PrepareApproveDebitTransactionRequestSchemaUrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface PrepareBurnTransactionRequestSchema
 */
export interface PrepareBurnTransactionRequestSchema {
    /**
     * 
     * @type {Location}
     * @memberof PrepareBurnTransactionRequestSchema
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PrepareBurnTransactionRequestSchema
     */
    'type': PrepareBurnTransactionRequestSchemaTypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PrepareBurnTransactionRequestSchema
     */
    'urgency': PrepareBurnTransactionRequestSchemaUrgencyEnum;
    /**
     * 
     * @type {BurnRequestDetailsSchema}
     * @memberof PrepareBurnTransactionRequestSchema
     */
    'requestDetails'?: BurnRequestDetailsSchema;
}

/**
    * @export
    * @enum {string}
    */
export enum PrepareBurnTransactionRequestSchemaTypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PrepareBurnTransactionRequestSchemaUrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface PrepareBurnTransactionRequestSchemaQrc721
 */
export interface PrepareBurnTransactionRequestSchemaQrc721 {
    /**
     * 
     * @type {Location}
     * @memberof PrepareBurnTransactionRequestSchemaQrc721
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PrepareBurnTransactionRequestSchemaQrc721
     */
    'type': PrepareBurnTransactionRequestSchemaQrc721TypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PrepareBurnTransactionRequestSchemaQrc721
     */
    'urgency': PrepareBurnTransactionRequestSchemaQrc721UrgencyEnum;
    /**
     * 
     * @type {BurnRequestDetailsSchemaQrc721}
     * @memberof PrepareBurnTransactionRequestSchemaQrc721
     */
    'requestDetails'?: BurnRequestDetailsSchemaQrc721;
}

/**
    * @export
    * @enum {string}
    */
export enum PrepareBurnTransactionRequestSchemaQrc721TypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PrepareBurnTransactionRequestSchemaQrc721UrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface PrepareCreditTransactionRequestSchema
 */
export interface PrepareCreditTransactionRequestSchema {
    /**
     * 
     * @type {Location}
     * @memberof PrepareCreditTransactionRequestSchema
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PrepareCreditTransactionRequestSchema
     */
    'type': PrepareCreditTransactionRequestSchemaTypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PrepareCreditTransactionRequestSchema
     */
    'urgency': PrepareCreditTransactionRequestSchemaUrgencyEnum;
    /**
     * 
     * @type {CreditRequestDetailsSchema}
     * @memberof PrepareCreditTransactionRequestSchema
     */
    'requestDetails'?: CreditRequestDetailsSchema;
}

/**
    * @export
    * @enum {string}
    */
export enum PrepareCreditTransactionRequestSchemaTypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PrepareCreditTransactionRequestSchemaUrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface PrepareMintTransactionRequestSchemaQrc20
 */
export interface PrepareMintTransactionRequestSchemaQrc20 {
    /**
     * 
     * @type {Location}
     * @memberof PrepareMintTransactionRequestSchemaQrc20
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PrepareMintTransactionRequestSchemaQrc20
     */
    'type': PrepareMintTransactionRequestSchemaQrc20TypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PrepareMintTransactionRequestSchemaQrc20
     */
    'urgency': PrepareMintTransactionRequestSchemaQrc20UrgencyEnum;
    /**
     * 
     * @type {MintRequestDetailsSchemaQrc20}
     * @memberof PrepareMintTransactionRequestSchemaQrc20
     */
    'requestDetails'?: MintRequestDetailsSchemaQrc20;
}

/**
    * @export
    * @enum {string}
    */
export enum PrepareMintTransactionRequestSchemaQrc20TypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PrepareMintTransactionRequestSchemaQrc20UrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface PrepareMintTransactionRequestSchemaQrc721
 */
export interface PrepareMintTransactionRequestSchemaQrc721 {
    /**
     * 
     * @type {Location}
     * @memberof PrepareMintTransactionRequestSchemaQrc721
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PrepareMintTransactionRequestSchemaQrc721
     */
    'type': PrepareMintTransactionRequestSchemaQrc721TypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PrepareMintTransactionRequestSchemaQrc721
     */
    'urgency': PrepareMintTransactionRequestSchemaQrc721UrgencyEnum;
    /**
     * 
     * @type {MintRequestDetailsSchemaQrc721}
     * @memberof PrepareMintTransactionRequestSchemaQrc721
     */
    'requestDetails'?: MintRequestDetailsSchemaQrc721;
}

/**
    * @export
    * @enum {string}
    */
export enum PrepareMintTransactionRequestSchemaQrc721TypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PrepareMintTransactionRequestSchemaQrc721UrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface PrepareNativeTransactionRequestSchema
 */
export interface PrepareNativeTransactionRequestSchema {
    /**
     * The type of the object
     * @type {string}
     * @memberof PrepareNativeTransactionRequestSchema
     */
    'type'?: string;
    /**
     * 
     * @type {Location}
     * @memberof PrepareNativeTransactionRequestSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface PreparePaymentTransactionRequestSchema
 */
export interface PreparePaymentTransactionRequestSchema {
    /**
     * 
     * @type {Location}
     * @memberof PreparePaymentTransactionRequestSchema
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PreparePaymentTransactionRequestSchema
     */
    'type': PreparePaymentTransactionRequestSchemaTypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PreparePaymentTransactionRequestSchema
     */
    'urgency': PreparePaymentTransactionRequestSchemaUrgencyEnum;
    /**
     * 
     * @type {PaymentRequestDetailsSchema}
     * @memberof PreparePaymentTransactionRequestSchema
     */
    'requestDetails': PaymentRequestDetailsSchema;
}

/**
    * @export
    * @enum {string}
    */
export enum PreparePaymentTransactionRequestSchemaTypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PreparePaymentTransactionRequestSchemaUrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface PrepareRemoveSecondaryAccountTransactionRequestSchema
 */
export interface PrepareRemoveSecondaryAccountTransactionRequestSchema {
    /**
     * 
     * @type {RemoveSecondaryAccountDetailsSchema}
     * @memberof PrepareRemoveSecondaryAccountTransactionRequestSchema
     */
    'removeSecondaryAccountDetailsSchema'?: RemoveSecondaryAccountDetailsSchema;
}
/**
 * 
 * @export
 * @interface PrepareRequest
 */
export interface PrepareRequest {
    /**
     * 
     * @type {string}
     * @memberof PrepareRequest
     */
    'apiLookupPath'?: string;
    /**
     * 
     * @type {Array<SmartContractTag>}
     * @memberof PrepareRequest
     */
    'smartContractTag'?: Array<SmartContractTag>;
    /**
     * 
     * @type {string}
     * @memberof PrepareRequest
     */
    'urgency'?: string;
    /**
     * 
     * @type {PrepareRequestDetails}
     * @memberof PrepareRequest
     */
    'requestDetails'?: PrepareRequestDetails;
    /**
     * 
     * @type {string}
     * @memberof PrepareRequest
     */
    'smartContractAddress'?: string;
    /**
     * 
     * @type {Location}
     * @memberof PrepareRequest
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof PrepareRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PrepareRequestDetails
 */
export interface PrepareRequestDetails {
    /**
     * 
     * @type {Array<Mandate>}
     * @memberof PrepareRequestDetails
     */
    'mandate'?: Array<Mandate>;
    /**
     * 
     * @type {AliasDetails}
     * @memberof PrepareRequestDetails
     */
    'aliasDetails'?: AliasDetails;
    /**
     * 
     * @type {Pagination}
     * @memberof PrepareRequestDetails
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<Origin>}
     * @memberof PrepareRequestDetails
     */
    'origin'?: Array<Origin>;
    /**
     * 
     * @type {Array<Destination>}
     * @memberof PrepareRequestDetails
     */
    'destination'?: Array<Destination>;
    /**
     * Name of the token
     * @type {string}
     * @memberof PrepareRequestDetails
     */
    'tokenName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareRequestDetails
     */
    'blockSearchType'?: string;
    /**
     * 
     * @type {Array<Payer>}
     * @memberof PrepareRequestDetails
     */
    'payer'?: Array<Payer>;
    /**
     * 
     * @type {Collector}
     * @memberof PrepareRequestDetails
     */
    'collector'?: Collector;
    /**
     * 
     * @type {Array<Payee>}
     * @memberof PrepareRequestDetails
     */
    'payee'?: Array<Payee>;
    /**
     * 
     * @type {AdditionalOwner}
     * @memberof PrepareRequestDetails
     */
    'additionalOwner'?: AdditionalOwner;
    /**
     * 
     * @type {Owner}
     * @memberof PrepareRequestDetails
     */
    'owner'?: Owner;
    /**
     * 
     * @type {Creator}
     * @memberof PrepareRequestDetails
     */
    'creator'?: Creator;
    /**
     * 
     * @type {Array<Receiver>}
     * @memberof PrepareRequestDetails
     */
    'receiver'?: Array<Receiver>;
    /**
     * Unique identifier for the specific token
     * @type {string}
     * @memberof PrepareRequestDetails
     */
    'tokenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareRequestDetails
     */
    'message'?: string;
    /**
     * 
     * @type {LockDetails}
     * @memberof PrepareRequestDetails
     */
    'lockDetails'?: LockDetails;
    /**
     * 
     * @type {string}
     * @memberof PrepareRequestDetails
     */
    'blockId'?: string;
    /**
     * The unique identifiers of the account
     * @type {string}
     * @memberof PrepareRequestDetails
     */
    'accountId'?: string;
    /**
     * The unit of this token
     * @type {string}
     * @memberof PrepareRequestDetails
     */
    'tokenUnit'?: string;
    /**
     * 
     * @type {Beneficiary}
     * @memberof PrepareRequestDetails
     */
    'beneficiary'?: Beneficiary;
    /**
     * 
     * @type {Array<Sender>}
     * @memberof PrepareRequestDetails
     */
    'sender'?: Array<Sender>;
    /**
     * 
     * @type {AccountDetails}
     * @memberof PrepareRequestDetails
     */
    'accountDetails'?: AccountDetails;
    /**
     * 
     * @type {string}
     * @memberof PrepareRequestDetails
     */
    'overledgerSigningType'?: string;
    /**
     * 
     * @type {Payment}
     * @memberof PrepareRequestDetails
     */
    'totalPaymentAmount'?: Payment;
    /**
     * 
     * @type {SignerAccount}
     * @memberof PrepareRequestDetails
     */
    'signerAccount'?: SignerAccount;
}
/**
 * 
 * @export
 * @interface PrepareSearchResponseSchema
 */
export interface PrepareSearchResponseSchema {
    /**
     * 
     * @type {Fee}
     * @memberof PrepareSearchResponseSchema
     */
    'gatewayFee'?: Fee;
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof PrepareSearchResponseSchema
     */
    'requestId'?: string;
}
/**
 * 
 * @export
 * @interface PrepareSearchSchema
 */
export interface PrepareSearchSchema {
    /**
     * 
     * @type {Location}
     * @memberof PrepareSearchSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface PrepareSearchSmartContractRequestSchema
 */
export interface PrepareSearchSmartContractRequestSchema {
    /**
     * 
     * @type {SmartContractSearchRequestDetails}
     * @memberof PrepareSearchSmartContractRequestSchema
     */
    'requestDetails'?: SmartContractSearchRequestDetails;
    /**
     * 
     * @type {Location}
     * @memberof PrepareSearchSmartContractRequestSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface PrepareTransactionResponse
 */
export interface PrepareTransactionResponse {
    /**
     * 
     * @type {Fee}
     * @memberof PrepareTransactionResponse
     */
    'gatewayFee'?: Fee;
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof PrepareTransactionResponse
     */
    'requestId'?: string;
    /**
     * 
     * @type {Fee}
     * @memberof PrepareTransactionResponse
     */
    'dltFee'?: Fee;
    /**
     * 
     * @type {object}
     * @memberof PrepareTransactionResponse
     */
    'nativeData'?: object;
}
/**
 * 
 * @export
 * @interface PrepareTransactionSmartContractInvokeRequestSchema
 */
export interface PrepareTransactionSmartContractInvokeRequestSchema {
    /**
     * 
     * @type {Location}
     * @memberof PrepareTransactionSmartContractInvokeRequestSchema
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PrepareTransactionSmartContractInvokeRequestSchema
     */
    'type': PrepareTransactionSmartContractInvokeRequestSchemaTypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PrepareTransactionSmartContractInvokeRequestSchema
     */
    'urgency': PrepareTransactionSmartContractInvokeRequestSchemaUrgencyEnum;
    /**
     * 
     * @type {SmartContractInvokeRequestDetailsSchema}
     * @memberof PrepareTransactionSmartContractInvokeRequestSchema
     */
    'requestDetails'?: SmartContractInvokeRequestDetailsSchema;
}

/**
    * @export
    * @enum {string}
    */
export enum PrepareTransactionSmartContractInvokeRequestSchemaTypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PrepareTransactionSmartContractInvokeRequestSchemaUrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface PrepareTransferTransactionRequestSchema
 */
export interface PrepareTransferTransactionRequestSchema {
    /**
     * 
     * @type {Location}
     * @memberof PrepareTransferTransactionRequestSchema
     */
    'location': Location;
    /**
     * The type of the transaction
     * @type {string}
     * @memberof PrepareTransferTransactionRequestSchema
     */
    'type': PrepareTransferTransactionRequestSchemaTypeEnum;
    /**
     * This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
     * @type {string}
     * @memberof PrepareTransferTransactionRequestSchema
     */
    'urgency': PrepareTransferTransactionRequestSchemaUrgencyEnum;
    /**
     * 
     * @type {TransferRequestDetailsSchema}
     * @memberof PrepareTransferTransactionRequestSchema
     */
    'requestDetails'?: TransferRequestDetailsSchema;
}

/**
    * @export
    * @enum {string}
    */
export enum PrepareTransferTransactionRequestSchemaTypeEnum {
    Payment = 'Payment',
    Transfer = 'Transfer',
    ContractInvoke = 'Contract Invoke'
}
/**
    * @export
    * @enum {string}
    */
export enum PrepareTransferTransactionRequestSchemaUrgencyEnum {
    Normal = 'Normal',
    Fast = 'Fast',
    Urgent = 'Urgent'
}

/**
 * 
 * @export
 * @interface ReadAccountBalanceRequestSchema
 */
export interface ReadAccountBalanceRequestSchema {
    /**
     * 
     * @type {object}
     * @memberof ReadAccountBalanceRequestSchema
     */
    'requestDetails'?: object;
    /**
     * 
     * @type {Location}
     * @memberof ReadAccountBalanceRequestSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface ReadApprovedAccountAllowanceRequestSchema
 */
export interface ReadApprovedAccountAllowanceRequestSchema {
    /**
     * 
     * @type {object}
     * @memberof ReadApprovedAccountAllowanceRequestSchema
     */
    'requestDetails'?: object;
    /**
     * 
     * @type {Location}
     * @memberof ReadApprovedAccountAllowanceRequestSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface ReadApprovedAccountRequestDetailsSchema
 */
export interface ReadApprovedAccountRequestDetailsSchema {
    /**
     * Id of the token
     * @type {string}
     * @memberof ReadApprovedAccountRequestDetailsSchema
     */
    'tokenId'?: string;
    /**
     * Name of the token
     * @type {string}
     * @memberof ReadApprovedAccountRequestDetailsSchema
     */
    'tokenName'?: string;
}
/**
 * 
 * @export
 * @interface ReadApprovedAccountRequestSchema
 */
export interface ReadApprovedAccountRequestSchema {
    /**
     * 
     * @type {ReadApprovedAccountRequestDetailsSchema}
     * @memberof ReadApprovedAccountRequestSchema
     */
    'requestDetails'?: ReadApprovedAccountRequestDetailsSchema;
    /**
     * 
     * @type {Location}
     * @memberof ReadApprovedAccountRequestSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface ReadBalanceRequestDetailsSchema
 */
export interface ReadBalanceRequestDetailsSchema {
    /**
     * Name of the token
     * @type {string}
     * @memberof ReadBalanceRequestDetailsSchema
     */
    'tokenName'?: string;
    /**
     * The unique identifiers of the account
     * @type {string}
     * @memberof ReadBalanceRequestDetailsSchema
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface ReadBalanceRequestSchema
 */
export interface ReadBalanceRequestSchema {
    /**
     * 
     * @type {ReadBalanceRequestDetailsSchema}
     * @memberof ReadBalanceRequestSchema
     */
    'requestDetails'?: ReadBalanceRequestDetailsSchema;
    /**
     * 
     * @type {Location}
     * @memberof ReadBalanceRequestSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface ReadContractOwnerRequestDetailsSchema
 */
export interface ReadContractOwnerRequestDetailsSchema {
    /**
     * Name of the token
     * @type {string}
     * @memberof ReadContractOwnerRequestDetailsSchema
     */
    'tokenName'?: string;
}
/**
 * 
 * @export
 * @interface ReadContractOwnerRequestSchema
 */
export interface ReadContractOwnerRequestSchema {
    /**
     * 
     * @type {ReadContractOwnerRequestDetailsSchema}
     * @memberof ReadContractOwnerRequestSchema
     */
    'requestDetails'?: ReadContractOwnerRequestDetailsSchema;
    /**
     * 
     * @type {Location}
     * @memberof ReadContractOwnerRequestSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface ReadTokenOwnerRequestDetailsSchema
 */
export interface ReadTokenOwnerRequestDetailsSchema {
    /**
     * Id of the token
     * @type {string}
     * @memberof ReadTokenOwnerRequestDetailsSchema
     */
    'tokenId'?: string;
    /**
     * Name of the token
     * @type {string}
     * @memberof ReadTokenOwnerRequestDetailsSchema
     */
    'tokenName'?: string;
}
/**
 * 
 * @export
 * @interface ReadTokenOwnerRequestSchema
 */
export interface ReadTokenOwnerRequestSchema {
    /**
     * 
     * @type {ReadTokenOwnerRequestDetailsSchema}
     * @memberof ReadTokenOwnerRequestSchema
     */
    'requestDetails'?: ReadTokenOwnerRequestDetailsSchema;
    /**
     * 
     * @type {Location}
     * @memberof ReadTokenOwnerRequestSchema
     */
    'location'?: Location;
}
/**
 * The Destination of this transaction.
 * @export
 * @interface Receiver
 */
export interface Receiver {
    /**
     * 
     * @type {string}
     * @memberof Receiver
     */
    'accountId'?: string;
    /**
     * 
     * @type {Transfer}
     * @memberof Receiver
     */
    'transfer'?: Transfer;
}
/**
 * 
 * @export
 * @interface RemoveSecondaryAccountDetailsSchema
 */
export interface RemoveSecondaryAccountDetailsSchema {
    /**
     * 
     * @type {OwnerRemoveSecondarySchema}
     * @memberof RemoveSecondaryAccountDetailsSchema
     */
    'owner'?: OwnerRemoveSecondarySchema;
    /**
     * 
     * @type {AdditionalOwnerRemoveSecondarySchema}
     * @memberof RemoveSecondaryAccountDetailsSchema
     */
    'additionalOwner'?: AdditionalOwnerRemoveSecondarySchema;
    /**
     * Any text-based element of the data payload
     * @type {string}
     * @memberof RemoveSecondaryAccountDetailsSchema
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof RemoveSecondaryAccountDetailsSchema
     */
    'overledgerSigningType'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoredAddressDetails
 */
export interface ResourceMonitoredAddressDetails {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoredAddressDetails
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringAddressDetails
 */
export interface ResourceMonitoringAddressDetails {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringAddressDetails
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringAddressSchema
 */
export interface ResourceMonitoringAddressSchema {
    /**
     * 
     * @type {ResourceMonitoringAddressDetails}
     * @memberof ResourceMonitoringAddressSchema
     */
    'addressMonitoringDetails'?: ResourceMonitoringAddressDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof ResourceMonitoringAddressSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringDetails
 */
export interface ResourceMonitoringDetails {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringDetails
     */
    'resourceMonitoringId'?: string;
    /**
     * 
     * @type {Location}
     * @memberof ResourceMonitoringDetails
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringDetails
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringDetails
     */
    'timestamp'?: string;
    /**
     * 
     * @type {Status}
     * @memberof ResourceMonitoringDetails
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringSmartContractEventDetails
 */
export interface ResourceMonitoringSmartContractEventDetails {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSmartContractEventDetails
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSmartContractEventDetails
     */
    'eventParameters'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSmartContractEventDetails
     */
    'smartContractId'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringSubscription
 */
export interface ResourceMonitoringSubscription {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSubscription
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSubscription
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSubscription
     */
    'callbackUrl'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringSubscriptionDetails
 */
export interface ResourceMonitoringSubscriptionDetails {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceMonitoringSubscriptionDetails
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {Status}
     * @memberof ResourceMonitoringSubscriptionDetails
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface ScriptPubKey
 */
export interface ScriptPubKey {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScriptPubKey
     */
    'addresses'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ScriptPubKey
     */
    'asm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScriptPubKey
     */
    'hex'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScriptPubKey
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScriptPubKey
     */
    'reqSigs'?: string;
}
/**
 * 
 * @export
 * @interface SecondaryAccountAdditionalOwnerSchema
 */
export interface SecondaryAccountAdditionalOwnerSchema {
    /**
     * Unique Identifier of the owner
     * @type {string}
     * @memberof SecondaryAccountAdditionalOwnerSchema
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface SecondaryAccountOwnerSchema
 */
export interface SecondaryAccountOwnerSchema {
    /**
     * Unique Identifier of the owner
     * @type {string}
     * @memberof SecondaryAccountOwnerSchema
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecondaryAccountOwnerSchema
     */
    'unit'?: string;
}
/**
 * Where is this transaction coming from.
 * @export
 * @interface Sender
 */
export interface Sender {
    /**
     * 
     * @type {string}
     * @memberof Sender
     */
    'accountId'?: string;
}
/**
 * 
 * @export
 * @interface SignerAccount
 */
export interface SignerAccount {
    /**
     * 
     * @type {string}
     * @memberof SignerAccount
     */
    'accountId'?: string;
}
/**
 * Computer program storage in a DLT system where the outcome is recorded on the distributed ledger
 * @export
 * @interface SmartContract
 */
export interface SmartContract {
    /**
     * 
     * @type {string}
     * @memberof SmartContract
     */
    'detail'?: string;
    /**
     * Information on the object type
     * @type {string}
     * @memberof SmartContract
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContract
     */
    'smartContractId'?: string;
    /**
     * 
     * @type {Function}
     * @memberof SmartContract
     */
    'function'?: Function;
    /**
     * 
     * @type {object}
     * @memberof SmartContract
     */
    'extraFields'?: object;
}
/**
 * 
 * @export
 * @interface SmartContractDestinationSchema
 */
export interface SmartContractDestinationSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractDestinationSchema
     */
    'destinationId'?: string;
    /**
     * 
     * @type {SmartContractSchema}
     * @memberof SmartContractDestinationSchema
     */
    'smartContract'?: SmartContractSchema;
    /**
     * 
     * @type {SmartContractPaymentSchema}
     * @memberof SmartContractDestinationSchema
     */
    'payment'?: SmartContractPaymentSchema;
}
/**
 * 
 * @export
 * @interface SmartContractEventHistory
 */
export interface SmartContractEventHistory {
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'eventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'eventParameters'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'transactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractFunctionSchema
 */
export interface SmartContractFunctionSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractFunctionSchema
     */
    'name'?: string;
    /**
     * 
     * @type {Array<SmartContractInputParameterSchema>}
     * @memberof SmartContractFunctionSchema
     */
    'inputParameters'?: Array<SmartContractInputParameterSchema>;
}
/**
 * 
 * @export
 * @interface SmartContractInputParameterSchema
 */
export interface SmartContractInputParameterSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractInputParameterSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractInputParameterSchema
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractInvokeRequestDetailsSchema
 */
export interface SmartContractInvokeRequestDetailsSchema {
    /**
     * 
     * @type {Array<SmartContractDestinationSchema>}
     * @memberof SmartContractInvokeRequestDetailsSchema
     */
    'destination'?: Array<SmartContractDestinationSchema>;
    /**
     * 
     * @type {Array<SmartContractRequestDetailsOrigin>}
     * @memberof SmartContractInvokeRequestDetailsSchema
     */
    'origin'?: Array<SmartContractRequestDetailsOrigin>;
}
/**
 * 
 * @export
 * @interface SmartContractMonitoringDetailsSchema
 */
export interface SmartContractMonitoringDetailsSchema {
    /**
     * 
     * @type {ResourceMonitoringSmartContractEventDetails}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'smartContractEventDetails'?: ResourceMonitoringSmartContractEventDetails;
    /**
     * 
     * @type {Location}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {Array<SmartContractEventHistory>}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'smartContractEventHistory'?: Array<SmartContractEventHistory>;
    /**
     * 
     * @type {string}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'type'?: string;
    /**
     * 
     * @type {Status}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'status'?: Status;
    /**
     * 
     * @type {string}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractMonitoringSchema
 */
export interface SmartContractMonitoringSchema {
    /**
     * 
     * @type {ResourceMonitoringSmartContractEventDetails}
     * @memberof SmartContractMonitoringSchema
     */
    'smartContractEventMonitoringDetails'?: ResourceMonitoringSmartContractEventDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof SmartContractMonitoringSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
}
/**
 * 
 * @export
 * @interface SmartContractOutputParameterSchema
 */
export interface SmartContractOutputParameterSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractOutputParameterSchema
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractPaymentSchema
 */
export interface SmartContractPaymentSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractPaymentSchema
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractPaymentSchema
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractReadFunctionSchema
 */
export interface SmartContractReadFunctionSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractReadFunctionSchema
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractReadFunctionSchema
     */
    'functionId'?: string;
    /**
     * 
     * @type {Array<SmartContractInputParameterSchema>}
     * @memberof SmartContractReadFunctionSchema
     */
    'inputParameters'?: Array<SmartContractInputParameterSchema>;
    /**
     * 
     * @type {Array<SmartContractInputParameterSchema>}
     * @memberof SmartContractReadFunctionSchema
     */
    'outputParameters'?: Array<SmartContractInputParameterSchema>;
}
/**
 * Computer program storage in a DLT system where the outcome is recorded on the distributed ledger
 * @export
 * @interface SmartContractReadSchema
 */
export interface SmartContractReadSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractReadSchema
     */
    'smartContractId'?: string;
    /**
     * 
     * @type {SmartContractReadFunctionSchema}
     * @memberof SmartContractReadSchema
     */
    'function'?: SmartContractReadFunctionSchema;
}
/**
 * 
 * @export
 * @interface SmartContractRequestDetailsOrigin
 */
export interface SmartContractRequestDetailsOrigin {
    /**
     * 
     * @type {string}
     * @memberof SmartContractRequestDetailsOrigin
     */
    'originId'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractSchema
 */
export interface SmartContractSchema {
    /**
     * 
     * @type {SmartContractFunctionSchema}
     * @memberof SmartContractSchema
     */
    'function'?: SmartContractFunctionSchema;
}
/**
 * 
 * @export
 * @interface SmartContractSearchDestinationSchema
 */
export interface SmartContractSearchDestinationSchema {
    /**
     * 
     * @type {SmartContractSearchSchema}
     * @memberof SmartContractSearchDestinationSchema
     */
    'smartContract'?: SmartContractSearchSchema;
}
/**
 * 
 * @export
 * @interface SmartContractSearchFunctionSchema
 */
export interface SmartContractSearchFunctionSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractSearchFunctionSchema
     */
    'name'?: string;
    /**
     * 
     * @type {Array<SmartContractInputParameterSchema>}
     * @memberof SmartContractSearchFunctionSchema
     */
    'inputParameters'?: Array<SmartContractInputParameterSchema>;
    /**
     * 
     * @type {Array<SmartContractOutputParameterSchema>}
     * @memberof SmartContractSearchFunctionSchema
     */
    'outputParameters'?: Array<SmartContractOutputParameterSchema>;
}
/**
 * 
 * @export
 * @interface SmartContractSearchRequestDetails
 */
export interface SmartContractSearchRequestDetails {
    /**
     * 
     * @type {Array<SmartContractSearchDestinationSchema>}
     * @memberof SmartContractSearchRequestDetails
     */
    'destination'?: Array<SmartContractSearchDestinationSchema>;
}
/**
 * 
 * @export
 * @interface SmartContractSearchSchema
 */
export interface SmartContractSearchSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractSearchSchema
     */
    'smartContractId'?: string;
    /**
     * 
     * @type {SmartContractSearchFunctionSchema}
     * @memberof SmartContractSearchSchema
     */
    'function'?: SmartContractSearchFunctionSchema;
}
/**
 * 
 * @export
 * @interface SmartContractTag
 */
export interface SmartContractTag {
    /**
     * 
     * @type {string}
     * @memberof SmartContractTag
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractTag
     */
    'functionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractTag
     */
    'eventName'?: string;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * The description of an object
     * @type {string}
     * @memberof Status
     */
    'description'?: string;
    /**
     * The code of an object
     * @type {string}
     * @memberof Status
     */
    'code'?: string;
    /**
     * The message of an object
     * @type {string}
     * @memberof Status
     */
    'message'?: string;
    /**
     * The value of an object
     * @type {string}
     * @memberof Status
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface StatusUpdateMonitoringRequestSchema
 */
export interface StatusUpdateMonitoringRequestSchema {
    /**
     * 
     * @type {StatusUpdateSchema}
     * @memberof StatusUpdateMonitoringRequestSchema
     */
    'statusUpdate'?: StatusUpdateSchema;
}
/**
 * 
 * @export
 * @interface StatusUpdateSchema
 */
export interface StatusUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof StatusUpdateSchema
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface TierFunctionDTO
 */
export interface TierFunctionDTO {
    /**
     * 
     * @type {string}
     * @memberof TierFunctionDTO
     */
    'functionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TierFunctionDTO
     */
    'api'?: string;
}
/**
 * 
 * @export
 * @interface TokenReadQRC20Response
 */
export interface TokenReadQRC20Response {
    /**
     * 
     * @type {Array<TokenReadResponseDetails>}
     * @memberof TokenReadQRC20Response
     */
    'responseDetails'?: Array<TokenReadResponseDetails>;
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof TokenReadQRC20Response
     */
    'requestId'?: string;
    /**
     * 
     * @type {Location}
     * @memberof TokenReadQRC20Response
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface TokenReadQRC721Response
 */
export interface TokenReadQRC721Response {
    /**
     * Name of the token
     * @type {string}
     * @memberof TokenReadQRC721Response
     */
    'tokenName'?: string;
    /**
     * 
     * @type {TokenReadResponseDetails}
     * @memberof TokenReadQRC721Response
     */
    'responseDetails'?: TokenReadResponseDetails;
    /**
     * 
     * @type {Location}
     * @memberof TokenReadQRC721Response
     */
    'location'?: Location;
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof TokenReadQRC721Response
     */
    'requestId'?: string;
}
/**
 * 
 * @export
 * @interface TokenReadResponseDetails
 */
export interface TokenReadResponseDetails {
    /**
     * 
     * @type {string}
     * @memberof TokenReadResponseDetails
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenReadResponseDetails
     */
    'type'?: string;
    /**
     * 
     * @type {object}
     * @memberof TokenReadResponseDetails
     */
    'value'?: object;
}
/**
 * Smallest unit of a work process related to interactions with distributed ledgers
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * The signatures of this transaction
     * @type {Array<string>}
     * @memberof Transaction
     */
    'signature'?: Array<string>;
    /**
     * 
     * @type {Array<Origin>}
     * @memberof Transaction
     */
    'origin'?: Array<Origin>;
    /**
     * 
     * @type {Fee}
     * @memberof Transaction
     */
    'fee'?: Fee;
    /**
     * 
     * @type {Array<Destination>}
     * @memberof Transaction
     */
    'destination'?: Array<Destination>;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'signed'?: string;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof Transaction
     */
    'totalPaymentAmount'?: Array<Payment>;
    /**
     * Any text-based element of the data payload
     * @type {string}
     * @memberof Transaction
     */
    'message'?: string;
    /**
     * The unique identifier of the transaction on this DLN
     * @type {string}
     * @memberof Transaction
     */
    'transactionId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Transaction
     */
    'encoded'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof Transaction
     */
    'extraFields'?: object;
    /**
     * 
     * @type {object}
     * @memberof Transaction
     */
    'nativeData'?: object;
}
/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'tokenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'tokenName'?: string;
}
/**
 * 
 * @export
 * @interface TransferRequestDetailsSchema
 */
export interface TransferRequestDetailsSchema {
    /**
     * 
     * @type {Array<DestinationTransferSchema>}
     * @memberof TransferRequestDetailsSchema
     */
    'destination'?: Array<DestinationTransferSchema>;
    /**
     * 
     * @type {string}
     * @memberof TransferRequestDetailsSchema
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferRequestDetailsSchema
     */
    'overledgerSigningType'?: string;
    /**
     * 
     * @type {Array<OriginTransferSchema>}
     * @memberof TransferRequestDetailsSchema
     */
    'origin'?: Array<OriginTransferSchema>;
}
/**
 * 
 * @export
 * @interface TransferSchema
 */
export interface TransferSchema {
    /**
     * 
     * @type {string}
     * @memberof TransferSchema
     */
    'tokenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSchema
     */
    'tokenName'?: string;
}
/**
 * 
 * @export
 * @interface UTXODestination
 */
export interface UTXODestination {
    /**
     * 
     * @type {string}
     * @memberof UTXODestination
     */
    'destinationId'?: string;
    /**
     * 
     * @type {UTXOSmartContract}
     * @memberof UTXODestination
     */
    'smartContract'?: UTXOSmartContract;
    /**
     * 
     * @type {Payment}
     * @memberof UTXODestination
     */
    'payment'?: Payment;
}
/**
 * 
 * @export
 * @interface UTXONativeData
 */
export interface UTXONativeData {
    /**
     * 
     * @type {Array<Vout>}
     * @memberof UTXONativeData
     */
    'vout'?: Array<Vout>;
}
/**
 * 
 * @export
 * @interface UTXOSmartContract
 */
export interface UTXOSmartContract {
    /**
     * 
     * @type {string}
     * @memberof UTXOSmartContract
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UTXOSmartContract
     */
    'detail'?: string;
    /**
     * 
     * @type {ExtraFields}
     * @memberof UTXOSmartContract
     */
    'extraFields'?: ExtraFields;
}
/**
 * 
 * @export
 * @interface UpdateAddressMonitoringSchema
 */
export interface UpdateAddressMonitoringSchema {
    /**
     * 
     * @type {ResourceMonitoringAddressDetails}
     * @memberof UpdateAddressMonitoringSchema
     */
    'addressMonitoringDetails'?: ResourceMonitoringAddressDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof UpdateAddressMonitoringSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
}
/**
 * 
 * @export
 * @interface UpdateWebhookSubscriptionRequestSchema
 */
export interface UpdateWebhookSubscriptionRequestSchema {
    /**
     * 
     * @type {WebhookStatusUpdateSchema}
     * @memberof UpdateWebhookSubscriptionRequestSchema
     */
    'statusUpdate'?: WebhookStatusUpdateSchema;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookSubscriptionRequestSchema
     */
    'callbackUrl'?: string;
}
/**
 * 
 * @export
 * @interface Vout
 */
export interface Vout {
    /**
     * 
     * @type {ScriptPubKey}
     * @memberof Vout
     */
    'scriptPubKey'?: ScriptPubKey;
    /**
     * 
     * @type {number}
     * @memberof Vout
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vout
     */
    'n'?: number;
}
/**
 * 
 * @export
 * @interface WebhookStatusUpdateSchema
 */
export interface WebhookStatusUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof WebhookStatusUpdateSchema
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface WebhookSubscriptionDetails
 */
export interface WebhookSubscriptionDetails {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhookSubscriptionDetails
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {Status}
     * @memberof WebhookSubscriptionDetails
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface WebhookSubscriptionDetailsSchema
 */
export interface WebhookSubscriptionDetailsSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhookSubscriptionDetailsSchema
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {Status}
     * @memberof WebhookSubscriptionDetailsSchema
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface WebhookSubscriptionStatusUpdateResponse
 */
export interface WebhookSubscriptionStatusUpdateResponse {
    /**
     * 
     * @type {WebhookSubscriptionDetails}
     * @memberof WebhookSubscriptionStatusUpdateResponse
     */
    'subscriptionDetails'?: WebhookSubscriptionDetails;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionStatusUpdateResponse
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionStatusUpdateResponse
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionStatusUpdateResponse
     */
    'type'?: string;
}

/**
 * AddressSearchApi - axios parameter creator
 * @export
 */
export const AddressSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the address balance search on the requested DLT.
         * @summary Prepare and automatically execute a search for an address balance on a DLT.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchAddressBalanceRequest: async (authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchAddressBalanceRequest', 'authorization', authorization)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('autoExecuteSearchAddressBalanceRequest', 'addressId', addressId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchAddressBalanceRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/address/balance/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID, searches for the address and retrieves the balance on the requested DLT. This API is only applicable for account based DLTs
         * @summary Execute a search for an address balance on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestAddressBalance: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequestAddressBalance', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequestAddressBalance', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/address/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID, searches for the address and retrieves the sequence on the requested DLT. This API is only applicable for account based DLT’s
         * @summary Execute a search for an address sequence on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestAddressSequence: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequestAddressSequence', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequestAddressSequence', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/address/sequence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform an address balance search on the requested DLT. Returns a request ID to execute
         * @summary Prepare Search for an Address Balance.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressBalanceSearchRequest: async (authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareAddressBalanceSearchRequest', 'authorization', authorization)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('prepareAddressBalanceSearchRequest', 'addressId', addressId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareAddressBalanceSearchRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/address/balance/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform an address sequence search on the requested DLT.Returns a request ID to execute
         * @summary Prepare Search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressSequenceSearchRequest: async (authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest', 'authorization', authorization)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest', 'addressId', addressId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/address/sequence/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a request ID and automatically executes the address sequence search on the requested DLT.
         * @summary Prepare and automatically execute a search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressSequenceSearchRequest1: async (authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest1', 'authorization', authorization)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest1', 'addressId', addressId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest1', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/address/sequence/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressSearchApi - functional programming interface
 * @export
 */
export const AddressSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the address balance search on the requested DLT.
         * @summary Prepare and automatically execute a search for an address balance on a DLT.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchAddressBalanceRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecuteSearchAddressBalanceResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchAddressBalanceRequest(authorization, addressId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID, searches for the address and retrieves the balance on the requested DLT. This API is only applicable for account based DLTs
         * @summary Execute a search for an address balance on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequestAddressBalance(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequestAddressBalance(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID, searches for the address and retrieves the sequence on the requested DLT. This API is only applicable for account based DLT’s
         * @summary Execute a search for an address sequence on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequestAddressSequence(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchSequenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequestAddressSequence(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform an address balance search on the requested DLT. Returns a request ID to execute
         * @summary Prepare Search for an Address Balance.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareAddressBalanceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareAddressBalanceSearchRequest(authorization, addressId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform an address sequence search on the requested DLT.Returns a request ID to execute
         * @summary Prepare Search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareAddressSequenceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareAddressSequenceSearchRequest(authorization, addressId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a request ID and automatically executes the address sequence search on the requested DLT.
         * @summary Prepare and automatically execute a search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareAddressSequenceSearchRequest1(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecSearchAddressSequenceResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareAddressSequenceSearchRequest1(authorization, addressId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressSearchApi - factory interface
 * @export
 */
export const AddressSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the address balance search on the requested DLT.
         * @summary Prepare and automatically execute a search for an address balance on a DLT.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchAddressBalanceRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecuteSearchAddressBalanceResponseSchema> {
            return localVarFp.autoExecuteSearchAddressBalanceRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID, searches for the address and retrieves the balance on the requested DLT. This API is only applicable for account based DLTs
         * @summary Execute a search for an address balance on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestAddressBalance(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchBalanceResponse> {
            return localVarFp.executePreparedSearchRequestAddressBalance(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID, searches for the address and retrieves the sequence on the requested DLT. This API is only applicable for account based DLT’s
         * @summary Execute a search for an address sequence on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestAddressSequence(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchSequenceResponse> {
            return localVarFp.executePreparedSearchRequestAddressSequence(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform an address balance search on the requested DLT. Returns a request ID to execute
         * @summary Prepare Search for an Address Balance.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressBalanceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareAddressBalanceSearchRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform an address sequence search on the requested DLT.Returns a request ID to execute
         * @summary Prepare Search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressSequenceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareAddressSequenceSearchRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a request ID and automatically executes the address sequence search on the requested DLT.
         * @summary Prepare and automatically execute a search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressSequenceSearchRequest1(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecSearchAddressSequenceResponseSchema> {
            return localVarFp.prepareAddressSequenceSearchRequest1(authorization, addressId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressSearchApi - object-oriented interface
 * @export
 * @class AddressSearchApi
 * @extends {BaseAPI}
 */
export class AddressSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the address balance search on the requested DLT.
     * @summary Prepare and automatically execute a search for an address balance on a DLT.
     * @param {string} authorization 
     * @param {string} addressId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public autoExecuteSearchAddressBalanceRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).autoExecuteSearchAddressBalanceRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID, searches for the address and retrieves the balance on the requested DLT. This API is only applicable for account based DLTs
     * @summary Execute a search for an address balance on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public executePreparedSearchRequestAddressBalance(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).executePreparedSearchRequestAddressBalance(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID, searches for the address and retrieves the sequence on the requested DLT. This API is only applicable for account based DLT’s
     * @summary Execute a search for an address sequence on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public executePreparedSearchRequestAddressSequence(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).executePreparedSearchRequestAddressSequence(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform an address balance search on the requested DLT. Returns a request ID to execute
     * @summary Prepare Search for an Address Balance.
     * @param {string} authorization 
     * @param {string} addressId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public prepareAddressBalanceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).prepareAddressBalanceSearchRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform an address sequence search on the requested DLT.Returns a request ID to execute
     * @summary Prepare Search for an Address Sequence.
     * @param {string} authorization 
     * @param {string} addressId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public prepareAddressSequenceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).prepareAddressSequenceSearchRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a request ID and automatically executes the address sequence search on the requested DLT.
     * @summary Prepare and automatically execute a search for an Address Sequence.
     * @param {string} authorization 
     * @param {string} addressId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public prepareAddressSequenceSearchRequest1(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).prepareAddressSequenceSearchRequest1(authorization, addressId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockSearchApi - axios parameter creator
 * @export
 */
export const BlockSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the block search on the requested DLT.
         * @summary Prepare and automatically execute a search for a block on a DLT.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchBlockRequest: async (authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchBlockRequest', 'authorization', authorization)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('autoExecuteSearchBlockRequest', 'blockId', blockId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchBlockRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/block/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID and searches for the block on the requested DLT based on the parameters specified in the prepare request
         * @summary Execute a search for a block on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestBlock: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequestBlock', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequestBlock', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a request ID for executing a block search on the requested DLT. Block searches can be prepared based on the Block ID, Block Number or for the latest block at the time
         * @summary Prepare Search Block by Block Id.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchBlockByBlockId: async (authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSearchBlockByBlockId', 'authorization', authorization)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('prepareSearchBlockByBlockId', 'blockId', blockId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareSearchBlockByBlockId', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/block/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockSearchApi - functional programming interface
 * @export
 */
export const BlockSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the block search on the requested DLT.
         * @summary Prepare and automatically execute a search for a block on a DLT.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchBlockRequest(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecuteSearchBlockResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchBlockRequest(authorization, blockId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID and searches for the block on the requested DLT based on the parameters specified in the prepare request
         * @summary Execute a search for a block on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequestBlock(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequestBlock(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a request ID for executing a block search on the requested DLT. Block searches can be prepared based on the Block ID, Block Number or for the latest block at the time
         * @summary Prepare Search Block by Block Id.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSearchBlockByBlockId(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSearchBlockByBlockId(authorization, blockId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlockSearchApi - factory interface
 * @export
 */
export const BlockSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the block search on the requested DLT.
         * @summary Prepare and automatically execute a search for a block on a DLT.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchBlockRequest(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecuteSearchBlockResponseSchema> {
            return localVarFp.autoExecuteSearchBlockRequest(authorization, blockId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID and searches for the block on the requested DLT based on the parameters specified in the prepare request
         * @summary Execute a search for a block on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestBlock(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchBlockResponse> {
            return localVarFp.executePreparedSearchRequestBlock(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a request ID for executing a block search on the requested DLT. Block searches can be prepared based on the Block ID, Block Number or for the latest block at the time
         * @summary Prepare Search Block by Block Id.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchBlockByBlockId(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareSearchBlockByBlockId(authorization, blockId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockSearchApi - object-oriented interface
 * @export
 * @class BlockSearchApi
 * @extends {BaseAPI}
 */
export class BlockSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the block search on the requested DLT.
     * @summary Prepare and automatically execute a search for a block on a DLT.
     * @param {string} authorization 
     * @param {string} blockId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockSearchApi
     */
    public autoExecuteSearchBlockRequest(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return BlockSearchApiFp(this.configuration).autoExecuteSearchBlockRequest(authorization, blockId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID and searches for the block on the requested DLT based on the parameters specified in the prepare request
     * @summary Execute a search for a block on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockSearchApi
     */
    public executePreparedSearchRequestBlock(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return BlockSearchApiFp(this.configuration).executePreparedSearchRequestBlock(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a request ID for executing a block search on the requested DLT. Block searches can be prepared based on the Block ID, Block Number or for the latest block at the time
     * @summary Prepare Search Block by Block Id.
     * @param {string} authorization 
     * @param {string} blockId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockSearchApi
     */
    public prepareSearchBlockByBlockId(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return BlockSearchApiFp(this.configuration).prepareSearchBlockByBlockId(authorization, blockId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateAQRC20CreditTransactionApi - axios parameter creator
 * @export
 */
export const CreateAQRC20CreditTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction: async (authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'authorization', authorization)
            // verify required parameter 'executeTransactionRequest' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'executeTransactionRequest', executeTransactionRequest)
            const localVarPath = `/v2/execution/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is “Create Credit” which will allow you to make a payment to another specified account.
         * @summary Prepare a QRC20 token credit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareCreditRequest: async (authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareCreditRequest', 'authorization', authorization)
            // verify required parameter 'prepareCreditTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareCreditRequest', 'prepareCreditTransactionRequestSchema', prepareCreditTransactionRequestSchema)
            const localVarPath = `/v2/preparation/credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareCreditTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateAQRC20CreditTransactionApi - functional programming interface
 * @export
 */
export const CreateAQRC20CreditTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateAQRC20CreditTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedRequestTransaction(authorization, executeTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is “Create Credit” which will allow you to make a payment to another specified account.
         * @summary Prepare a QRC20 token credit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareCreditRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareCreditRequest(authorization, prepareCreditTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateAQRC20CreditTransactionApi - factory interface
 * @export
 */
export const CreateAQRC20CreditTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateAQRC20CreditTransactionApiFp(configuration)
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: any): AxiosPromise<ExecuteTransactionResponse> {
            return localVarFp.executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is “Create Credit” which will allow you to make a payment to another specified account.
         * @summary Prepare a QRC20 token credit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareCreditRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareCreditRequest(authorization, prepareCreditTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateAQRC20CreditTransactionApi - object-oriented interface
 * @export
 * @class CreateAQRC20CreditTransactionApi
 * @extends {BaseAPI}
 */
export class CreateAQRC20CreditTransactionApi extends BaseAPI {
    /**
     * Takes a request ID and submits a signed transaction to the requested DLT.
     * @summary Execute a transaction on a DLT
     * @param {string} authorization 
     * @param {ExecuteTransactionRequest} executeTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAQRC20CreditTransactionApi
     */
    public executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig) {
        return CreateAQRC20CreditTransactionApiFp(this.configuration).executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is “Create Credit” which will allow you to make a payment to another specified account.
     * @summary Prepare a QRC20 token credit transaction for signing
     * @param {string} authorization 
     * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAQRC20CreditTransactionApi
     */
    public prepareCreditRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateAQRC20CreditTransactionApiFp(this.configuration).prepareCreditRequest(authorization, prepareCreditTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateAQRC20DebitTransactionApi - axios parameter creator
 * @export
 */
export const CreateAQRC20DebitTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction: async (authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'authorization', authorization)
            // verify required parameter 'executeTransactionRequest' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'executeTransactionRequest', executeTransactionRequest)
            const localVarPath = `/v2/execution/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are “Approve Debit” and “Create Debit”. The ‘Approve Debit’ transaction type will allow you to approve someone to make a pull payment from your account and the “Create Debit” transaction type will create the payment to pull the approved amount from an account.
         * @summary Prepare a QRC20 token debit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDebitRequest: async (authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareDebitRequest', 'authorization', authorization)
            // verify required parameter 'prepareCreditTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareDebitRequest', 'prepareCreditTransactionRequestSchema', prepareCreditTransactionRequestSchema)
            const localVarPath = `/v2/preparation/debit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareCreditTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateAQRC20DebitTransactionApi - functional programming interface
 * @export
 */
export const CreateAQRC20DebitTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateAQRC20DebitTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedRequestTransaction(authorization, executeTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are “Approve Debit” and “Create Debit”. The ‘Approve Debit’ transaction type will allow you to approve someone to make a pull payment from your account and the “Create Debit” transaction type will create the payment to pull the approved amount from an account.
         * @summary Prepare a QRC20 token debit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareDebitRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareDebitRequest(authorization, prepareCreditTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateAQRC20DebitTransactionApi - factory interface
 * @export
 */
export const CreateAQRC20DebitTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateAQRC20DebitTransactionApiFp(configuration)
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: any): AxiosPromise<ExecuteTransactionResponse> {
            return localVarFp.executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are “Approve Debit” and “Create Debit”. The ‘Approve Debit’ transaction type will allow you to approve someone to make a pull payment from your account and the “Create Debit” transaction type will create the payment to pull the approved amount from an account.
         * @summary Prepare a QRC20 token debit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDebitRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareDebitRequest(authorization, prepareCreditTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateAQRC20DebitTransactionApi - object-oriented interface
 * @export
 * @class CreateAQRC20DebitTransactionApi
 * @extends {BaseAPI}
 */
export class CreateAQRC20DebitTransactionApi extends BaseAPI {
    /**
     * Takes a request ID and submits a signed transaction to the requested DLT.
     * @summary Execute a transaction on a DLT
     * @param {string} authorization 
     * @param {ExecuteTransactionRequest} executeTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAQRC20DebitTransactionApi
     */
    public executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig) {
        return CreateAQRC20DebitTransactionApiFp(this.configuration).executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are “Approve Debit” and “Create Debit”. The ‘Approve Debit’ transaction type will allow you to approve someone to make a pull payment from your account and the “Create Debit” transaction type will create the payment to pull the approved amount from an account.
     * @summary Prepare a QRC20 token debit transaction for signing
     * @param {string} authorization 
     * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAQRC20DebitTransactionApi
     */
    public prepareDebitRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateAQRC20DebitTransactionApiFp(this.configuration).prepareDebitRequest(authorization, prepareCreditTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateAQRC721TokenCollectionTransactionApi - axios parameter creator
 * @export
 */
export const CreateAQRC721TokenCollectionTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are “Approve Asset Collect” and “Collect Asset”. The “Approve Asset Collect” transaction type will allow you to approve someone to subsequently make a transaction that takes the NFT from your address into their own. The “Collect Asset” transaction type will create the transaction to pull the approved NFT from an account into the receiving account. Successfully prepared transactions can then be executed using the /execution/transaction API.
         * @summary Prepare a QRC721 token collection transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareCollectRequest: async (authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareCollectRequest', 'authorization', authorization)
            // verify required parameter 'preparePaymentTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareCollectRequest', 'preparePaymentTransactionRequestSchema', preparePaymentTransactionRequestSchema)
            const localVarPath = `/v2/tokenise/preparation/transaction/qrc721/collect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preparePaymentTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateAQRC721TokenCollectionTransactionApi - functional programming interface
 * @export
 */
export const CreateAQRC721TokenCollectionTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateAQRC721TokenCollectionTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are “Approve Asset Collect” and “Collect Asset”. The “Approve Asset Collect” transaction type will allow you to approve someone to subsequently make a transaction that takes the NFT from your address into their own. The “Collect Asset” transaction type will create the transaction to pull the approved NFT from an account into the receiving account. Successfully prepared transactions can then be executed using the /execution/transaction API.
         * @summary Prepare a QRC721 token collection transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareCollectRequest(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareCollectRequest(authorization, preparePaymentTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateAQRC721TokenCollectionTransactionApi - factory interface
 * @export
 */
export const CreateAQRC721TokenCollectionTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateAQRC721TokenCollectionTransactionApiFp(configuration)
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are “Approve Asset Collect” and “Collect Asset”. The “Approve Asset Collect” transaction type will allow you to approve someone to subsequently make a transaction that takes the NFT from your address into their own. The “Collect Asset” transaction type will create the transaction to pull the approved NFT from an account into the receiving account. Successfully prepared transactions can then be executed using the /execution/transaction API.
         * @summary Prepare a QRC721 token collection transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareCollectRequest(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareCollectRequest(authorization, preparePaymentTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateAQRC721TokenCollectionTransactionApi - object-oriented interface
 * @export
 * @class CreateAQRC721TokenCollectionTransactionApi
 * @extends {BaseAPI}
 */
export class CreateAQRC721TokenCollectionTransactionApi extends BaseAPI {
    /**
     * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are “Approve Asset Collect” and “Collect Asset”. The “Approve Asset Collect” transaction type will allow you to approve someone to subsequently make a transaction that takes the NFT from your address into their own. The “Collect Asset” transaction type will create the transaction to pull the approved NFT from an account into the receiving account. Successfully prepared transactions can then be executed using the /execution/transaction API.
     * @summary Prepare a QRC721 token collection transaction for signing
     * @param {string} authorization 
     * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAQRC721TokenCollectionTransactionApi
     */
    public prepareCollectRequest(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateAQRC721TokenCollectionTransactionApiFp(this.configuration).prepareCollectRequest(authorization, preparePaymentTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateAQRC721TransferTransactionApi - axios parameter creator
 * @export
 */
export const CreateAQRC721TransferTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is “Create Transfer” which will allow you to transfer a QRC721 token to another specified account. Successfully prepared transactions can then be executed using the /execution/transaction API.
         * @summary Prepare a QRC721 token transfer transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareTransactionRequest: async (authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareTransactionRequest', 'authorization', authorization)
            // verify required parameter 'preparePaymentTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareTransactionRequest', 'preparePaymentTransactionRequestSchema', preparePaymentTransactionRequestSchema)
            const localVarPath = `/v2/tokenise/preparation/transaction/qrc721/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preparePaymentTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateAQRC721TransferTransactionApi - functional programming interface
 * @export
 */
export const CreateAQRC721TransferTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateAQRC721TransferTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is “Create Transfer” which will allow you to transfer a QRC721 token to another specified account. Successfully prepared transactions can then be executed using the /execution/transaction API.
         * @summary Prepare a QRC721 token transfer transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareTransactionRequest(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareTransactionRequest(authorization, preparePaymentTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateAQRC721TransferTransactionApi - factory interface
 * @export
 */
export const CreateAQRC721TransferTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateAQRC721TransferTransactionApiFp(configuration)
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is “Create Transfer” which will allow you to transfer a QRC721 token to another specified account. Successfully prepared transactions can then be executed using the /execution/transaction API.
         * @summary Prepare a QRC721 token transfer transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareTransactionRequest(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareTransactionRequest(authorization, preparePaymentTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateAQRC721TransferTransactionApi - object-oriented interface
 * @export
 * @class CreateAQRC721TransferTransactionApi
 * @extends {BaseAPI}
 */
export class CreateAQRC721TransferTransactionApi extends BaseAPI {
    /**
     * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is “Create Transfer” which will allow you to transfer a QRC721 token to another specified account. Successfully prepared transactions can then be executed using the /execution/transaction API.
     * @summary Prepare a QRC721 token transfer transaction for signing
     * @param {string} authorization 
     * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAQRC721TransferTransactionApi
     */
    public prepareTransactionRequest(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateAQRC721TransferTransactionApiFp(this.configuration).prepareTransactionRequest(authorization, preparePaymentTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateASubscriptionApi - axios parameter creator
 * @export
 */
export const CreateASubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a subscription to receive status updates for a transaction created in Overledger, or to receive updates each time a transaction happens on the requested DLT for a resource (e.g. address) being monitored, to the requested callback URL.  Subscriptions are created using an Overledger Transaction ID or Resource Monitoring ID
         * @summary Create a subscription for a transaction or monitored resource 
         * @param {string} authorization 
         * @param {CreateWebhookSubscriptionRequestSchema} createWebhookSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscription: async (authorization: string, createWebhookSubscriptionRequestSchema: CreateWebhookSubscriptionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('subscription', 'authorization', authorization)
            // verify required parameter 'createWebhookSubscriptionRequestSchema' is not null or undefined
            assertParamExists('subscription', 'createWebhookSubscriptionRequestSchema', createWebhookSubscriptionRequestSchema)
            const localVarPath = `/v2/webhook/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookSubscriptionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateASubscriptionApi - functional programming interface
 * @export
 */
export const CreateASubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateASubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a subscription to receive status updates for a transaction created in Overledger, or to receive updates each time a transaction happens on the requested DLT for a resource (e.g. address) being monitored, to the requested callback URL.  Subscriptions are created using an Overledger Transaction ID or Resource Monitoring ID
         * @summary Create a subscription for a transaction or monitored resource 
         * @param {string} authorization 
         * @param {CreateWebhookSubscriptionRequestSchema} createWebhookSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscription(authorization: string, createWebhookSubscriptionRequestSchema: CreateWebhookSubscriptionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateWebhookSubscriptionResponseSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscription(authorization, createWebhookSubscriptionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateASubscriptionApi - factory interface
 * @export
 */
export const CreateASubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateASubscriptionApiFp(configuration)
    return {
        /**
         * Creates a subscription to receive status updates for a transaction created in Overledger, or to receive updates each time a transaction happens on the requested DLT for a resource (e.g. address) being monitored, to the requested callback URL.  Subscriptions are created using an Overledger Transaction ID or Resource Monitoring ID
         * @summary Create a subscription for a transaction or monitored resource 
         * @param {string} authorization 
         * @param {CreateWebhookSubscriptionRequestSchema} createWebhookSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscription(authorization: string, createWebhookSubscriptionRequestSchema: CreateWebhookSubscriptionRequestSchema, options?: any): AxiosPromise<Array<CreateWebhookSubscriptionResponseSchema>> {
            return localVarFp.subscription(authorization, createWebhookSubscriptionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateASubscriptionApi - object-oriented interface
 * @export
 * @class CreateASubscriptionApi
 * @extends {BaseAPI}
 */
export class CreateASubscriptionApi extends BaseAPI {
    /**
     * Creates a subscription to receive status updates for a transaction created in Overledger, or to receive updates each time a transaction happens on the requested DLT for a resource (e.g. address) being monitored, to the requested callback URL.  Subscriptions are created using an Overledger Transaction ID or Resource Monitoring ID
     * @summary Create a subscription for a transaction or monitored resource 
     * @param {string} authorization 
     * @param {CreateWebhookSubscriptionRequestSchema} createWebhookSubscriptionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateASubscriptionApi
     */
    public subscription(authorization: string, createWebhookSubscriptionRequestSchema: CreateWebhookSubscriptionRequestSchema, options?: AxiosRequestConfig) {
        return CreateASubscriptionApiFp(this.configuration).subscription(authorization, createWebhookSubscriptionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateATransactionApi - axios parameter creator
 * @export
 */
export const CreateATransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a request ID and submits a signed native transaction to the requested DLT
         * @summary Execute a native transaction on the DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestNativeTransaction: async (authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedRequestNativeTransaction', 'authorization', authorization)
            // verify required parameter 'executeTransactionRequest' is not null or undefined
            assertParamExists('executePreparedRequestNativeTransaction', 'executeTransactionRequest', executeTransactionRequest)
            const localVarPath = `/v2/execution/nativetransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction: async (authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'authorization', authorization)
            // verify required parameter 'executeTransactionRequest' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'executeTransactionRequest', executeTransactionRequest)
            const localVarPath = `/v2/execution/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows advanced developers to submit their own DLT native transactions via Overledger. Returns a request ID for executing a DLT native transaction on the requested DLT
         * @summary Prepare a DLT native transaction
         * @param {string} authorization 
         * @param {PrepareNativeTransactionRequestSchema} prepareNativeTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareNativeTransaction: async (authorization: string, prepareNativeTransactionRequestSchema: PrepareNativeTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareNativeTransaction', 'authorization', authorization)
            // verify required parameter 'prepareNativeTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareNativeTransaction', 'prepareNativeTransactionRequestSchema', prepareNativeTransactionRequestSchema)
            const localVarPath = `/v2/preparation/nativetransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareNativeTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The first step of submitting a transaction to Overledger requires preparing the transaction for signing. This API transforms a transaction request into a payload that can be signed. It returns a request ID that is used to execute the transaction after it is signed.  There are three types of transactions supported: * Payment     * Send payments in the native token of the network     * Send payments with ERC20 fungible tokens supported by Overledger on Ethereum-compatible networks. To help you test ERC20 functionality we have deployed the QNT token on the Ethereum-based test networks we support. You can check the request samples to view an example of a Smart Contract Invoke which requests test QNT from our faucet contracts. Please note that the faucet Smart Contract ID is different for all the test networks. Here is a list of faucet ids per network:         * Ethereum Goerli Testnet: 0x8cFCC46A00d6E9e86aacFa74AC5f74e90Fb6994c  * Transfer     * Transfer ownership of ERC721 non-fungible tokens supported by Overledger on Ethereum * Contract Invoke     * Call any function on any contract deployed on Ethereum, Polygon, XDC Network or our Hyperledger Fabric Sandbox
         * @summary Prepare a DLT transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareTransactionRequest1: async (authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareTransactionRequest1', 'authorization', authorization)
            // verify required parameter 'preparePaymentTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareTransactionRequest1', 'preparePaymentTransactionRequestSchema', preparePaymentTransactionRequestSchema)
            const localVarPath = `/v2/preparation/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preparePaymentTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateATransactionApi - functional programming interface
 * @export
 */
export const CreateATransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateATransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a request ID and submits a signed native transaction to the requested DLT
         * @summary Execute a native transaction on the DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedRequestNativeTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedRequestNativeTransaction(authorization, executeTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedRequestTransaction(authorization, executeTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows advanced developers to submit their own DLT native transactions via Overledger. Returns a request ID for executing a DLT native transaction on the requested DLT
         * @summary Prepare a DLT native transaction
         * @param {string} authorization 
         * @param {PrepareNativeTransactionRequestSchema} prepareNativeTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareNativeTransaction(authorization: string, prepareNativeTransactionRequestSchema: PrepareNativeTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareNativeTransaction(authorization, prepareNativeTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The first step of submitting a transaction to Overledger requires preparing the transaction for signing. This API transforms a transaction request into a payload that can be signed. It returns a request ID that is used to execute the transaction after it is signed.  There are three types of transactions supported: * Payment     * Send payments in the native token of the network     * Send payments with ERC20 fungible tokens supported by Overledger on Ethereum-compatible networks. To help you test ERC20 functionality we have deployed the QNT token on the Ethereum-based test networks we support. You can check the request samples to view an example of a Smart Contract Invoke which requests test QNT from our faucet contracts. Please note that the faucet Smart Contract ID is different for all the test networks. Here is a list of faucet ids per network:         * Ethereum Goerli Testnet: 0x8cFCC46A00d6E9e86aacFa74AC5f74e90Fb6994c  * Transfer     * Transfer ownership of ERC721 non-fungible tokens supported by Overledger on Ethereum * Contract Invoke     * Call any function on any contract deployed on Ethereum, Polygon, XDC Network or our Hyperledger Fabric Sandbox
         * @summary Prepare a DLT transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareTransactionRequest1(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareTransactionRequest1(authorization, preparePaymentTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateATransactionApi - factory interface
 * @export
 */
export const CreateATransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateATransactionApiFp(configuration)
    return {
        /**
         * Takes a request ID and submits a signed native transaction to the requested DLT
         * @summary Execute a native transaction on the DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestNativeTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: any): AxiosPromise<ExecuteTransactionResponse> {
            return localVarFp.executePreparedRequestNativeTransaction(authorization, executeTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: any): AxiosPromise<ExecuteTransactionResponse> {
            return localVarFp.executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows advanced developers to submit their own DLT native transactions via Overledger. Returns a request ID for executing a DLT native transaction on the requested DLT
         * @summary Prepare a DLT native transaction
         * @param {string} authorization 
         * @param {PrepareNativeTransactionRequestSchema} prepareNativeTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareNativeTransaction(authorization: string, prepareNativeTransactionRequestSchema: PrepareNativeTransactionRequestSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareNativeTransaction(authorization, prepareNativeTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * The first step of submitting a transaction to Overledger requires preparing the transaction for signing. This API transforms a transaction request into a payload that can be signed. It returns a request ID that is used to execute the transaction after it is signed.  There are three types of transactions supported: * Payment     * Send payments in the native token of the network     * Send payments with ERC20 fungible tokens supported by Overledger on Ethereum-compatible networks. To help you test ERC20 functionality we have deployed the QNT token on the Ethereum-based test networks we support. You can check the request samples to view an example of a Smart Contract Invoke which requests test QNT from our faucet contracts. Please note that the faucet Smart Contract ID is different for all the test networks. Here is a list of faucet ids per network:         * Ethereum Goerli Testnet: 0x8cFCC46A00d6E9e86aacFa74AC5f74e90Fb6994c  * Transfer     * Transfer ownership of ERC721 non-fungible tokens supported by Overledger on Ethereum * Contract Invoke     * Call any function on any contract deployed on Ethereum, Polygon, XDC Network or our Hyperledger Fabric Sandbox
         * @summary Prepare a DLT transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareTransactionRequest1(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareTransactionRequest1(authorization, preparePaymentTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateATransactionApi - object-oriented interface
 * @export
 * @class CreateATransactionApi
 * @extends {BaseAPI}
 */
export class CreateATransactionApi extends BaseAPI {
    /**
     * Takes a request ID and submits a signed native transaction to the requested DLT
     * @summary Execute a native transaction on the DLT
     * @param {string} authorization 
     * @param {ExecuteTransactionRequest} executeTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateATransactionApi
     */
    public executePreparedRequestNativeTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig) {
        return CreateATransactionApiFp(this.configuration).executePreparedRequestNativeTransaction(authorization, executeTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID and submits a signed transaction to the requested DLT.
     * @summary Execute a transaction on a DLT
     * @param {string} authorization 
     * @param {ExecuteTransactionRequest} executeTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateATransactionApi
     */
    public executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig) {
        return CreateATransactionApiFp(this.configuration).executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows advanced developers to submit their own DLT native transactions via Overledger. Returns a request ID for executing a DLT native transaction on the requested DLT
     * @summary Prepare a DLT native transaction
     * @param {string} authorization 
     * @param {PrepareNativeTransactionRequestSchema} prepareNativeTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateATransactionApi
     */
    public prepareNativeTransaction(authorization: string, prepareNativeTransactionRequestSchema: PrepareNativeTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateATransactionApiFp(this.configuration).prepareNativeTransaction(authorization, prepareNativeTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The first step of submitting a transaction to Overledger requires preparing the transaction for signing. This API transforms a transaction request into a payload that can be signed. It returns a request ID that is used to execute the transaction after it is signed.  There are three types of transactions supported: * Payment     * Send payments in the native token of the network     * Send payments with ERC20 fungible tokens supported by Overledger on Ethereum-compatible networks. To help you test ERC20 functionality we have deployed the QNT token on the Ethereum-based test networks we support. You can check the request samples to view an example of a Smart Contract Invoke which requests test QNT from our faucet contracts. Please note that the faucet Smart Contract ID is different for all the test networks. Here is a list of faucet ids per network:         * Ethereum Goerli Testnet: 0x8cFCC46A00d6E9e86aacFa74AC5f74e90Fb6994c  * Transfer     * Transfer ownership of ERC721 non-fungible tokens supported by Overledger on Ethereum * Contract Invoke     * Call any function on any contract deployed on Ethereum, Polygon, XDC Network or our Hyperledger Fabric Sandbox
     * @summary Prepare a DLT transaction for signing
     * @param {string} authorization 
     * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateATransactionApi
     */
    public prepareTransactionRequest1(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateATransactionApiFp(this.configuration).prepareTransactionRequest1(authorization, preparePaymentTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateAndPayFromAQRC20SharedAccountApi - axios parameter creator
 * @export
 */
export const CreateAndPayFromAQRC20SharedAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction: async (authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'authorization', authorization)
            // verify required parameter 'executeTransactionRequest' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'executeTransactionRequest', executeTransactionRequest)
            const localVarPath = `/v2/execution/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transforms a transaction request for a QRC20 shared account to be signed and returns a request ID for executing. The supported types for this API are “Add Account”, which will add someone as an operator of your account so that they can make payments on your behalf, \"Remove Account\" which will remove someone as an operator of your account so that they can no longer make payments on your behalf and “Create Credit” for account operators to make a QRC20 token payment on behalf of the account owner. Successfully prepared transactions can then be executed using the /execution/transaction API
         * @summary Prepare a request for a QRC20 shared account
         * @param {string} authorization 
         * @param {PrepareAddSecondaryAccountRequestSchema} prepareAddSecondaryAccountRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSecondaryOwnerRequest: async (authorization: string, prepareAddSecondaryAccountRequestSchema: PrepareAddSecondaryAccountRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSecondaryOwnerRequest', 'authorization', authorization)
            // verify required parameter 'prepareAddSecondaryAccountRequestSchema' is not null or undefined
            assertParamExists('prepareSecondaryOwnerRequest', 'prepareAddSecondaryAccountRequestSchema', prepareAddSecondaryAccountRequestSchema)
            const localVarPath = `/v2/preparation/secondaryaccountowner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareAddSecondaryAccountRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateAndPayFromAQRC20SharedAccountApi - functional programming interface
 * @export
 */
export const CreateAndPayFromAQRC20SharedAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateAndPayFromAQRC20SharedAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedRequestTransaction(authorization, executeTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Transforms a transaction request for a QRC20 shared account to be signed and returns a request ID for executing. The supported types for this API are “Add Account”, which will add someone as an operator of your account so that they can make payments on your behalf, \"Remove Account\" which will remove someone as an operator of your account so that they can no longer make payments on your behalf and “Create Credit” for account operators to make a QRC20 token payment on behalf of the account owner. Successfully prepared transactions can then be executed using the /execution/transaction API
         * @summary Prepare a request for a QRC20 shared account
         * @param {string} authorization 
         * @param {PrepareAddSecondaryAccountRequestSchema} prepareAddSecondaryAccountRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSecondaryOwnerRequest(authorization: string, prepareAddSecondaryAccountRequestSchema: PrepareAddSecondaryAccountRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSecondaryOwnerRequest(authorization, prepareAddSecondaryAccountRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateAndPayFromAQRC20SharedAccountApi - factory interface
 * @export
 */
export const CreateAndPayFromAQRC20SharedAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateAndPayFromAQRC20SharedAccountApiFp(configuration)
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: any): AxiosPromise<ExecuteTransactionResponse> {
            return localVarFp.executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Transforms a transaction request for a QRC20 shared account to be signed and returns a request ID for executing. The supported types for this API are “Add Account”, which will add someone as an operator of your account so that they can make payments on your behalf, \"Remove Account\" which will remove someone as an operator of your account so that they can no longer make payments on your behalf and “Create Credit” for account operators to make a QRC20 token payment on behalf of the account owner. Successfully prepared transactions can then be executed using the /execution/transaction API
         * @summary Prepare a request for a QRC20 shared account
         * @param {string} authorization 
         * @param {PrepareAddSecondaryAccountRequestSchema} prepareAddSecondaryAccountRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSecondaryOwnerRequest(authorization: string, prepareAddSecondaryAccountRequestSchema: PrepareAddSecondaryAccountRequestSchema, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareSecondaryOwnerRequest(authorization, prepareAddSecondaryAccountRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateAndPayFromAQRC20SharedAccountApi - object-oriented interface
 * @export
 * @class CreateAndPayFromAQRC20SharedAccountApi
 * @extends {BaseAPI}
 */
export class CreateAndPayFromAQRC20SharedAccountApi extends BaseAPI {
    /**
     * Takes a request ID and submits a signed transaction to the requested DLT.
     * @summary Execute a transaction on a DLT
     * @param {string} authorization 
     * @param {ExecuteTransactionRequest} executeTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAndPayFromAQRC20SharedAccountApi
     */
    public executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig) {
        return CreateAndPayFromAQRC20SharedAccountApiFp(this.configuration).executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transforms a transaction request for a QRC20 shared account to be signed and returns a request ID for executing. The supported types for this API are “Add Account”, which will add someone as an operator of your account so that they can make payments on your behalf, \"Remove Account\" which will remove someone as an operator of your account so that they can no longer make payments on your behalf and “Create Credit” for account operators to make a QRC20 token payment on behalf of the account owner. Successfully prepared transactions can then be executed using the /execution/transaction API
     * @summary Prepare a request for a QRC20 shared account
     * @param {string} authorization 
     * @param {PrepareAddSecondaryAccountRequestSchema} prepareAddSecondaryAccountRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAndPayFromAQRC20SharedAccountApi
     */
    public prepareSecondaryOwnerRequest(authorization: string, prepareAddSecondaryAccountRequestSchema: PrepareAddSecondaryAccountRequestSchema, options?: AxiosRequestConfig) {
        return CreateAndPayFromAQRC20SharedAccountApiFp(this.configuration).prepareSecondaryOwnerRequest(authorization, prepareAddSecondaryAccountRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FungibleTokenControllerApi - axios parameter creator
 * @export
 */
export const FungibleTokenControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} technology 
         * @param {string} network 
         * @param {string} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (technology: string, network: string, unit: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'technology' is not null or undefined
            assertParamExists('getToken', 'technology', technology)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getToken', 'network', network)
            // verify required parameter 'unit' is not null or undefined
            assertParamExists('getToken', 'unit', unit)
            const localVarPath = `/v2/token/fungible`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (technology !== undefined) {
                localVarQueryParameter['technology'] = technology;
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FungibleTokenControllerApi - functional programming interface
 * @export
 */
export const FungibleTokenControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FungibleTokenControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} technology 
         * @param {string} network 
         * @param {string} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(technology: string, network: string, unit: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Erc20DTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(technology, network, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FungibleTokenControllerApi - factory interface
 * @export
 */
export const FungibleTokenControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FungibleTokenControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} technology 
         * @param {string} network 
         * @param {string} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(technology: string, network: string, unit: string, options?: any): AxiosPromise<Erc20DTO> {
            return localVarFp.getToken(technology, network, unit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FungibleTokenControllerApi - object-oriented interface
 * @export
 * @class FungibleTokenControllerApi
 * @extends {BaseAPI}
 */
export class FungibleTokenControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} technology 
     * @param {string} network 
     * @param {string} unit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FungibleTokenControllerApi
     */
    public getToken(technology: string, network: string, unit: string, options?: AxiosRequestConfig) {
        return FungibleTokenControllerApiFp(this.configuration).getToken(technology, network, unit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MDAppTransactionQueryApi - axios parameter creator
 * @export
 */
export const MDAppTransactionQueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information for a specific transaction based on a given Overledger Transaction ID. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve information about a specific transaction created by your application in Overledger
         * @param {string} authorization 
         * @param {string} overledgertransactionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvlTransactionByTxId: async (authorization: string, overledgertransactionid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getOvlTransactionByTxId', 'authorization', authorization)
            // verify required parameter 'overledgertransactionid' is not null or undefined
            assertParamExists('getOvlTransactionByTxId', 'overledgertransactionid', overledgertransactionid)
            const localVarPath = `/v2/mdapptransaction/{overledgertransactionid}`
                .replace(`{${"overledgertransactionid"}}`, encodeURIComponent(String(overledgertransactionid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of transactions and the corresponding Overledger Transaction ID your application has created in Overledger. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve a list of transactions created by your application in Overledger
         * @param {string} authorization 
         * @param {number} [offset] 
         * @param {number} [length] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvlTransactionsByClientId: async (authorization: string, offset?: number, length?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getOvlTransactionsByClientId', 'authorization', authorization)
            const localVarPath = `/v2/mdapptransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MDAppTransactionQueryApi - functional programming interface
 * @export
 */
export const MDAppTransactionQueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MDAppTransactionQueryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns information for a specific transaction based on a given Overledger Transaction ID. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve information about a specific transaction created by your application in Overledger
         * @param {string} authorization 
         * @param {string} overledgertransactionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOvlTransactionByTxId(authorization: string, overledgertransactionid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverledgerTransactionResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOvlTransactionByTxId(authorization, overledgertransactionid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of transactions and the corresponding Overledger Transaction ID your application has created in Overledger. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve a list of transactions created by your application in Overledger
         * @param {string} authorization 
         * @param {number} [offset] 
         * @param {number} [length] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOvlTransactionsByClientId(authorization: string, offset?: number, length?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OverledgerTransactionResponseSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOvlTransactionsByClientId(authorization, offset, length, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MDAppTransactionQueryApi - factory interface
 * @export
 */
export const MDAppTransactionQueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MDAppTransactionQueryApiFp(configuration)
    return {
        /**
         * Returns information for a specific transaction based on a given Overledger Transaction ID. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve information about a specific transaction created by your application in Overledger
         * @param {string} authorization 
         * @param {string} overledgertransactionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvlTransactionByTxId(authorization: string, overledgertransactionid: string, options?: any): AxiosPromise<OverledgerTransactionResponseSchema> {
            return localVarFp.getOvlTransactionByTxId(authorization, overledgertransactionid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of transactions and the corresponding Overledger Transaction ID your application has created in Overledger. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve a list of transactions created by your application in Overledger
         * @param {string} authorization 
         * @param {number} [offset] 
         * @param {number} [length] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvlTransactionsByClientId(authorization: string, offset?: number, length?: number, options?: any): AxiosPromise<Array<OverledgerTransactionResponseSchema>> {
            return localVarFp.getOvlTransactionsByClientId(authorization, offset, length, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MDAppTransactionQueryApi - object-oriented interface
 * @export
 * @class MDAppTransactionQueryApi
 * @extends {BaseAPI}
 */
export class MDAppTransactionQueryApi extends BaseAPI {
    /**
     * Returns information for a specific transaction based on a given Overledger Transaction ID. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
     * @summary Retrieve information about a specific transaction created by your application in Overledger
     * @param {string} authorization 
     * @param {string} overledgertransactionid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDAppTransactionQueryApi
     */
    public getOvlTransactionByTxId(authorization: string, overledgertransactionid: string, options?: AxiosRequestConfig) {
        return MDAppTransactionQueryApiFp(this.configuration).getOvlTransactionByTxId(authorization, overledgertransactionid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of transactions and the corresponding Overledger Transaction ID your application has created in Overledger. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
     * @summary Retrieve a list of transactions created by your application in Overledger
     * @param {string} authorization 
     * @param {number} [offset] 
     * @param {number} [length] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDAppTransactionQueryApi
     */
    public getOvlTransactionsByClientId(authorization: string, offset?: number, length?: number, options?: AxiosRequestConfig) {
        return MDAppTransactionQueryApiFp(this.configuration).getOvlTransactionsByClientId(authorization, offset, length, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManageMonitoredResourcesApi - axios parameter creator
 * @export
 */
export const ManageMonitoredResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for a smart contract based on the given Resource Monitoring ID
         * @summary Stop monitoring a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventMonitoring: async (authorization: string, resourceMonitoringId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteEventMonitoring', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('deleteEventMonitoring', 'resourceMonitoringId', resourceMonitoringId)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevent/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for an address based on the given Resource Monitoring ID
         * @summary Stop monitoring an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceMonitoringAddress: async (authorization: string, resourceMonitoringId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteResourceMonitoringAddress', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('deleteResourceMonitoringAddress', 'resourceMonitoringId', resourceMonitoringId)
            const localVarPath = `/v2/resourcemonitoring/address/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of addresses being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of addresses being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfAddresses: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getListOfAddresses', 'authorization', authorization)
            const localVarPath = `/v2/resourcemonitoring/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all of the resources being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of all resources being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfResources: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getListOfResources', 'authorization', authorization)
            const localVarPath = `/v2/resourcemonitoring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of smart contracts being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of smart contracts being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfSmartContractEvents: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getListOfSmartContractEvents', 'authorization', authorization)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the update information recorded in Overledger for an address being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoredAddress: async (authorization: string, resourceMonitoringId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getMonitoredAddress', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('getMonitoredAddress', 'resourceMonitoringId', resourceMonitoringId)
            const localVarPath = `/v2/resourcemonitoring/address/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the update information recorded in Overledger for asmart contract being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoredSmartContractEventDetails: async (authorization: string, resourceMonitoringId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getMonitoredSmartContractEventDetails', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('getMonitoredSmartContractEventDetails', 'resourceMonitoringId', resourceMonitoringId)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevent/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to be inactive will pause Overledger recording updates for the requested smart contract
         * @summary Update the monitoring status of a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventMonitoring: async (authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateEventMonitoring', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('updateEventMonitoring', 'resourceMonitoringId', resourceMonitoringId)
            // verify required parameter 'statusUpdateMonitoringRequestSchema' is not null or undefined
            assertParamExists('updateEventMonitoring', 'statusUpdateMonitoringRequestSchema', statusUpdateMonitoringRequestSchema)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevent/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statusUpdateMonitoringRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to beinactive will pause Overledger recording updates for the requested address
         * @summary Update the monitoring status of an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceMonitoringAddress: async (authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateResourceMonitoringAddress', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('updateResourceMonitoringAddress', 'resourceMonitoringId', resourceMonitoringId)
            // verify required parameter 'statusUpdateMonitoringRequestSchema' is not null or undefined
            assertParamExists('updateResourceMonitoringAddress', 'statusUpdateMonitoringRequestSchema', statusUpdateMonitoringRequestSchema)
            const localVarPath = `/v2/resourcemonitoring/address/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statusUpdateMonitoringRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageMonitoredResourcesApi - functional programming interface
 * @export
 */
export const ManageMonitoredResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageMonitoredResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for a smart contract based on the given Resource Monitoring ID
         * @summary Stop monitoring a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventMonitoring(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContractMonitoringSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventMonitoring(authorization, resourceMonitoringId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for an address based on the given Resource Monitoring ID
         * @summary Stop monitoring an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResourceMonitoringAddressSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceMonitoringAddress(authorization, resourceMonitoringId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of addresses being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of addresses being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfAddresses(authorization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceMonitoringAddressSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfAddresses(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all of the resources being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of all resources being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfResources(authorization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SmartContractMonitoringSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfResources(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of smart contracts being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of smart contracts being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfSmartContractEvents(authorization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SmartContractMonitoringSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfSmartContractEvents(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the update information recorded in Overledger for an address being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonitoredAddress(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressMonitoringDetailsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonitoredAddress(authorization, resourceMonitoringId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the update information recorded in Overledger for asmart contract being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonitoredSmartContractEventDetails(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContractMonitoringDetailsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonitoredSmartContractEventDetails(authorization, resourceMonitoringId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to be inactive will pause Overledger recording updates for the requested smart contract
         * @summary Update the monitoring status of a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventMonitoring(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContractMonitoringSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventMonitoring(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to beinactive will pause Overledger recording updates for the requested address
         * @summary Update the monitoring status of an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAddressMonitoringSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceMonitoringAddress(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManageMonitoredResourcesApi - factory interface
 * @export
 */
export const ManageMonitoredResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageMonitoredResourcesApiFp(configuration)
    return {
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for a smart contract based on the given Resource Monitoring ID
         * @summary Stop monitoring a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventMonitoring(authorization: string, resourceMonitoringId: string, options?: any): AxiosPromise<SmartContractMonitoringSchema> {
            return localVarFp.deleteEventMonitoring(authorization, resourceMonitoringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for an address based on the given Resource Monitoring ID
         * @summary Stop monitoring an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, options?: any): AxiosPromise<DeleteResourceMonitoringAddressSchema> {
            return localVarFp.deleteResourceMonitoringAddress(authorization, resourceMonitoringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of addresses being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of addresses being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfAddresses(authorization: string, options?: any): AxiosPromise<Array<ResourceMonitoringAddressSchema>> {
            return localVarFp.getListOfAddresses(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all of the resources being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of all resources being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfResources(authorization: string, options?: any): AxiosPromise<Array<SmartContractMonitoringSchema>> {
            return localVarFp.getListOfResources(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of smart contracts being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of smart contracts being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfSmartContractEvents(authorization: string, options?: any): AxiosPromise<Array<SmartContractMonitoringSchema>> {
            return localVarFp.getListOfSmartContractEvents(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the update information recorded in Overledger for an address being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoredAddress(authorization: string, resourceMonitoringId: string, options?: any): AxiosPromise<AddressMonitoringDetailsSchema> {
            return localVarFp.getMonitoredAddress(authorization, resourceMonitoringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the update information recorded in Overledger for asmart contract being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoredSmartContractEventDetails(authorization: string, resourceMonitoringId: string, options?: any): AxiosPromise<SmartContractMonitoringDetailsSchema> {
            return localVarFp.getMonitoredSmartContractEventDetails(authorization, resourceMonitoringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to be inactive will pause Overledger recording updates for the requested smart contract
         * @summary Update the monitoring status of a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventMonitoring(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: any): AxiosPromise<SmartContractMonitoringSchema> {
            return localVarFp.updateEventMonitoring(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to beinactive will pause Overledger recording updates for the requested address
         * @summary Update the monitoring status of an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: any): AxiosPromise<UpdateAddressMonitoringSchema> {
            return localVarFp.updateResourceMonitoringAddress(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageMonitoredResourcesApi - object-oriented interface
 * @export
 * @class ManageMonitoredResourcesApi
 * @extends {BaseAPI}
 */
export class ManageMonitoredResourcesApi extends BaseAPI {
    /**
     * Deletes the tracking record in Overledger to stop Overledger from recording updates for a smart contract based on the given Resource Monitoring ID
     * @summary Stop monitoring a smart contract
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public deleteEventMonitoring(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).deleteEventMonitoring(authorization, resourceMonitoringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the tracking record in Overledger to stop Overledger from recording updates for an address based on the given Resource Monitoring ID
     * @summary Stop monitoring an address
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public deleteResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).deleteResourceMonitoringAddress(authorization, resourceMonitoringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of addresses being monitored for your application and the corresponding Resource Monitoring ID
     * @summary Retrieve a list of addresses being monitored
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getListOfAddresses(authorization: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getListOfAddresses(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all of the resources being monitored for your application and the corresponding Resource Monitoring ID
     * @summary Retrieve a list of all resources being monitored
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getListOfResources(authorization: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getListOfResources(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of smart contracts being monitored for your application and the corresponding Resource Monitoring ID
     * @summary Retrieve a list of smart contracts being monitored
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getListOfSmartContractEvents(authorization: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getListOfSmartContractEvents(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the update information recorded in Overledger for an address being monitored by your application for a given Resource Monitoring ID
     * @summary Retrieve recorded updates for a specific monitored address
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getMonitoredAddress(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getMonitoredAddress(authorization, resourceMonitoringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the update information recorded in Overledger for asmart contract being monitored by your application for a given Resource Monitoring ID
     * @summary Retrieve recorded updates for a specific monitored smart contract
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getMonitoredSmartContractEventDetails(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getMonitoredSmartContractEventDetails(authorization, resourceMonitoringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to be inactive will pause Overledger recording updates for the requested smart contract
     * @summary Update the monitoring status of a smart contract
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public updateEventMonitoring(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).updateEventMonitoring(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to beinactive will pause Overledger recording updates for the requested address
     * @summary Update the monitoring status of an address
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public updateResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).updateResourceMonitoringAddress(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManageQRC20TokenSupplyApi - axios parameter creator
 * @export
 */
export const ManageQRC20TokenSupplyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction: async (authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'authorization', authorization)
            // verify required parameter 'executeTransactionRequest' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'executeTransactionRequest', executeTransactionRequest)
            const localVarPath = `/v2/execution/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transforms a transaction request to manage QRC20 token supply ready to be signed and returns a request ID for executing. The supported types for this API are “Mint Tokens”, which will allow you to issue more tokens for your QRC20 token, and \"Burn Tokens\" which will allow you to destroy your QRC20 tokens. Successfully prepared transactions can then be executed using the /execution/transaction API.
         * @summary Prepare a request to manage QRC20 token supply
         * @param {string} authorization 
         * @param {PrepareMintTransactionRequestSchemaQrc20} prepareMintTransactionRequestSchemaQrc20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSupplyRequest1: async (authorization: string, prepareMintTransactionRequestSchemaQrc20: PrepareMintTransactionRequestSchemaQrc20, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSupplyRequest1', 'authorization', authorization)
            // verify required parameter 'prepareMintTransactionRequestSchemaQrc20' is not null or undefined
            assertParamExists('prepareSupplyRequest1', 'prepareMintTransactionRequestSchemaQrc20', prepareMintTransactionRequestSchemaQrc20)
            const localVarPath = `/v2/preparation/supply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareMintTransactionRequestSchemaQrc20, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageQRC20TokenSupplyApi - functional programming interface
 * @export
 */
export const ManageQRC20TokenSupplyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageQRC20TokenSupplyApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedRequestTransaction(authorization, executeTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Transforms a transaction request to manage QRC20 token supply ready to be signed and returns a request ID for executing. The supported types for this API are “Mint Tokens”, which will allow you to issue more tokens for your QRC20 token, and \"Burn Tokens\" which will allow you to destroy your QRC20 tokens. Successfully prepared transactions can then be executed using the /execution/transaction API.
         * @summary Prepare a request to manage QRC20 token supply
         * @param {string} authorization 
         * @param {PrepareMintTransactionRequestSchemaQrc20} prepareMintTransactionRequestSchemaQrc20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSupplyRequest1(authorization: string, prepareMintTransactionRequestSchemaQrc20: PrepareMintTransactionRequestSchemaQrc20, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSupplyRequest1(authorization, prepareMintTransactionRequestSchemaQrc20, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManageQRC20TokenSupplyApi - factory interface
 * @export
 */
export const ManageQRC20TokenSupplyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageQRC20TokenSupplyApiFp(configuration)
    return {
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on a DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: any): AxiosPromise<ExecuteTransactionResponse> {
            return localVarFp.executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Transforms a transaction request to manage QRC20 token supply ready to be signed and returns a request ID for executing. The supported types for this API are “Mint Tokens”, which will allow you to issue more tokens for your QRC20 token, and \"Burn Tokens\" which will allow you to destroy your QRC20 tokens. Successfully prepared transactions can then be executed using the /execution/transaction API.
         * @summary Prepare a request to manage QRC20 token supply
         * @param {string} authorization 
         * @param {PrepareMintTransactionRequestSchemaQrc20} prepareMintTransactionRequestSchemaQrc20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSupplyRequest1(authorization: string, prepareMintTransactionRequestSchemaQrc20: PrepareMintTransactionRequestSchemaQrc20, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareSupplyRequest1(authorization, prepareMintTransactionRequestSchemaQrc20, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageQRC20TokenSupplyApi - object-oriented interface
 * @export
 * @class ManageQRC20TokenSupplyApi
 * @extends {BaseAPI}
 */
export class ManageQRC20TokenSupplyApi extends BaseAPI {
    /**
     * Takes a request ID and submits a signed transaction to the requested DLT.
     * @summary Execute a transaction on a DLT
     * @param {string} authorization 
     * @param {ExecuteTransactionRequest} executeTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageQRC20TokenSupplyApi
     */
    public executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig) {
        return ManageQRC20TokenSupplyApiFp(this.configuration).executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transforms a transaction request to manage QRC20 token supply ready to be signed and returns a request ID for executing. The supported types for this API are “Mint Tokens”, which will allow you to issue more tokens for your QRC20 token, and \"Burn Tokens\" which will allow you to destroy your QRC20 tokens. Successfully prepared transactions can then be executed using the /execution/transaction API.
     * @summary Prepare a request to manage QRC20 token supply
     * @param {string} authorization 
     * @param {PrepareMintTransactionRequestSchemaQrc20} prepareMintTransactionRequestSchemaQrc20 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageQRC20TokenSupplyApi
     */
    public prepareSupplyRequest1(authorization: string, prepareMintTransactionRequestSchemaQrc20: PrepareMintTransactionRequestSchemaQrc20, options?: AxiosRequestConfig) {
        return ManageQRC20TokenSupplyApiFp(this.configuration).prepareSupplyRequest1(authorization, prepareMintTransactionRequestSchemaQrc20, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManageQRC721TokenSupplyApi - axios parameter creator
 * @export
 */
export const ManageQRC721TokenSupplyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transforms a transaction request to manage QRC721 token supply ready to be signed and returns a request ID for executing. The supported types for this API are “Mint Tokens”, which will allow you to issue an new NFT for your QRC721 token, and \"Burn Tokens\" which will allow you to destroy your QRC721 token. Successfully prepared transactions can then be executed using the /execution/transaction API
         * @summary Prepare a transaction to manage QRC721 token supply
         * @param {string} authorization 
         * @param {PrepareMintTransactionRequestSchemaQrc721} prepareMintTransactionRequestSchemaQrc721 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSupplyRequest: async (authorization: string, prepareMintTransactionRequestSchemaQrc721: PrepareMintTransactionRequestSchemaQrc721, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSupplyRequest', 'authorization', authorization)
            // verify required parameter 'prepareMintTransactionRequestSchemaQrc721' is not null or undefined
            assertParamExists('prepareSupplyRequest', 'prepareMintTransactionRequestSchemaQrc721', prepareMintTransactionRequestSchemaQrc721)
            const localVarPath = `/v2/tokenise/preparation/transaction/qrc721/supply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareMintTransactionRequestSchemaQrc721, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageQRC721TokenSupplyApi - functional programming interface
 * @export
 */
export const ManageQRC721TokenSupplyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageQRC721TokenSupplyApiAxiosParamCreator(configuration)
    return {
        /**
         * Transforms a transaction request to manage QRC721 token supply ready to be signed and returns a request ID for executing. The supported types for this API are “Mint Tokens”, which will allow you to issue an new NFT for your QRC721 token, and \"Burn Tokens\" which will allow you to destroy your QRC721 token. Successfully prepared transactions can then be executed using the /execution/transaction API
         * @summary Prepare a transaction to manage QRC721 token supply
         * @param {string} authorization 
         * @param {PrepareMintTransactionRequestSchemaQrc721} prepareMintTransactionRequestSchemaQrc721 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSupplyRequest(authorization: string, prepareMintTransactionRequestSchemaQrc721: PrepareMintTransactionRequestSchemaQrc721, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSupplyRequest(authorization, prepareMintTransactionRequestSchemaQrc721, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManageQRC721TokenSupplyApi - factory interface
 * @export
 */
export const ManageQRC721TokenSupplyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageQRC721TokenSupplyApiFp(configuration)
    return {
        /**
         * Transforms a transaction request to manage QRC721 token supply ready to be signed and returns a request ID for executing. The supported types for this API are “Mint Tokens”, which will allow you to issue an new NFT for your QRC721 token, and \"Burn Tokens\" which will allow you to destroy your QRC721 token. Successfully prepared transactions can then be executed using the /execution/transaction API
         * @summary Prepare a transaction to manage QRC721 token supply
         * @param {string} authorization 
         * @param {PrepareMintTransactionRequestSchemaQrc721} prepareMintTransactionRequestSchemaQrc721 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSupplyRequest(authorization: string, prepareMintTransactionRequestSchemaQrc721: PrepareMintTransactionRequestSchemaQrc721, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareSupplyRequest(authorization, prepareMintTransactionRequestSchemaQrc721, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageQRC721TokenSupplyApi - object-oriented interface
 * @export
 * @class ManageQRC721TokenSupplyApi
 * @extends {BaseAPI}
 */
export class ManageQRC721TokenSupplyApi extends BaseAPI {
    /**
     * Transforms a transaction request to manage QRC721 token supply ready to be signed and returns a request ID for executing. The supported types for this API are “Mint Tokens”, which will allow you to issue an new NFT for your QRC721 token, and \"Burn Tokens\" which will allow you to destroy your QRC721 token. Successfully prepared transactions can then be executed using the /execution/transaction API
     * @summary Prepare a transaction to manage QRC721 token supply
     * @param {string} authorization 
     * @param {PrepareMintTransactionRequestSchemaQrc721} prepareMintTransactionRequestSchemaQrc721 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageQRC721TokenSupplyApi
     */
    public prepareSupplyRequest(authorization: string, prepareMintTransactionRequestSchemaQrc721: PrepareMintTransactionRequestSchemaQrc721, options?: AxiosRequestConfig) {
        return ManageQRC721TokenSupplyApiFp(this.configuration).prepareSupplyRequest(authorization, prepareMintTransactionRequestSchemaQrc721, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManageSubscriptionsApi - axios parameter creator
 * @export
 */
export const ManageSubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a subscription created by your application based onthe given Subscription ID. Deleting a subscription will stop updates being sent to the requested callback URL
         * @summary Remove a subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription: async (authorization: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteSubscription', 'authorization', authorization)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deleteSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/v2/webhook/subscription/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of active or paused subscriptions and the corresponding Subscription IDs that were created by your application
         * @summary Retrieve a list of subscriptions created by your application
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('listSubscriptions', 'authorization', authorization)
            const localVarPath = `/v2/webhook/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the subscription callback URL and/or the subscription status to be either active or track only for the given Subscription ID. Updating the status to be track only will pause updates being sent to the requested callback URL
         * @summary Update a specific subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {UpdateWebhookSubscriptionRequestSchema} updateWebhookSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription: async (authorization: string, subscriptionId: string, updateWebhookSubscriptionRequestSchema: UpdateWebhookSubscriptionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateSubscription', 'authorization', authorization)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscription', 'subscriptionId', subscriptionId)
            // verify required parameter 'updateWebhookSubscriptionRequestSchema' is not null or undefined
            assertParamExists('updateSubscription', 'updateWebhookSubscriptionRequestSchema', updateWebhookSubscriptionRequestSchema)
            const localVarPath = `/v2/webhook/subscription/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookSubscriptionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageSubscriptionsApi - functional programming interface
 * @export
 */
export const ManageSubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageSubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a subscription created by your application based onthe given Subscription ID. Deleting a subscription will stop updates being sent to the requested callback URL
         * @summary Remove a subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscription(authorization: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscriptionStatusUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscription(authorization, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of active or paused subscriptions and the corresponding Subscription IDs that were created by your application
         * @summary Retrieve a list of subscriptions created by your application
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptions(authorization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListWebhookSubscriptionResponseSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptions(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the subscription callback URL and/or the subscription status to be either active or track only for the given Subscription ID. Updating the status to be track only will pause updates being sent to the requested callback URL
         * @summary Update a specific subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {UpdateWebhookSubscriptionRequestSchema} updateWebhookSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscription(authorization: string, subscriptionId: string, updateWebhookSubscriptionRequestSchema: UpdateWebhookSubscriptionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscriptionStatusUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscription(authorization, subscriptionId, updateWebhookSubscriptionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManageSubscriptionsApi - factory interface
 * @export
 */
export const ManageSubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageSubscriptionsApiFp(configuration)
    return {
        /**
         * Deletes a subscription created by your application based onthe given Subscription ID. Deleting a subscription will stop updates being sent to the requested callback URL
         * @summary Remove a subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(authorization: string, subscriptionId: string, options?: any): AxiosPromise<WebhookSubscriptionStatusUpdateResponse> {
            return localVarFp.deleteSubscription(authorization, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of active or paused subscriptions and the corresponding Subscription IDs that were created by your application
         * @summary Retrieve a list of subscriptions created by your application
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions(authorization: string, options?: any): AxiosPromise<Array<ListWebhookSubscriptionResponseSchema>> {
            return localVarFp.listSubscriptions(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the subscription callback URL and/or the subscription status to be either active or track only for the given Subscription ID. Updating the status to be track only will pause updates being sent to the requested callback URL
         * @summary Update a specific subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {UpdateWebhookSubscriptionRequestSchema} updateWebhookSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(authorization: string, subscriptionId: string, updateWebhookSubscriptionRequestSchema: UpdateWebhookSubscriptionRequestSchema, options?: any): AxiosPromise<WebhookSubscriptionStatusUpdateResponse> {
            return localVarFp.updateSubscription(authorization, subscriptionId, updateWebhookSubscriptionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageSubscriptionsApi - object-oriented interface
 * @export
 * @class ManageSubscriptionsApi
 * @extends {BaseAPI}
 */
export class ManageSubscriptionsApi extends BaseAPI {
    /**
     * Deletes a subscription created by your application based onthe given Subscription ID. Deleting a subscription will stop updates being sent to the requested callback URL
     * @summary Remove a subscription created by your application
     * @param {string} authorization 
     * @param {string} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageSubscriptionsApi
     */
    public deleteSubscription(authorization: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return ManageSubscriptionsApiFp(this.configuration).deleteSubscription(authorization, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of active or paused subscriptions and the corresponding Subscription IDs that were created by your application
     * @summary Retrieve a list of subscriptions created by your application
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageSubscriptionsApi
     */
    public listSubscriptions(authorization: string, options?: AxiosRequestConfig) {
        return ManageSubscriptionsApiFp(this.configuration).listSubscriptions(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the subscription callback URL and/or the subscription status to be either active or track only for the given Subscription ID. Updating the status to be track only will pause updates being sent to the requested callback URL
     * @summary Update a specific subscription created by your application
     * @param {string} authorization 
     * @param {string} subscriptionId 
     * @param {UpdateWebhookSubscriptionRequestSchema} updateWebhookSubscriptionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageSubscriptionsApi
     */
    public updateSubscription(authorization: string, subscriptionId: string, updateWebhookSubscriptionRequestSchema: UpdateWebhookSubscriptionRequestSchema, options?: AxiosRequestConfig) {
        return ManageSubscriptionsApiFp(this.configuration).updateSubscription(authorization, subscriptionId, updateWebhookSubscriptionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MonitorAResourceApi - axios parameter creator
 * @export
 */
export const MonitorAResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Overledger creates a tracking record for the given address and records information each time the given address receives or sends transactions on the DLT
         * @summary Monitor an address for incoming and outgoing transactions
         * @param {string} authorization 
         * @param {AddressMonitoringRequestSchema} addressMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceMonitoringAddress: async (authorization: string, addressMonitoringRequestSchema: AddressMonitoringRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('resourceMonitoringAddress', 'authorization', authorization)
            // verify required parameter 'addressMonitoringRequestSchema' is not null or undefined
            assertParamExists('resourceMonitoringAddress', 'addressMonitoringRequestSchema', addressMonitoringRequestSchema)
            const localVarPath = `/v2/resourcemonitoring/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressMonitoringRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Overledger creates a tracking record for the given smart contract and records information each time a transaction on the DLT triggers a specific event
         * @summary Monitor a smart contract for an event
         * @param {string} authorization 
         * @param {MonitorSmartContractRequestSchema} monitorSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackAndSubscribeEvent: async (authorization: string, monitorSmartContractRequestSchema: MonitorSmartContractRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('trackAndSubscribeEvent', 'authorization', authorization)
            // verify required parameter 'monitorSmartContractRequestSchema' is not null or undefined
            assertParamExists('trackAndSubscribeEvent', 'monitorSmartContractRequestSchema', monitorSmartContractRequestSchema)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(monitorSmartContractRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonitorAResourceApi - functional programming interface
 * @export
 */
export const MonitorAResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonitorAResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Overledger creates a tracking record for the given address and records information each time the given address receives or sends transactions on the DLT
         * @summary Monitor an address for incoming and outgoing transactions
         * @param {string} authorization 
         * @param {AddressMonitoringRequestSchema} addressMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceMonitoringAddress(authorization: string, addressMonitoringRequestSchema: AddressMonitoringRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressMonitoringResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceMonitoringAddress(authorization, addressMonitoringRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Overledger creates a tracking record for the given smart contract and records information each time a transaction on the DLT triggers a specific event
         * @summary Monitor a smart contract for an event
         * @param {string} authorization 
         * @param {MonitorSmartContractRequestSchema} monitorSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackAndSubscribeEvent(authorization: string, monitorSmartContractRequestSchema: MonitorSmartContractRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSmartContractMonitoringSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackAndSubscribeEvent(authorization, monitorSmartContractRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MonitorAResourceApi - factory interface
 * @export
 */
export const MonitorAResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonitorAResourceApiFp(configuration)
    return {
        /**
         * Overledger creates a tracking record for the given address and records information each time the given address receives or sends transactions on the DLT
         * @summary Monitor an address for incoming and outgoing transactions
         * @param {string} authorization 
         * @param {AddressMonitoringRequestSchema} addressMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceMonitoringAddress(authorization: string, addressMonitoringRequestSchema: AddressMonitoringRequestSchema, options?: any): AxiosPromise<AddressMonitoringResponseSchema> {
            return localVarFp.resourceMonitoringAddress(authorization, addressMonitoringRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Overledger creates a tracking record for the given smart contract and records information each time a transaction on the DLT triggers a specific event
         * @summary Monitor a smart contract for an event
         * @param {string} authorization 
         * @param {MonitorSmartContractRequestSchema} monitorSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackAndSubscribeEvent(authorization: string, monitorSmartContractRequestSchema: MonitorSmartContractRequestSchema, options?: any): AxiosPromise<CreateSmartContractMonitoringSchema> {
            return localVarFp.trackAndSubscribeEvent(authorization, monitorSmartContractRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonitorAResourceApi - object-oriented interface
 * @export
 * @class MonitorAResourceApi
 * @extends {BaseAPI}
 */
export class MonitorAResourceApi extends BaseAPI {
    /**
     * Overledger creates a tracking record for the given address and records information each time the given address receives or sends transactions on the DLT
     * @summary Monitor an address for incoming and outgoing transactions
     * @param {string} authorization 
     * @param {AddressMonitoringRequestSchema} addressMonitoringRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorAResourceApi
     */
    public resourceMonitoringAddress(authorization: string, addressMonitoringRequestSchema: AddressMonitoringRequestSchema, options?: AxiosRequestConfig) {
        return MonitorAResourceApiFp(this.configuration).resourceMonitoringAddress(authorization, addressMonitoringRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Overledger creates a tracking record for the given smart contract and records information each time a transaction on the DLT triggers a specific event
     * @summary Monitor a smart contract for an event
     * @param {string} authorization 
     * @param {MonitorSmartContractRequestSchema} monitorSmartContractRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorAResourceApi
     */
    public trackAndSubscribeEvent(authorization: string, monitorSmartContractRequestSchema: MonitorSmartContractRequestSchema, options?: AxiosRequestConfig) {
        return MonitorAResourceApiFp(this.configuration).trackAndSubscribeEvent(authorization, monitorSmartContractRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetrieveAccountBalanceForAQRC20TokenApi - axios parameter creator
 * @export
 */
export const RetrieveAccountBalanceForAQRC20TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a query to the Blockchain Network and returns the balance of QRC20 tokens for an account .
         * @summary Retrieve the balance of QRC20 tokens for an account
         * @param {string} authorization 
         * @param {ReadAccountBalanceRequestSchema} readAccountBalanceRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC20SmartContractBalance: async (authorization: string, readAccountBalanceRequestSchema: ReadAccountBalanceRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('readQRC20SmartContractBalance', 'authorization', authorization)
            // verify required parameter 'readAccountBalanceRequestSchema' is not null or undefined
            assertParamExists('readQRC20SmartContractBalance', 'readAccountBalanceRequestSchema', readAccountBalanceRequestSchema)
            const localVarPath = `/v2/tokenise/tokens/qrc20/account-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readAccountBalanceRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetrieveAccountBalanceForAQRC20TokenApi - functional programming interface
 * @export
 */
export const RetrieveAccountBalanceForAQRC20TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetrieveAccountBalanceForAQRC20TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns the balance of QRC20 tokens for an account .
         * @summary Retrieve the balance of QRC20 tokens for an account
         * @param {string} authorization 
         * @param {ReadAccountBalanceRequestSchema} readAccountBalanceRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readQRC20SmartContractBalance(authorization: string, readAccountBalanceRequestSchema: ReadAccountBalanceRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReadQRC20Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readQRC20SmartContractBalance(authorization, readAccountBalanceRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetrieveAccountBalanceForAQRC20TokenApi - factory interface
 * @export
 */
export const RetrieveAccountBalanceForAQRC20TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetrieveAccountBalanceForAQRC20TokenApiFp(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns the balance of QRC20 tokens for an account .
         * @summary Retrieve the balance of QRC20 tokens for an account
         * @param {string} authorization 
         * @param {ReadAccountBalanceRequestSchema} readAccountBalanceRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC20SmartContractBalance(authorization: string, readAccountBalanceRequestSchema: ReadAccountBalanceRequestSchema, options?: any): AxiosPromise<TokenReadQRC20Response> {
            return localVarFp.readQRC20SmartContractBalance(authorization, readAccountBalanceRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetrieveAccountBalanceForAQRC20TokenApi - object-oriented interface
 * @export
 * @class RetrieveAccountBalanceForAQRC20TokenApi
 * @extends {BaseAPI}
 */
export class RetrieveAccountBalanceForAQRC20TokenApi extends BaseAPI {
    /**
     * Submits a query to the Blockchain Network and returns the balance of QRC20 tokens for an account .
     * @summary Retrieve the balance of QRC20 tokens for an account
     * @param {string} authorization 
     * @param {ReadAccountBalanceRequestSchema} readAccountBalanceRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetrieveAccountBalanceForAQRC20TokenApi
     */
    public readQRC20SmartContractBalance(authorization: string, readAccountBalanceRequestSchema: ReadAccountBalanceRequestSchema, options?: AxiosRequestConfig) {
        return RetrieveAccountBalanceForAQRC20TokenApiFp(this.configuration).readQRC20SmartContractBalance(authorization, readAccountBalanceRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetrieveApprovedAccountAllowanceForAQRC20TokenApi - axios parameter creator
 * @export
 */
export const RetrieveApprovedAccountAllowanceForAQRC20TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a query to the Blockchain Network and returns the number of QRC20 tokens a particular account is allowed to debit from another account
         * @summary Retrieve how many QRC20 tokens an address is allowed to debit
         * @param {string} authorization 
         * @param {ReadApprovedAccountAllowanceRequestSchema} readApprovedAccountAllowanceRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readApprovedDebitAmount: async (authorization: string, readApprovedAccountAllowanceRequestSchema: ReadApprovedAccountAllowanceRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('readApprovedDebitAmount', 'authorization', authorization)
            // verify required parameter 'readApprovedAccountAllowanceRequestSchema' is not null or undefined
            assertParamExists('readApprovedDebitAmount', 'readApprovedAccountAllowanceRequestSchema', readApprovedAccountAllowanceRequestSchema)
            const localVarPath = `/v2/tokenise/tokens/qrc20/approved-debit-amount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readApprovedAccountAllowanceRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetrieveApprovedAccountAllowanceForAQRC20TokenApi - functional programming interface
 * @export
 */
export const RetrieveApprovedAccountAllowanceForAQRC20TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetrieveApprovedAccountAllowanceForAQRC20TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns the number of QRC20 tokens a particular account is allowed to debit from another account
         * @summary Retrieve how many QRC20 tokens an address is allowed to debit
         * @param {string} authorization 
         * @param {ReadApprovedAccountAllowanceRequestSchema} readApprovedAccountAllowanceRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readApprovedDebitAmount(authorization: string, readApprovedAccountAllowanceRequestSchema: ReadApprovedAccountAllowanceRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReadQRC20Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readApprovedDebitAmount(authorization, readApprovedAccountAllowanceRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetrieveApprovedAccountAllowanceForAQRC20TokenApi - factory interface
 * @export
 */
export const RetrieveApprovedAccountAllowanceForAQRC20TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetrieveApprovedAccountAllowanceForAQRC20TokenApiFp(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns the number of QRC20 tokens a particular account is allowed to debit from another account
         * @summary Retrieve how many QRC20 tokens an address is allowed to debit
         * @param {string} authorization 
         * @param {ReadApprovedAccountAllowanceRequestSchema} readApprovedAccountAllowanceRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readApprovedDebitAmount(authorization: string, readApprovedAccountAllowanceRequestSchema: ReadApprovedAccountAllowanceRequestSchema, options?: any): AxiosPromise<TokenReadQRC20Response> {
            return localVarFp.readApprovedDebitAmount(authorization, readApprovedAccountAllowanceRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetrieveApprovedAccountAllowanceForAQRC20TokenApi - object-oriented interface
 * @export
 * @class RetrieveApprovedAccountAllowanceForAQRC20TokenApi
 * @extends {BaseAPI}
 */
export class RetrieveApprovedAccountAllowanceForAQRC20TokenApi extends BaseAPI {
    /**
     * Submits a query to the Blockchain Network and returns the number of QRC20 tokens a particular account is allowed to debit from another account
     * @summary Retrieve how many QRC20 tokens an address is allowed to debit
     * @param {string} authorization 
     * @param {ReadApprovedAccountAllowanceRequestSchema} readApprovedAccountAllowanceRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetrieveApprovedAccountAllowanceForAQRC20TokenApi
     */
    public readApprovedDebitAmount(authorization: string, readApprovedAccountAllowanceRequestSchema: ReadApprovedAccountAllowanceRequestSchema, options?: AxiosRequestConfig) {
        return RetrieveApprovedAccountAllowanceForAQRC20TokenApiFp(this.configuration).readApprovedDebitAmount(authorization, readApprovedAccountAllowanceRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetrieveApprovedAccountInformationForAQRC20TokenApi - axios parameter creator
 * @export
 */
export const RetrieveApprovedAccountInformationForAQRC20TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a query to the Blockchain Network and returns whether an account is approved to make payments on behalf of another account for a particular QRC20 token.
         * @summary Retrieve whether an account is approved to make payments on behalf of another account for a particular QRC20 token.
         * @param {string} authorization 
         * @param {ReadContractOwnerRequestSchema} readContractOwnerRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC20SecondaryAccountOwner: async (authorization: string, readContractOwnerRequestSchema: ReadContractOwnerRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('readQRC20SecondaryAccountOwner', 'authorization', authorization)
            // verify required parameter 'readContractOwnerRequestSchema' is not null or undefined
            assertParamExists('readQRC20SecondaryAccountOwner', 'readContractOwnerRequestSchema', readContractOwnerRequestSchema)
            const localVarPath = `/v2/tokenise/tokens/qrc20/secondary-account-owner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readContractOwnerRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetrieveApprovedAccountInformationForAQRC20TokenApi - functional programming interface
 * @export
 */
export const RetrieveApprovedAccountInformationForAQRC20TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetrieveApprovedAccountInformationForAQRC20TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns whether an account is approved to make payments on behalf of another account for a particular QRC20 token.
         * @summary Retrieve whether an account is approved to make payments on behalf of another account for a particular QRC20 token.
         * @param {string} authorization 
         * @param {ReadContractOwnerRequestSchema} readContractOwnerRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readQRC20SecondaryAccountOwner(authorization: string, readContractOwnerRequestSchema: ReadContractOwnerRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReadQRC20Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readQRC20SecondaryAccountOwner(authorization, readContractOwnerRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetrieveApprovedAccountInformationForAQRC20TokenApi - factory interface
 * @export
 */
export const RetrieveApprovedAccountInformationForAQRC20TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetrieveApprovedAccountInformationForAQRC20TokenApiFp(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns whether an account is approved to make payments on behalf of another account for a particular QRC20 token.
         * @summary Retrieve whether an account is approved to make payments on behalf of another account for a particular QRC20 token.
         * @param {string} authorization 
         * @param {ReadContractOwnerRequestSchema} readContractOwnerRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC20SecondaryAccountOwner(authorization: string, readContractOwnerRequestSchema: ReadContractOwnerRequestSchema, options?: any): AxiosPromise<TokenReadQRC20Response> {
            return localVarFp.readQRC20SecondaryAccountOwner(authorization, readContractOwnerRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetrieveApprovedAccountInformationForAQRC20TokenApi - object-oriented interface
 * @export
 * @class RetrieveApprovedAccountInformationForAQRC20TokenApi
 * @extends {BaseAPI}
 */
export class RetrieveApprovedAccountInformationForAQRC20TokenApi extends BaseAPI {
    /**
     * Submits a query to the Blockchain Network and returns whether an account is approved to make payments on behalf of another account for a particular QRC20 token.
     * @summary Retrieve whether an account is approved to make payments on behalf of another account for a particular QRC20 token.
     * @param {string} authorization 
     * @param {ReadContractOwnerRequestSchema} readContractOwnerRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetrieveApprovedAccountInformationForAQRC20TokenApi
     */
    public readQRC20SecondaryAccountOwner(authorization: string, readContractOwnerRequestSchema: ReadContractOwnerRequestSchema, options?: AxiosRequestConfig) {
        return RetrieveApprovedAccountInformationForAQRC20TokenApiFp(this.configuration).readQRC20SecondaryAccountOwner(authorization, readContractOwnerRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetrieveApprovedAccountInformationOfAQRC721TokenApi - axios parameter creator
 * @export
 */
export const RetrieveApprovedAccountInformationOfAQRC721TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a query to the DLN and returns the address that is approved to collect a particular QRC721 token ID.
         * @summary Retrieve which account is approved to collect a QRC721 token
         * @param {string} authorization 
         * @param {ReadApprovedAccountRequestSchema} readApprovedAccountRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC721SmartContractApprovedAccount: async (authorization: string, readApprovedAccountRequestSchema: ReadApprovedAccountRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('readQRC721SmartContractApprovedAccount', 'authorization', authorization)
            // verify required parameter 'readApprovedAccountRequestSchema' is not null or undefined
            assertParamExists('readQRC721SmartContractApprovedAccount', 'readApprovedAccountRequestSchema', readApprovedAccountRequestSchema)
            const localVarPath = `/v2/tokenise/tokens/qrc721/approved-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readApprovedAccountRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetrieveApprovedAccountInformationOfAQRC721TokenApi - functional programming interface
 * @export
 */
export const RetrieveApprovedAccountInformationOfAQRC721TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetrieveApprovedAccountInformationOfAQRC721TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a query to the DLN and returns the address that is approved to collect a particular QRC721 token ID.
         * @summary Retrieve which account is approved to collect a QRC721 token
         * @param {string} authorization 
         * @param {ReadApprovedAccountRequestSchema} readApprovedAccountRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readQRC721SmartContractApprovedAccount(authorization: string, readApprovedAccountRequestSchema: ReadApprovedAccountRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReadQRC721Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readQRC721SmartContractApprovedAccount(authorization, readApprovedAccountRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetrieveApprovedAccountInformationOfAQRC721TokenApi - factory interface
 * @export
 */
export const RetrieveApprovedAccountInformationOfAQRC721TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetrieveApprovedAccountInformationOfAQRC721TokenApiFp(configuration)
    return {
        /**
         * Submits a query to the DLN and returns the address that is approved to collect a particular QRC721 token ID.
         * @summary Retrieve which account is approved to collect a QRC721 token
         * @param {string} authorization 
         * @param {ReadApprovedAccountRequestSchema} readApprovedAccountRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC721SmartContractApprovedAccount(authorization: string, readApprovedAccountRequestSchema: ReadApprovedAccountRequestSchema, options?: any): AxiosPromise<TokenReadQRC721Response> {
            return localVarFp.readQRC721SmartContractApprovedAccount(authorization, readApprovedAccountRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetrieveApprovedAccountInformationOfAQRC721TokenApi - object-oriented interface
 * @export
 * @class RetrieveApprovedAccountInformationOfAQRC721TokenApi
 * @extends {BaseAPI}
 */
export class RetrieveApprovedAccountInformationOfAQRC721TokenApi extends BaseAPI {
    /**
     * Submits a query to the DLN and returns the address that is approved to collect a particular QRC721 token ID.
     * @summary Retrieve which account is approved to collect a QRC721 token
     * @param {string} authorization 
     * @param {ReadApprovedAccountRequestSchema} readApprovedAccountRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetrieveApprovedAccountInformationOfAQRC721TokenApi
     */
    public readQRC721SmartContractApprovedAccount(authorization: string, readApprovedAccountRequestSchema: ReadApprovedAccountRequestSchema, options?: AxiosRequestConfig) {
        return RetrieveApprovedAccountInformationOfAQRC721TokenApiFp(this.configuration).readQRC721SmartContractApprovedAccount(authorization, readApprovedAccountRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetrieveContractOwnerInformationOfAQRCTokenApi - axios parameter creator
 * @export
 */
export const RetrieveContractOwnerInformationOfAQRCTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a query to the Blockchain Network and returns the address that currently has contract owner permissions for a particular QRC token.
         * @summary Retrieve which account has contract owner permissions for a QRC token
         * @param {string} authorization 
         * @param {string} flowType 
         * @param {PrepareRequest} prepareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRCSmartContractOwner: async (authorization: string, flowType: string, prepareRequest: PrepareRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('readQRCSmartContractOwner', 'authorization', authorization)
            // verify required parameter 'flowType' is not null or undefined
            assertParamExists('readQRCSmartContractOwner', 'flowType', flowType)
            // verify required parameter 'prepareRequest' is not null or undefined
            assertParamExists('readQRCSmartContractOwner', 'prepareRequest', prepareRequest)
            const localVarPath = `/v2/tokenise/tokens/{flowType}/contract-owner`
                .replace(`{${"flowType"}}`, encodeURIComponent(String(flowType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetrieveContractOwnerInformationOfAQRCTokenApi - functional programming interface
 * @export
 */
export const RetrieveContractOwnerInformationOfAQRCTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetrieveContractOwnerInformationOfAQRCTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns the address that currently has contract owner permissions for a particular QRC token.
         * @summary Retrieve which account has contract owner permissions for a QRC token
         * @param {string} authorization 
         * @param {string} flowType 
         * @param {PrepareRequest} prepareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readQRCSmartContractOwner(authorization: string, flowType: string, prepareRequest: PrepareRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReadQRC721Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readQRCSmartContractOwner(authorization, flowType, prepareRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetrieveContractOwnerInformationOfAQRCTokenApi - factory interface
 * @export
 */
export const RetrieveContractOwnerInformationOfAQRCTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetrieveContractOwnerInformationOfAQRCTokenApiFp(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns the address that currently has contract owner permissions for a particular QRC token.
         * @summary Retrieve which account has contract owner permissions for a QRC token
         * @param {string} authorization 
         * @param {string} flowType 
         * @param {PrepareRequest} prepareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRCSmartContractOwner(authorization: string, flowType: string, prepareRequest: PrepareRequest, options?: any): AxiosPromise<TokenReadQRC721Response> {
            return localVarFp.readQRCSmartContractOwner(authorization, flowType, prepareRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetrieveContractOwnerInformationOfAQRCTokenApi - object-oriented interface
 * @export
 * @class RetrieveContractOwnerInformationOfAQRCTokenApi
 * @extends {BaseAPI}
 */
export class RetrieveContractOwnerInformationOfAQRCTokenApi extends BaseAPI {
    /**
     * Submits a query to the Blockchain Network and returns the address that currently has contract owner permissions for a particular QRC token.
     * @summary Retrieve which account has contract owner permissions for a QRC token
     * @param {string} authorization 
     * @param {string} flowType 
     * @param {PrepareRequest} prepareRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetrieveContractOwnerInformationOfAQRCTokenApi
     */
    public readQRCSmartContractOwner(authorization: string, flowType: string, prepareRequest: PrepareRequest, options?: AxiosRequestConfig) {
        return RetrieveContractOwnerInformationOfAQRCTokenApiFp(this.configuration).readQRCSmartContractOwner(authorization, flowType, prepareRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetrieveOwnerInformationForAQRC721TokenApi - axios parameter creator
 * @export
 */
export const RetrieveOwnerInformationForAQRC721TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a query to the DLN and returns the address that currently has owns a particular QRC721 token.
         * @summary Retrieve which account currently owns a specific QRC721 token
         * @param {string} authorization 
         * @param {ReadTokenOwnerRequestSchema} readTokenOwnerRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC721SmartContractTokenOwner: async (authorization: string, readTokenOwnerRequestSchema: ReadTokenOwnerRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('readQRC721SmartContractTokenOwner', 'authorization', authorization)
            // verify required parameter 'readTokenOwnerRequestSchema' is not null or undefined
            assertParamExists('readQRC721SmartContractTokenOwner', 'readTokenOwnerRequestSchema', readTokenOwnerRequestSchema)
            const localVarPath = `/v2/tokenise/tokens/qrc721/token-owner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readTokenOwnerRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetrieveOwnerInformationForAQRC721TokenApi - functional programming interface
 * @export
 */
export const RetrieveOwnerInformationForAQRC721TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetrieveOwnerInformationForAQRC721TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a query to the DLN and returns the address that currently has owns a particular QRC721 token.
         * @summary Retrieve which account currently owns a specific QRC721 token
         * @param {string} authorization 
         * @param {ReadTokenOwnerRequestSchema} readTokenOwnerRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readQRC721SmartContractTokenOwner(authorization: string, readTokenOwnerRequestSchema: ReadTokenOwnerRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReadQRC721Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readQRC721SmartContractTokenOwner(authorization, readTokenOwnerRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetrieveOwnerInformationForAQRC721TokenApi - factory interface
 * @export
 */
export const RetrieveOwnerInformationForAQRC721TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetrieveOwnerInformationForAQRC721TokenApiFp(configuration)
    return {
        /**
         * Submits a query to the DLN and returns the address that currently has owns a particular QRC721 token.
         * @summary Retrieve which account currently owns a specific QRC721 token
         * @param {string} authorization 
         * @param {ReadTokenOwnerRequestSchema} readTokenOwnerRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC721SmartContractTokenOwner(authorization: string, readTokenOwnerRequestSchema: ReadTokenOwnerRequestSchema, options?: any): AxiosPromise<TokenReadQRC721Response> {
            return localVarFp.readQRC721SmartContractTokenOwner(authorization, readTokenOwnerRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetrieveOwnerInformationForAQRC721TokenApi - object-oriented interface
 * @export
 * @class RetrieveOwnerInformationForAQRC721TokenApi
 * @extends {BaseAPI}
 */
export class RetrieveOwnerInformationForAQRC721TokenApi extends BaseAPI {
    /**
     * Submits a query to the DLN and returns the address that currently has owns a particular QRC721 token.
     * @summary Retrieve which account currently owns a specific QRC721 token
     * @param {string} authorization 
     * @param {ReadTokenOwnerRequestSchema} readTokenOwnerRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetrieveOwnerInformationForAQRC721TokenApi
     */
    public readQRC721SmartContractTokenOwner(authorization: string, readTokenOwnerRequestSchema: ReadTokenOwnerRequestSchema, options?: AxiosRequestConfig) {
        return RetrieveOwnerInformationForAQRC721TokenApiFp(this.configuration).readQRC721SmartContractTokenOwner(authorization, readTokenOwnerRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetrieveSupplyInformationForAQRCTokenApi - axios parameter creator
 * @export
 */
export const RetrieveSupplyInformationForAQRCTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a query to the Blockchain Network and returns the number of QRC tokens that are currently in circulation after tokens have been minted and burned.
         * @summary Retrieve how many QRC tokens are currently in supply
         * @param {string} authorization 
         * @param {string} flowType 
         * @param {PrepareRequest} prepareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC721SmartContractCurrentSupply: async (authorization: string, flowType: string, prepareRequest: PrepareRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('readQRC721SmartContractCurrentSupply', 'authorization', authorization)
            // verify required parameter 'flowType' is not null or undefined
            assertParamExists('readQRC721SmartContractCurrentSupply', 'flowType', flowType)
            // verify required parameter 'prepareRequest' is not null or undefined
            assertParamExists('readQRC721SmartContractCurrentSupply', 'prepareRequest', prepareRequest)
            const localVarPath = `/v2/tokenise/tokens/{flowType}/current-supply`
                .replace(`{${"flowType"}}`, encodeURIComponent(String(flowType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetrieveSupplyInformationForAQRCTokenApi - functional programming interface
 * @export
 */
export const RetrieveSupplyInformationForAQRCTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetrieveSupplyInformationForAQRCTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns the number of QRC tokens that are currently in circulation after tokens have been minted and burned.
         * @summary Retrieve how many QRC tokens are currently in supply
         * @param {string} authorization 
         * @param {string} flowType 
         * @param {PrepareRequest} prepareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readQRC721SmartContractCurrentSupply(authorization: string, flowType: string, prepareRequest: PrepareRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReadQRC721Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readQRC721SmartContractCurrentSupply(authorization, flowType, prepareRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetrieveSupplyInformationForAQRCTokenApi - factory interface
 * @export
 */
export const RetrieveSupplyInformationForAQRCTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetrieveSupplyInformationForAQRCTokenApiFp(configuration)
    return {
        /**
         * Submits a query to the Blockchain Network and returns the number of QRC tokens that are currently in circulation after tokens have been minted and burned.
         * @summary Retrieve how many QRC tokens are currently in supply
         * @param {string} authorization 
         * @param {string} flowType 
         * @param {PrepareRequest} prepareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC721SmartContractCurrentSupply(authorization: string, flowType: string, prepareRequest: PrepareRequest, options?: any): AxiosPromise<TokenReadQRC721Response> {
            return localVarFp.readQRC721SmartContractCurrentSupply(authorization, flowType, prepareRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetrieveSupplyInformationForAQRCTokenApi - object-oriented interface
 * @export
 * @class RetrieveSupplyInformationForAQRCTokenApi
 * @extends {BaseAPI}
 */
export class RetrieveSupplyInformationForAQRCTokenApi extends BaseAPI {
    /**
     * Submits a query to the Blockchain Network and returns the number of QRC tokens that are currently in circulation after tokens have been minted and burned.
     * @summary Retrieve how many QRC tokens are currently in supply
     * @param {string} authorization 
     * @param {string} flowType 
     * @param {PrepareRequest} prepareRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetrieveSupplyInformationForAQRCTokenApi
     */
    public readQRC721SmartContractCurrentSupply(authorization: string, flowType: string, prepareRequest: PrepareRequest, options?: AxiosRequestConfig) {
        return RetrieveSupplyInformationForAQRCTokenApiFp(this.configuration).readQRC721SmartContractCurrentSupply(authorization, flowType, prepareRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetrieveTheCountOfQRC721TokensApi - axios parameter creator
 * @export
 */
export const RetrieveTheCountOfQRC721TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a query to the DLN and returns the number of QRC721 tokens held by the given account ID
         * @summary Retrieve the count of a QRC721 token for a particular account
         * @param {string} authorization 
         * @param {ReadBalanceRequestSchema} readBalanceRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenCount: async (authorization: string, readBalanceRequestSchema: ReadBalanceRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getTokenCount', 'authorization', authorization)
            // verify required parameter 'readBalanceRequestSchema' is not null or undefined
            assertParamExists('getTokenCount', 'readBalanceRequestSchema', readBalanceRequestSchema)
            const localVarPath = `/v2/tokenise/tokens/qrc721/token-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readBalanceRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetrieveTheCountOfQRC721TokensApi - functional programming interface
 * @export
 */
export const RetrieveTheCountOfQRC721TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetrieveTheCountOfQRC721TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a query to the DLN and returns the number of QRC721 tokens held by the given account ID
         * @summary Retrieve the count of a QRC721 token for a particular account
         * @param {string} authorization 
         * @param {ReadBalanceRequestSchema} readBalanceRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenCount(authorization: string, readBalanceRequestSchema: ReadBalanceRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReadQRC721Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenCount(authorization, readBalanceRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetrieveTheCountOfQRC721TokensApi - factory interface
 * @export
 */
export const RetrieveTheCountOfQRC721TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetrieveTheCountOfQRC721TokensApiFp(configuration)
    return {
        /**
         * Submits a query to the DLN and returns the number of QRC721 tokens held by the given account ID
         * @summary Retrieve the count of a QRC721 token for a particular account
         * @param {string} authorization 
         * @param {ReadBalanceRequestSchema} readBalanceRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenCount(authorization: string, readBalanceRequestSchema: ReadBalanceRequestSchema, options?: any): AxiosPromise<TokenReadQRC721Response> {
            return localVarFp.getTokenCount(authorization, readBalanceRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetrieveTheCountOfQRC721TokensApi - object-oriented interface
 * @export
 * @class RetrieveTheCountOfQRC721TokensApi
 * @extends {BaseAPI}
 */
export class RetrieveTheCountOfQRC721TokensApi extends BaseAPI {
    /**
     * Submits a query to the DLN and returns the number of QRC721 tokens held by the given account ID
     * @summary Retrieve the count of a QRC721 token for a particular account
     * @param {string} authorization 
     * @param {ReadBalanceRequestSchema} readBalanceRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetrieveTheCountOfQRC721TokensApi
     */
    public getTokenCount(authorization: string, readBalanceRequestSchema: ReadBalanceRequestSchema, options?: AxiosRequestConfig) {
        return RetrieveTheCountOfQRC721TokensApiFp(this.configuration).getTokenCount(authorization, readBalanceRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RetrieveURIInformationForAQRC721TokenApi - axios parameter creator
 * @export
 */
export const RetrieveURIInformationForAQRC721TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Submits a query to the DLN and returns the URI that is assigned to a particular QRC721 token
         * @summary Retrieve the URI for a specific QRC721 token
         * @param {string} authorization 
         * @param {ReadApprovedAccountRequestSchema} readApprovedAccountRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC721SmartContractUri: async (authorization: string, readApprovedAccountRequestSchema: ReadApprovedAccountRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('readQRC721SmartContractUri', 'authorization', authorization)
            // verify required parameter 'readApprovedAccountRequestSchema' is not null or undefined
            assertParamExists('readQRC721SmartContractUri', 'readApprovedAccountRequestSchema', readApprovedAccountRequestSchema)
            const localVarPath = `/v2/tokenise/tokens/qrc721/token-uri`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(readApprovedAccountRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RetrieveURIInformationForAQRC721TokenApi - functional programming interface
 * @export
 */
export const RetrieveURIInformationForAQRC721TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RetrieveURIInformationForAQRC721TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Submits a query to the DLN and returns the URI that is assigned to a particular QRC721 token
         * @summary Retrieve the URI for a specific QRC721 token
         * @param {string} authorization 
         * @param {ReadApprovedAccountRequestSchema} readApprovedAccountRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readQRC721SmartContractUri(authorization: string, readApprovedAccountRequestSchema: ReadApprovedAccountRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenReadQRC721Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readQRC721SmartContractUri(authorization, readApprovedAccountRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RetrieveURIInformationForAQRC721TokenApi - factory interface
 * @export
 */
export const RetrieveURIInformationForAQRC721TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RetrieveURIInformationForAQRC721TokenApiFp(configuration)
    return {
        /**
         * Submits a query to the DLN and returns the URI that is assigned to a particular QRC721 token
         * @summary Retrieve the URI for a specific QRC721 token
         * @param {string} authorization 
         * @param {ReadApprovedAccountRequestSchema} readApprovedAccountRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readQRC721SmartContractUri(authorization: string, readApprovedAccountRequestSchema: ReadApprovedAccountRequestSchema, options?: any): AxiosPromise<TokenReadQRC721Response> {
            return localVarFp.readQRC721SmartContractUri(authorization, readApprovedAccountRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RetrieveURIInformationForAQRC721TokenApi - object-oriented interface
 * @export
 * @class RetrieveURIInformationForAQRC721TokenApi
 * @extends {BaseAPI}
 */
export class RetrieveURIInformationForAQRC721TokenApi extends BaseAPI {
    /**
     * Submits a query to the DLN and returns the URI that is assigned to a particular QRC721 token
     * @summary Retrieve the URI for a specific QRC721 token
     * @param {string} authorization 
     * @param {ReadApprovedAccountRequestSchema} readApprovedAccountRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RetrieveURIInformationForAQRC721TokenApi
     */
    public readQRC721SmartContractUri(authorization: string, readApprovedAccountRequestSchema: ReadApprovedAccountRequestSchema, options?: AxiosRequestConfig) {
        return RetrieveURIInformationForAQRC721TokenApiFp(this.configuration).readQRC721SmartContractUri(authorization, readApprovedAccountRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SmartContractSearchApi - axios parameter creator
 * @export
 */
export const SmartContractSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the smart contract query search on the requested DLT.
         * @summary Prepare and automatically execute a search for a smart contract query on a DLT.
         * @param {string} authorization 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchSmartContractQueryRequest: async (authorization: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchSmartContractQueryRequest', 'authorization', authorization)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchSmartContractQueryRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/smartcontract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID and reads the smart contract on Ethereum based on the parameters specified in the prepare request.
         * @summary Execute a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequest: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequest', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequest', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/smartcontract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a request ID for executing a smart contract read on Ethereum.
         * @summary Prepare a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {PrepareSearchSmartContractRequestSchema} prepareSearchSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSmartContractQueryRequest: async (authorization: string, prepareSearchSmartContractRequestSchema: PrepareSearchSmartContractRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSmartContractQueryRequest', 'authorization', authorization)
            // verify required parameter 'prepareSearchSmartContractRequestSchema' is not null or undefined
            assertParamExists('prepareSmartContractQueryRequest', 'prepareSearchSmartContractRequestSchema', prepareSearchSmartContractRequestSchema)
            const localVarPath = `/v2/preparation/search/smartcontract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSmartContractRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SmartContractSearchApi - functional programming interface
 * @export
 */
export const SmartContractSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartContractSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the smart contract query search on the requested DLT.
         * @summary Prepare and automatically execute a search for a smart contract query on a DLT.
         * @param {string} authorization 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchSmartContractQueryRequest(authorization: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecuteSearchAddressBalanceResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchSmartContractQueryRequest(authorization, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID and reads the smart contract on Ethereum based on the parameters specified in the prepare request.
         * @summary Execute a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequest(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSmartContractReadResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequest(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a request ID for executing a smart contract read on Ethereum.
         * @summary Prepare a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {PrepareSearchSmartContractRequestSchema} prepareSearchSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSmartContractQueryRequest(authorization: string, prepareSearchSmartContractRequestSchema: PrepareSearchSmartContractRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSmartContractQueryRequest(authorization, prepareSearchSmartContractRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SmartContractSearchApi - factory interface
 * @export
 */
export const SmartContractSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SmartContractSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the smart contract query search on the requested DLT.
         * @summary Prepare and automatically execute a search for a smart contract query on a DLT.
         * @param {string} authorization 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchSmartContractQueryRequest(authorization: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecuteSearchAddressBalanceResponseSchema> {
            return localVarFp.autoExecuteSearchSmartContractQueryRequest(authorization, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID and reads the smart contract on Ethereum based on the parameters specified in the prepare request.
         * @summary Execute a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequest(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSmartContractReadResponseSchema> {
            return localVarFp.executePreparedSearchRequest(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a request ID for executing a smart contract read on Ethereum.
         * @summary Prepare a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {PrepareSearchSmartContractRequestSchema} prepareSearchSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSmartContractQueryRequest(authorization: string, prepareSearchSmartContractRequestSchema: PrepareSearchSmartContractRequestSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareSmartContractQueryRequest(authorization, prepareSearchSmartContractRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SmartContractSearchApi - object-oriented interface
 * @export
 * @class SmartContractSearchApi
 * @extends {BaseAPI}
 */
export class SmartContractSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the smart contract query search on the requested DLT.
     * @summary Prepare and automatically execute a search for a smart contract query on a DLT.
     * @param {string} authorization 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractSearchApi
     */
    public autoExecuteSearchSmartContractQueryRequest(authorization: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return SmartContractSearchApiFp(this.configuration).autoExecuteSearchSmartContractQueryRequest(authorization, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID and reads the smart contract on Ethereum based on the parameters specified in the prepare request.
     * @summary Execute a read of a smart contract on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractSearchApi
     */
    public executePreparedSearchRequest(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return SmartContractSearchApiFp(this.configuration).executePreparedSearchRequest(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a request ID for executing a smart contract read on Ethereum.
     * @summary Prepare a read of a smart contract on a DLT
     * @param {string} authorization 
     * @param {PrepareSearchSmartContractRequestSchema} prepareSearchSmartContractRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractSearchApi
     */
    public prepareSmartContractQueryRequest(authorization: string, prepareSearchSmartContractRequestSchema: PrepareSearchSmartContractRequestSchema, options?: AxiosRequestConfig) {
        return SmartContractSearchApiFp(this.configuration).prepareSmartContractQueryRequest(authorization, prepareSearchSmartContractRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscribeToQRC20AccountCreditPaymentsApi - axios parameter creator
 * @export
 */
export const SubscribeToQRC20AccountCreditPaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time there is a credit on a QRC20 token.
         * @summary Receive updates each time there is a credit payment on your account
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeCreditEvent: async (authorization: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('subscribeCreditEvent', 'authorization', authorization)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('subscribeCreditEvent', 'body', body)
            const localVarPath = `/v2/tokenise/tokens/subscription/qrc20/credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscribeToQRC20AccountCreditPaymentsApi - functional programming interface
 * @export
 */
export const SubscribeToQRC20AccountCreditPaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscribeToQRC20AccountCreditPaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time there is a credit on a QRC20 token.
         * @summary Receive updates each time there is a credit payment on your account
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeCreditEvent(authorization: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeCreditEvent(authorization, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscribeToQRC20AccountCreditPaymentsApi - factory interface
 * @export
 */
export const SubscribeToQRC20AccountCreditPaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscribeToQRC20AccountCreditPaymentsApiFp(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time there is a credit on a QRC20 token.
         * @summary Receive updates each time there is a credit payment on your account
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeCreditEvent(authorization: string, body: object, options?: any): AxiosPromise<EventSubscriptionResponse> {
            return localVarFp.subscribeCreditEvent(authorization, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscribeToQRC20AccountCreditPaymentsApi - object-oriented interface
 * @export
 * @class SubscribeToQRC20AccountCreditPaymentsApi
 * @extends {BaseAPI}
 */
export class SubscribeToQRC20AccountCreditPaymentsApi extends BaseAPI {
    /**
     * Set up a subscription to receive updates to a callback URL each time there is a credit on a QRC20 token.
     * @summary Receive updates each time there is a credit payment on your account
     * @param {string} authorization 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeToQRC20AccountCreditPaymentsApi
     */
    public subscribeCreditEvent(authorization: string, body: object, options?: AxiosRequestConfig) {
        return SubscribeToQRC20AccountCreditPaymentsApiFp(this.configuration).subscribeCreditEvent(authorization, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscribeToQRC20AccountDebitPaymentsApi - axios parameter creator
 * @export
 */
export const SubscribeToQRC20AccountDebitPaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time there is a debit on a QRC20 token or a QRC20 debit is approved. Use the type \"Create Debit\" to get an update when there is a debit payment on your account or \"Approve Debit\" to receive an update each time a token has been approved for debit.
         * @summary Receive updates each time there is a debit transaction on QRC20 token or a QRC20 debit is approved
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeQRC20DebitEvent: async (authorization: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('subscribeQRC20DebitEvent', 'authorization', authorization)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('subscribeQRC20DebitEvent', 'body', body)
            const localVarPath = `/v2/tokenise/tokens/subscription/qrc20/debit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscribeToQRC20AccountDebitPaymentsApi - functional programming interface
 * @export
 */
export const SubscribeToQRC20AccountDebitPaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscribeToQRC20AccountDebitPaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time there is a debit on a QRC20 token or a QRC20 debit is approved. Use the type \"Create Debit\" to get an update when there is a debit payment on your account or \"Approve Debit\" to receive an update each time a token has been approved for debit.
         * @summary Receive updates each time there is a debit transaction on QRC20 token or a QRC20 debit is approved
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeQRC20DebitEvent(authorization: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeQRC20DebitEvent(authorization, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscribeToQRC20AccountDebitPaymentsApi - factory interface
 * @export
 */
export const SubscribeToQRC20AccountDebitPaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscribeToQRC20AccountDebitPaymentsApiFp(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time there is a debit on a QRC20 token or a QRC20 debit is approved. Use the type \"Create Debit\" to get an update when there is a debit payment on your account or \"Approve Debit\" to receive an update each time a token has been approved for debit.
         * @summary Receive updates each time there is a debit transaction on QRC20 token or a QRC20 debit is approved
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeQRC20DebitEvent(authorization: string, body: object, options?: any): AxiosPromise<EventSubscriptionResponse> {
            return localVarFp.subscribeQRC20DebitEvent(authorization, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscribeToQRC20AccountDebitPaymentsApi - object-oriented interface
 * @export
 * @class SubscribeToQRC20AccountDebitPaymentsApi
 * @extends {BaseAPI}
 */
export class SubscribeToQRC20AccountDebitPaymentsApi extends BaseAPI {
    /**
     * Set up a subscription to receive updates to a callback URL each time there is a debit on a QRC20 token or a QRC20 debit is approved. Use the type \"Create Debit\" to get an update when there is a debit payment on your account or \"Approve Debit\" to receive an update each time a token has been approved for debit.
     * @summary Receive updates each time there is a debit transaction on QRC20 token or a QRC20 debit is approved
     * @param {string} authorization 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeToQRC20AccountDebitPaymentsApi
     */
    public subscribeQRC20DebitEvent(authorization: string, body: object, options?: AxiosRequestConfig) {
        return SubscribeToQRC20AccountDebitPaymentsApiFp(this.configuration).subscribeQRC20DebitEvent(authorization, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscribeToQRC20SharedAccountUpdatesApi - axios parameter creator
 * @export
 */
export const SubscribeToQRC20SharedAccountUpdatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a secondary account owner is added or removed using the \"Add Account\" & \"Remove Account\" Request Types. Also sends update when a shared account creates a QRC20 credit payment using the \"Create Credit\" Request Type.
         * @summary Receive updates for a shared account
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeSecondaryOwnerEvent: async (authorization: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('subscribeSecondaryOwnerEvent', 'authorization', authorization)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('subscribeSecondaryOwnerEvent', 'body', body)
            const localVarPath = `/v2/tokenise/tokens/subscription/qrc20/secondaryaccountowner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscribeToQRC20SharedAccountUpdatesApi - functional programming interface
 * @export
 */
export const SubscribeToQRC20SharedAccountUpdatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscribeToQRC20SharedAccountUpdatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a secondary account owner is added or removed using the \"Add Account\" & \"Remove Account\" Request Types. Also sends update when a shared account creates a QRC20 credit payment using the \"Create Credit\" Request Type.
         * @summary Receive updates for a shared account
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeSecondaryOwnerEvent(authorization: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeSecondaryOwnerEvent(authorization, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscribeToQRC20SharedAccountUpdatesApi - factory interface
 * @export
 */
export const SubscribeToQRC20SharedAccountUpdatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscribeToQRC20SharedAccountUpdatesApiFp(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a secondary account owner is added or removed using the \"Add Account\" & \"Remove Account\" Request Types. Also sends update when a shared account creates a QRC20 credit payment using the \"Create Credit\" Request Type.
         * @summary Receive updates for a shared account
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeSecondaryOwnerEvent(authorization: string, body: object, options?: any): AxiosPromise<EventSubscriptionResponse> {
            return localVarFp.subscribeSecondaryOwnerEvent(authorization, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscribeToQRC20SharedAccountUpdatesApi - object-oriented interface
 * @export
 * @class SubscribeToQRC20SharedAccountUpdatesApi
 * @extends {BaseAPI}
 */
export class SubscribeToQRC20SharedAccountUpdatesApi extends BaseAPI {
    /**
     * Set up a subscription to receive updates to a callback URL each time a secondary account owner is added or removed using the \"Add Account\" & \"Remove Account\" Request Types. Also sends update when a shared account creates a QRC20 credit payment using the \"Create Credit\" Request Type.
     * @summary Receive updates for a shared account
     * @param {string} authorization 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeToQRC20SharedAccountUpdatesApi
     */
    public subscribeSecondaryOwnerEvent(authorization: string, body: object, options?: AxiosRequestConfig) {
        return SubscribeToQRC20SharedAccountUpdatesApiFp(this.configuration).subscribeSecondaryOwnerEvent(authorization, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscribeToQRC20TokenSupplyChangesApi - axios parameter creator
 * @export
 */
export const SubscribeToQRC20TokenSupplyChangesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a change in QRC721 or QRC20 token supply occurs. Use the type \"Mint Tokens\" to receive an update each time a new token is created, or use the type \"Burn Tokens\" to receive an update each time a token is destroyed.
         * @summary Receive updates each time a supply changes for a QRC721 or QRC20 token
         * @param {string} authorization 
         * @param {string} flowtype 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeSupplyEvent: async (authorization: string, flowtype: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('subscribeSupplyEvent', 'authorization', authorization)
            // verify required parameter 'flowtype' is not null or undefined
            assertParamExists('subscribeSupplyEvent', 'flowtype', flowtype)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('subscribeSupplyEvent', 'body', body)
            const localVarPath = `/v2/tokenise/tokens/subscription/{flowtype}/supply`
                .replace(`{${"flowtype"}}`, encodeURIComponent(String(flowtype)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscribeToQRC20TokenSupplyChangesApi - functional programming interface
 * @export
 */
export const SubscribeToQRC20TokenSupplyChangesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscribeToQRC20TokenSupplyChangesApiAxiosParamCreator(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a change in QRC721 or QRC20 token supply occurs. Use the type \"Mint Tokens\" to receive an update each time a new token is created, or use the type \"Burn Tokens\" to receive an update each time a token is destroyed.
         * @summary Receive updates each time a supply changes for a QRC721 or QRC20 token
         * @param {string} authorization 
         * @param {string} flowtype 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeSupplyEvent(authorization: string, flowtype: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeSupplyEvent(authorization, flowtype, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscribeToQRC20TokenSupplyChangesApi - factory interface
 * @export
 */
export const SubscribeToQRC20TokenSupplyChangesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscribeToQRC20TokenSupplyChangesApiFp(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a change in QRC721 or QRC20 token supply occurs. Use the type \"Mint Tokens\" to receive an update each time a new token is created, or use the type \"Burn Tokens\" to receive an update each time a token is destroyed.
         * @summary Receive updates each time a supply changes for a QRC721 or QRC20 token
         * @param {string} authorization 
         * @param {string} flowtype 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeSupplyEvent(authorization: string, flowtype: string, body: object, options?: any): AxiosPromise<EventSubscriptionResponse> {
            return localVarFp.subscribeSupplyEvent(authorization, flowtype, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscribeToQRC20TokenSupplyChangesApi - object-oriented interface
 * @export
 * @class SubscribeToQRC20TokenSupplyChangesApi
 * @extends {BaseAPI}
 */
export class SubscribeToQRC20TokenSupplyChangesApi extends BaseAPI {
    /**
     * Set up a subscription to receive updates to a callback URL each time a change in QRC721 or QRC20 token supply occurs. Use the type \"Mint Tokens\" to receive an update each time a new token is created, or use the type \"Burn Tokens\" to receive an update each time a token is destroyed.
     * @summary Receive updates each time a supply changes for a QRC721 or QRC20 token
     * @param {string} authorization 
     * @param {string} flowtype 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeToQRC20TokenSupplyChangesApi
     */
    public subscribeSupplyEvent(authorization: string, flowtype: string, body: object, options?: AxiosRequestConfig) {
        return SubscribeToQRC20TokenSupplyChangesApiFp(this.configuration).subscribeSupplyEvent(authorization, flowtype, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscribeToQRC721AssetCollectionUpdatesApi - axios parameter creator
 * @export
 */
export const SubscribeToQRC721AssetCollectionUpdatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a QRC721 token is either approved for collected or collected. Use the type \"Approve Asset Collect\" to receive an update each time a token has been approved for collection, or use the type \"Collect Asset\" to receive an update each time a token has been collected.
         * @summary Receive updates each time a QRC721 token is approved for collection or collected
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeCollectEvent: async (authorization: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('subscribeCollectEvent', 'authorization', authorization)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('subscribeCollectEvent', 'body', body)
            const localVarPath = `/v2/tokenise/tokens/subscription/qrc721/collect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscribeToQRC721AssetCollectionUpdatesApi - functional programming interface
 * @export
 */
export const SubscribeToQRC721AssetCollectionUpdatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscribeToQRC721AssetCollectionUpdatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a QRC721 token is either approved for collected or collected. Use the type \"Approve Asset Collect\" to receive an update each time a token has been approved for collection, or use the type \"Collect Asset\" to receive an update each time a token has been collected.
         * @summary Receive updates each time a QRC721 token is approved for collection or collected
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeCollectEvent(authorization: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeCollectEvent(authorization, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscribeToQRC721AssetCollectionUpdatesApi - factory interface
 * @export
 */
export const SubscribeToQRC721AssetCollectionUpdatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscribeToQRC721AssetCollectionUpdatesApiFp(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a QRC721 token is either approved for collected or collected. Use the type \"Approve Asset Collect\" to receive an update each time a token has been approved for collection, or use the type \"Collect Asset\" to receive an update each time a token has been collected.
         * @summary Receive updates each time a QRC721 token is approved for collection or collected
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeCollectEvent(authorization: string, body: object, options?: any): AxiosPromise<EventSubscriptionResponse> {
            return localVarFp.subscribeCollectEvent(authorization, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscribeToQRC721AssetCollectionUpdatesApi - object-oriented interface
 * @export
 * @class SubscribeToQRC721AssetCollectionUpdatesApi
 * @extends {BaseAPI}
 */
export class SubscribeToQRC721AssetCollectionUpdatesApi extends BaseAPI {
    /**
     * Set up a subscription to receive updates to a callback URL each time a QRC721 token is either approved for collected or collected. Use the type \"Approve Asset Collect\" to receive an update each time a token has been approved for collection, or use the type \"Collect Asset\" to receive an update each time a token has been collected.
     * @summary Receive updates each time a QRC721 token is approved for collection or collected
     * @param {string} authorization 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeToQRC721AssetCollectionUpdatesApi
     */
    public subscribeCollectEvent(authorization: string, body: object, options?: AxiosRequestConfig) {
        return SubscribeToQRC721AssetCollectionUpdatesApiFp(this.configuration).subscribeCollectEvent(authorization, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscribeToQRC721AssetTransfersApi - axios parameter creator
 * @export
 */
export const SubscribeToQRC721AssetTransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a QRC721 token is transferred to a different owner. Use the type \"Create Transfer\" to receive an update each time a token is transferred to a different owner.
         * @summary Receive updates each time a QRC721 token is transferred
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeTransferEvent: async (authorization: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('subscribeTransferEvent', 'authorization', authorization)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('subscribeTransferEvent', 'body', body)
            const localVarPath = `/v2/tokenise/tokens/subscription/qrc721/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscribeToQRC721AssetTransfersApi - functional programming interface
 * @export
 */
export const SubscribeToQRC721AssetTransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscribeToQRC721AssetTransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a QRC721 token is transferred to a different owner. Use the type \"Create Transfer\" to receive an update each time a token is transferred to a different owner.
         * @summary Receive updates each time a QRC721 token is transferred
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeTransferEvent(authorization: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeTransferEvent(authorization, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscribeToQRC721AssetTransfersApi - factory interface
 * @export
 */
export const SubscribeToQRC721AssetTransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscribeToQRC721AssetTransfersApiFp(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a QRC721 token is transferred to a different owner. Use the type \"Create Transfer\" to receive an update each time a token is transferred to a different owner.
         * @summary Receive updates each time a QRC721 token is transferred
         * @param {string} authorization 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeTransferEvent(authorization: string, body: object, options?: any): AxiosPromise<EventSubscriptionResponse> {
            return localVarFp.subscribeTransferEvent(authorization, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscribeToQRC721AssetTransfersApi - object-oriented interface
 * @export
 * @class SubscribeToQRC721AssetTransfersApi
 * @extends {BaseAPI}
 */
export class SubscribeToQRC721AssetTransfersApi extends BaseAPI {
    /**
     * Set up a subscription to receive updates to a callback URL each time a QRC721 token is transferred to a different owner. Use the type \"Create Transfer\" to receive an update each time a token is transferred to a different owner.
     * @summary Receive updates each time a QRC721 token is transferred
     * @param {string} authorization 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeToQRC721AssetTransfersApi
     */
    public subscribeTransferEvent(authorization: string, body: object, options?: AxiosRequestConfig) {
        return SubscribeToQRC721AssetTransfersApiFp(this.configuration).subscribeTransferEvent(authorization, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscribeToQRC721SupplyChangeUpdatesApi - axios parameter creator
 * @export
 */
export const SubscribeToQRC721SupplyChangeUpdatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a change in QRC721 or QRC20 token supply occurs. Use the type \"Mint Tokens\" to receive an update each time a new token is created, or use the type \"Burn Tokens\" to receive an update each time a token is destroyed.
         * @summary Receive updates each time a supply changes for a QRC721 or QRC20 token
         * @param {string} authorization 
         * @param {string} flowtype 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeSupplyEvent: async (authorization: string, flowtype: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('subscribeSupplyEvent', 'authorization', authorization)
            // verify required parameter 'flowtype' is not null or undefined
            assertParamExists('subscribeSupplyEvent', 'flowtype', flowtype)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('subscribeSupplyEvent', 'body', body)
            const localVarPath = `/v2/tokenise/tokens/subscription/{flowtype}/supply`
                .replace(`{${"flowtype"}}`, encodeURIComponent(String(flowtype)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscribeToQRC721SupplyChangeUpdatesApi - functional programming interface
 * @export
 */
export const SubscribeToQRC721SupplyChangeUpdatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscribeToQRC721SupplyChangeUpdatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a change in QRC721 or QRC20 token supply occurs. Use the type \"Mint Tokens\" to receive an update each time a new token is created, or use the type \"Burn Tokens\" to receive an update each time a token is destroyed.
         * @summary Receive updates each time a supply changes for a QRC721 or QRC20 token
         * @param {string} authorization 
         * @param {string} flowtype 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribeSupplyEvent(authorization: string, flowtype: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribeSupplyEvent(authorization, flowtype, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscribeToQRC721SupplyChangeUpdatesApi - factory interface
 * @export
 */
export const SubscribeToQRC721SupplyChangeUpdatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscribeToQRC721SupplyChangeUpdatesApiFp(configuration)
    return {
        /**
         * Set up a subscription to receive updates to a callback URL each time a change in QRC721 or QRC20 token supply occurs. Use the type \"Mint Tokens\" to receive an update each time a new token is created, or use the type \"Burn Tokens\" to receive an update each time a token is destroyed.
         * @summary Receive updates each time a supply changes for a QRC721 or QRC20 token
         * @param {string} authorization 
         * @param {string} flowtype 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribeSupplyEvent(authorization: string, flowtype: string, body: object, options?: any): AxiosPromise<EventSubscriptionResponse> {
            return localVarFp.subscribeSupplyEvent(authorization, flowtype, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscribeToQRC721SupplyChangeUpdatesApi - object-oriented interface
 * @export
 * @class SubscribeToQRC721SupplyChangeUpdatesApi
 * @extends {BaseAPI}
 */
export class SubscribeToQRC721SupplyChangeUpdatesApi extends BaseAPI {
    /**
     * Set up a subscription to receive updates to a callback URL each time a change in QRC721 or QRC20 token supply occurs. Use the type \"Mint Tokens\" to receive an update each time a new token is created, or use the type \"Burn Tokens\" to receive an update each time a token is destroyed.
     * @summary Receive updates each time a supply changes for a QRC721 or QRC20 token
     * @param {string} authorization 
     * @param {string} flowtype 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscribeToQRC721SupplyChangeUpdatesApi
     */
    public subscribeSupplyEvent(authorization: string, flowtype: string, body: object, options?: AxiosRequestConfig) {
        return SubscribeToQRC721SupplyChangeUpdatesApiFp(this.configuration).subscribeSupplyEvent(authorization, flowtype, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SupportedFungibleTokensApi - axios parameter creator
 * @export
 */
export const SupportedFungibleTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of fungible tokens supported by Overledger and which APIs and functions you can use for each. You can retrieve all fungible token types for all locations without providing parameters. If you want to see what tokens are supported for a specific contract type you can pass in either ERC20 or QRC20 as a contract type parameter. You can then filter further by including the resource using the technology and network parameters. You can also look for a specific token by passing in the unit as a parameter.
         * @summary Retrieve a list of ERC20 and QRC20 tokens
         * @param {Location} [location] 
         * @param {string} [contractType] 
         * @param {string} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (location?: Location, contractType?: string, unit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/tokens/fungible`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportedFungibleTokensApi - functional programming interface
 * @export
 */
export const SupportedFungibleTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupportedFungibleTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of fungible tokens supported by Overledger and which APIs and functions you can use for each. You can retrieve all fungible token types for all locations without providing parameters. If you want to see what tokens are supported for a specific contract type you can pass in either ERC20 or QRC20 as a contract type parameter. You can then filter further by including the resource using the technology and network parameters. You can also look for a specific token by passing in the unit as a parameter.
         * @summary Retrieve a list of ERC20 and QRC20 tokens
         * @param {Location} [location] 
         * @param {string} [contractType] 
         * @param {string} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(location?: Location, contractType?: string, unit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FungibleTokenResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(location, contractType, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SupportedFungibleTokensApi - factory interface
 * @export
 */
export const SupportedFungibleTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupportedFungibleTokensApiFp(configuration)
    return {
        /**
         * Retrieves a list of fungible tokens supported by Overledger and which APIs and functions you can use for each. You can retrieve all fungible token types for all locations without providing parameters. If you want to see what tokens are supported for a specific contract type you can pass in either ERC20 or QRC20 as a contract type parameter. You can then filter further by including the resource using the technology and network parameters. You can also look for a specific token by passing in the unit as a parameter.
         * @summary Retrieve a list of ERC20 and QRC20 tokens
         * @param {Location} [location] 
         * @param {string} [contractType] 
         * @param {string} [unit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(location?: Location, contractType?: string, unit?: string, options?: any): AxiosPromise<FungibleTokenResponseDTO> {
            return localVarFp.getTokens(location, contractType, unit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupportedFungibleTokensApi - object-oriented interface
 * @export
 * @class SupportedFungibleTokensApi
 * @extends {BaseAPI}
 */
export class SupportedFungibleTokensApi extends BaseAPI {
    /**
     * Retrieves a list of fungible tokens supported by Overledger and which APIs and functions you can use for each. You can retrieve all fungible token types for all locations without providing parameters. If you want to see what tokens are supported for a specific contract type you can pass in either ERC20 or QRC20 as a contract type parameter. You can then filter further by including the resource using the technology and network parameters. You can also look for a specific token by passing in the unit as a parameter.
     * @summary Retrieve a list of ERC20 and QRC20 tokens
     * @param {Location} [location] 
     * @param {string} [contractType] 
     * @param {string} [unit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportedFungibleTokensApi
     */
    public getTokens(location?: Location, contractType?: string, unit?: string, options?: AxiosRequestConfig) {
        return SupportedFungibleTokensApiFp(this.configuration).getTokens(location, contractType, unit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SupportedNonFungibleTokensApi - axios parameter creator
 * @export
 */
export const SupportedNonFungibleTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of non-fungible tokens supported by Overledger and which API\'s and functions you can use for each. You can retrieve all non-fungible token types for all locations without providing parameters. If you want to see what tokens are supported for a specific contract type you can pass in either ERC721 or QRC721 as a contract type parameter. You can then filter further by including the resource using technology and network parameters. You can also look for a specific token by passing in the tokenName as a parameter.
         * @summary Retrieve a list of ERC721 and QRC721 tokens
         * @param {string} authorization 
         * @param {string} [contractType] 
         * @param {string} [technology] 
         * @param {string} [network] 
         * @param {string} [tokenName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllNonFungibleTokens: async (authorization: string, contractType?: string, technology?: string, network?: string, tokenName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getAllNonFungibleTokens', 'authorization', authorization)
            const localVarPath = `/v2/tokenise/tokens/nonfungible`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contractType !== undefined) {
                localVarQueryParameter['contractType'] = contractType;
            }

            if (technology !== undefined) {
                localVarQueryParameter['technology'] = technology;
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (tokenName !== undefined) {
                localVarQueryParameter['tokenName'] = tokenName;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportedNonFungibleTokensApi - functional programming interface
 * @export
 */
export const SupportedNonFungibleTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupportedNonFungibleTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of non-fungible tokens supported by Overledger and which API\'s and functions you can use for each. You can retrieve all non-fungible token types for all locations without providing parameters. If you want to see what tokens are supported for a specific contract type you can pass in either ERC721 or QRC721 as a contract type parameter. You can then filter further by including the resource using technology and network parameters. You can also look for a specific token by passing in the tokenName as a parameter.
         * @summary Retrieve a list of ERC721 and QRC721 tokens
         * @param {string} authorization 
         * @param {string} [contractType] 
         * @param {string} [technology] 
         * @param {string} [network] 
         * @param {string} [tokenName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllNonFungibleTokens(authorization: string, contractType?: string, technology?: string, network?: string, tokenName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonFungibleTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllNonFungibleTokens(authorization, contractType, technology, network, tokenName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SupportedNonFungibleTokensApi - factory interface
 * @export
 */
export const SupportedNonFungibleTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupportedNonFungibleTokensApiFp(configuration)
    return {
        /**
         * Retrieves a list of non-fungible tokens supported by Overledger and which API\'s and functions you can use for each. You can retrieve all non-fungible token types for all locations without providing parameters. If you want to see what tokens are supported for a specific contract type you can pass in either ERC721 or QRC721 as a contract type parameter. You can then filter further by including the resource using technology and network parameters. You can also look for a specific token by passing in the tokenName as a parameter.
         * @summary Retrieve a list of ERC721 and QRC721 tokens
         * @param {string} authorization 
         * @param {string} [contractType] 
         * @param {string} [technology] 
         * @param {string} [network] 
         * @param {string} [tokenName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllNonFungibleTokens(authorization: string, contractType?: string, technology?: string, network?: string, tokenName?: string, options?: any): AxiosPromise<NonFungibleTokenResponse> {
            return localVarFp.getAllNonFungibleTokens(authorization, contractType, technology, network, tokenName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupportedNonFungibleTokensApi - object-oriented interface
 * @export
 * @class SupportedNonFungibleTokensApi
 * @extends {BaseAPI}
 */
export class SupportedNonFungibleTokensApi extends BaseAPI {
    /**
     * Retrieves a list of non-fungible tokens supported by Overledger and which API\'s and functions you can use for each. You can retrieve all non-fungible token types for all locations without providing parameters. If you want to see what tokens are supported for a specific contract type you can pass in either ERC721 or QRC721 as a contract type parameter. You can then filter further by including the resource using technology and network parameters. You can also look for a specific token by passing in the tokenName as a parameter.
     * @summary Retrieve a list of ERC721 and QRC721 tokens
     * @param {string} authorization 
     * @param {string} [contractType] 
     * @param {string} [technology] 
     * @param {string} [network] 
     * @param {string} [tokenName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportedNonFungibleTokensApi
     */
    public getAllNonFungibleTokens(authorization: string, contractType?: string, technology?: string, network?: string, tokenName?: string, options?: AxiosRequestConfig) {
        return SupportedNonFungibleTokensApiFp(this.configuration).getAllNonFungibleTokens(authorization, contractType, technology, network, tokenName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenControllerApi - axios parameter creator
 * @export
 */
export const TokenControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} tokenName 
         * @param {string} technology 
         * @param {string} network 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonFungibleToken: async (tokenName: string, technology: string, network: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenName' is not null or undefined
            assertParamExists('getNonFungibleToken', 'tokenName', tokenName)
            // verify required parameter 'technology' is not null or undefined
            assertParamExists('getNonFungibleToken', 'technology', technology)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('getNonFungibleToken', 'network', network)
            const localVarPath = `/v2/nonfungibletoken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tokenName !== undefined) {
                localVarQueryParameter['tokenName'] = tokenName;
            }

            if (technology !== undefined) {
                localVarQueryParameter['technology'] = technology;
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenControllerApi - functional programming interface
 * @export
 */
export const TokenControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} tokenName 
         * @param {string} technology 
         * @param {string} network 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNonFungibleToken(tokenName: string, technology: string, network: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NonFungibleTokenDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNonFungibleToken(tokenName, technology, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokenControllerApi - factory interface
 * @export
 */
export const TokenControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} tokenName 
         * @param {string} technology 
         * @param {string} network 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNonFungibleToken(tokenName: string, technology: string, network: string, options?: any): AxiosPromise<NonFungibleTokenDTO> {
            return localVarFp.getNonFungibleToken(tokenName, technology, network, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenControllerApi - object-oriented interface
 * @export
 * @class TokenControllerApi
 * @extends {BaseAPI}
 */
export class TokenControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} tokenName 
     * @param {string} technology 
     * @param {string} network 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenControllerApi
     */
    public getNonFungibleToken(tokenName: string, technology: string, network: string, options?: AxiosRequestConfig) {
        return TokenControllerApiFp(this.configuration).getNonFungibleToken(tokenName, technology, network, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionSearchApi - axios parameter creator
 * @export
 */
export const TransactionSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the transaction search on the requested DLT.
         * @summary Prepare and automatically execute a search for a transaction on a DLT.
         * @param {string} authorization 
         * @param {string} transactionId The transactionId to search for
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchTransactionRequest: async (authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchTransactionRequest', 'authorization', authorization)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('autoExecuteSearchTransactionRequest', 'transactionId', transactionId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchTransactionRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID and searches for the transaction on the requested DLT
         * @summary Execute a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestTransaction: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequestTransaction', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequestTransaction', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for and returns data on transactions on a particular DLT. Returns a request ID for executing a transaction search on the requested DLT
         * @summary Prepare a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} transactionId The transactionId to search for
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchRequest: async (authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSearchRequest', 'authorization', authorization)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('prepareSearchRequest', 'transactionId', transactionId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareSearchRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionSearchApi - functional programming interface
 * @export
 */
export const TransactionSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the transaction search on the requested DLT.
         * @summary Prepare and automatically execute a search for a transaction on a DLT.
         * @param {string} authorization 
         * @param {string} transactionId The transactionId to search for
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchTransactionRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareAndExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchTransactionRequest(authorization, transactionId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID and searches for the transaction on the requested DLT
         * @summary Execute a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequestTransaction(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequestTransaction(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches for and returns data on transactions on a particular DLT. Returns a request ID for executing a transaction search on the requested DLT
         * @summary Prepare a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} transactionId The transactionId to search for
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSearchRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSearchRequest(authorization, transactionId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionSearchApi - factory interface
 * @export
 */
export const TransactionSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the transaction search on the requested DLT.
         * @summary Prepare and automatically execute a search for a transaction on a DLT.
         * @param {string} authorization 
         * @param {string} transactionId The transactionId to search for
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchTransactionRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareAndExecuteTransactionResponse> {
            return localVarFp.autoExecuteSearchTransactionRequest(authorization, transactionId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID and searches for the transaction on the requested DLT
         * @summary Execute a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestTransaction(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchTransactionResponse> {
            return localVarFp.executePreparedSearchRequestTransaction(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for and returns data on transactions on a particular DLT. Returns a request ID for executing a transaction search on the requested DLT
         * @summary Prepare a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} transactionId The transactionId to search for
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareSearchRequest(authorization, transactionId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionSearchApi - object-oriented interface
 * @export
 * @class TransactionSearchApi
 * @extends {BaseAPI}
 */
export class TransactionSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the transaction search on the requested DLT.
     * @summary Prepare and automatically execute a search for a transaction on a DLT.
     * @param {string} authorization 
     * @param {string} transactionId The transactionId to search for
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionSearchApi
     */
    public autoExecuteSearchTransactionRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return TransactionSearchApiFp(this.configuration).autoExecuteSearchTransactionRequest(authorization, transactionId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID and searches for the transaction on the requested DLT
     * @summary Execute a search for a transaction on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionSearchApi
     */
    public executePreparedSearchRequestTransaction(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return TransactionSearchApiFp(this.configuration).executePreparedSearchRequestTransaction(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for and returns data on transactions on a particular DLT. Returns a request ID for executing a transaction search on the requested DLT
     * @summary Prepare a search for a transaction on a DLT
     * @param {string} authorization 
     * @param {string} transactionId The transactionId to search for
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionSearchApi
     */
    public prepareSearchRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return TransactionSearchApiFp(this.configuration).prepareSearchRequest(authorization, transactionId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UTXOStatusSearchApi - axios parameter creator
 * @export
 */
export const UTXOStatusSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the utxo search on the requested DLT.
         * @summary Prepare and automatically execute a search for a UTXO on a DLT.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchUtxoRequest: async (authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchUtxoRequest', 'authorization', authorization)
            // verify required parameter 'utxoId' is not null or undefined
            assertParamExists('autoExecuteSearchUtxoRequest', 'utxoId', utxoId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchUtxoRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/utxo/{utxoId}`
                .replace(`{${"utxoId"}}`, encodeURIComponent(String(utxoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID, searches for the UTXO state and retrieves the details on the requested DLT. This API is only applicable for Bitcoin.
         * @summary Execute a search for UTXO state on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeUTXOPreparedSearchRequest: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executeUTXOPreparedSearchRequest', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executeUTXOPreparedSearchRequest', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/utxo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a request ID for executing a search for the status ofa UTXO on UTXO based DLT’s
         * @summary Prepare Search for a UTXO State.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchUTXOState: async (authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSearchUTXOState', 'authorization', authorization)
            // verify required parameter 'utxoId' is not null or undefined
            assertParamExists('prepareSearchUTXOState', 'utxoId', utxoId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareSearchUTXOState', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/utxo/{utxoId}`
                .replace(`{${"utxoId"}}`, encodeURIComponent(String(utxoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UTXOStatusSearchApi - functional programming interface
 * @export
 */
export const UTXOStatusSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UTXOStatusSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the utxo search on the requested DLT.
         * @summary Prepare and automatically execute a search for a UTXO on a DLT.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchUtxoRequest(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecuteSearchUTXOResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchUtxoRequest(authorization, utxoId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID, searches for the UTXO state and retrieves the details on the requested DLT. This API is only applicable for Bitcoin.
         * @summary Execute a search for UTXO state on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeUTXOPreparedSearchRequest(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchUTXOResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeUTXOPreparedSearchRequest(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a request ID for executing a search for the status ofa UTXO on UTXO based DLT’s
         * @summary Prepare Search for a UTXO State.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSearchUTXOState(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSearchUTXOState(authorization, utxoId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UTXOStatusSearchApi - factory interface
 * @export
 */
export const UTXOStatusSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UTXOStatusSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the utxo search on the requested DLT.
         * @summary Prepare and automatically execute a search for a UTXO on a DLT.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchUtxoRequest(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecuteSearchUTXOResponseSchema> {
            return localVarFp.autoExecuteSearchUtxoRequest(authorization, utxoId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID, searches for the UTXO state and retrieves the details on the requested DLT. This API is only applicable for Bitcoin.
         * @summary Execute a search for UTXO state on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeUTXOPreparedSearchRequest(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchUTXOResponseSchema> {
            return localVarFp.executeUTXOPreparedSearchRequest(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a request ID for executing a search for the status ofa UTXO on UTXO based DLT’s
         * @summary Prepare Search for a UTXO State.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchUTXOState(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareSearchUTXOState(authorization, utxoId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UTXOStatusSearchApi - object-oriented interface
 * @export
 * @class UTXOStatusSearchApi
 * @extends {BaseAPI}
 */
export class UTXOStatusSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the utxo search on the requested DLT.
     * @summary Prepare and automatically execute a search for a UTXO on a DLT.
     * @param {string} authorization 
     * @param {string} utxoId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UTXOStatusSearchApi
     */
    public autoExecuteSearchUtxoRequest(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return UTXOStatusSearchApiFp(this.configuration).autoExecuteSearchUtxoRequest(authorization, utxoId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID, searches for the UTXO state and retrieves the details on the requested DLT. This API is only applicable for Bitcoin.
     * @summary Execute a search for UTXO state on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UTXOStatusSearchApi
     */
    public executeUTXOPreparedSearchRequest(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return UTXOStatusSearchApiFp(this.configuration).executeUTXOPreparedSearchRequest(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a request ID for executing a search for the status ofa UTXO on UTXO based DLT’s
     * @summary Prepare Search for a UTXO State.
     * @param {string} authorization 
     * @param {string} utxoId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UTXOStatusSearchApi
     */
    public prepareSearchUTXOState(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return UTXOStatusSearchApiFp(this.configuration).prepareSearchUTXOState(authorization, utxoId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



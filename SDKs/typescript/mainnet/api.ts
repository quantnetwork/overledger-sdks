/* tslint:disable */
/* eslint-disable */
/**
 * Quant Overledger API
 * Quant\'s Overledger API allows developers to create applications for multiple DLT\'s using a single standard set of operations and data structures.In order to maintain the security of private keys, most operations have two steps â€“ prepare and execute. The prepare step is the point at which all arguments are specified and standardised payloads are sent. Overledger converts this standard payload into a DLT-specific transaction object. In the execute step, the SDK signs the transaction object that Overledger created and submits it to Overledger to perform the operation  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddressBalanceResponse
 */
export interface AddressBalanceResponse {
    /**
     * 
     * @type {string}
     * @memberof AddressBalanceResponse
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressBalanceResponse
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface AddressMonitoringDetailsSchema
 */
export interface AddressMonitoringDetailsSchema {
    /**
     * 
     * @type {Location}
     * @memberof AddressMonitoringDetailsSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {ResourceMonitoredAddressDetails}
     * @memberof AddressMonitoringDetailsSchema
     */
    'addressDetails'?: ResourceMonitoredAddressDetails;
    /**
     * 
     * @type {string}
     * @memberof AddressMonitoringDetailsSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressMonitoringDetailsSchema
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface AddressMonitoringRequestSchema
 */
export interface AddressMonitoringRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof AddressMonitoringRequestSchema
     */
    'callBackURL'?: string;
    /**
     * 
     * @type {Location}
     * @memberof AddressMonitoringRequestSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof AddressMonitoringRequestSchema
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface AddressMonitoringResponseSchema
 */
export interface AddressMonitoringResponseSchema {
    /**
     * 
     * @type {ResourceMonitoringSubscriptionDetails}
     * @memberof AddressMonitoringResponseSchema
     */
    'subscriptionDetails'?: ResourceMonitoringSubscriptionDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof AddressMonitoringResponseSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
    /**
     * 
     * @type {ResourceMonitoringSubscription}
     * @memberof AddressMonitoringResponseSchema
     */
    'subscription'?: ResourceMonitoringSubscription;
}
/**
 * 
 * @export
 * @interface ApproveRequestDetailsSchema
 */
export interface ApproveRequestDetailsSchema {
    /**
     * Who are the payees of this transaction
     * @type {Array<PayeeCreditSchema>}
     * @memberof ApproveRequestDetailsSchema
     */
    'mandate'?: Array<PayeeCreditSchema>;
    /**
     * 
     * @type {string}
     * @memberof ApproveRequestDetailsSchema
     */
    'overledgerSigningType'?: string;
    /**
     * Who are the payers of this transaction
     * @type {Array<PayerCreditSchema>}
     * @memberof ApproveRequestDetailsSchema
     */
    'payer'?: Array<PayerCreditSchema>;
}
/**
 * 
 * @export
 * @interface AutoExecSearchAddressSequenceResponseSchema
 */
export interface AutoExecSearchAddressSequenceResponseSchema {
    /**
     * 
     * @type {PrepareSearchResponseSchema}
     * @memberof AutoExecSearchAddressSequenceResponseSchema
     */
    'preparationAddressSequenceSearchResponse'?: PrepareSearchResponseSchema;
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof AutoExecSearchAddressSequenceResponseSchema
     */
    'prepareAndExecuteOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
    /**
     * 
     * @type {ExecuteSearchSequenceResponse}
     * @memberof AutoExecSearchAddressSequenceResponseSchema
     */
    'executionAddressSequenceSearchResponse'?: ExecuteSearchSequenceResponse;
}
/**
 * 
 * @export
 * @interface AutoExecuteSearchAddressBalanceResponseSchema
 */
export interface AutoExecuteSearchAddressBalanceResponseSchema {
    /**
     * 
     * @type {PrepareAndExecuteSearchAddressBalanceResponse}
     * @memberof AutoExecuteSearchAddressBalanceResponseSchema
     */
    'executionAddressBalanceSearchResponse'?: PrepareAndExecuteSearchAddressBalanceResponse;
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof AutoExecuteSearchAddressBalanceResponseSchema
     */
    'prepareAndExecuteOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
    /**
     * 
     * @type {PrepareSearchResponseSchema}
     * @memberof AutoExecuteSearchAddressBalanceResponseSchema
     */
    'preparationAddressBalanceSearchResponse'?: PrepareSearchResponseSchema;
}
/**
 * 
 * @export
 * @interface AutoExecuteSearchBlockResponseSchema
 */
export interface AutoExecuteSearchBlockResponseSchema {
    /**
     * 
     * @type {ExecuteSearchBlockResponse}
     * @memberof AutoExecuteSearchBlockResponseSchema
     */
    'executionBlockSearchResponse'?: ExecuteSearchBlockResponse;
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof AutoExecuteSearchBlockResponseSchema
     */
    'prepareAndExecuteOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
    /**
     * 
     * @type {PrepareSearchResponseSchema}
     * @memberof AutoExecuteSearchBlockResponseSchema
     */
    'preparationBlockSearchResponse'?: PrepareSearchResponseSchema;
}
/**
 * 
 * @export
 * @interface AutoExecuteSearchUTXOResponseSchema
 */
export interface AutoExecuteSearchUTXOResponseSchema {
    /**
     * 
     * @type {ExecuteSearchUTXOResponse}
     * @memberof AutoExecuteSearchUTXOResponseSchema
     */
    'executionUtxoSearchResponse'?: ExecuteSearchUTXOResponse;
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof AutoExecuteSearchUTXOResponseSchema
     */
    'prepareAndExecuteOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
    /**
     * 
     * @type {PrepareTransactionResponse}
     * @memberof AutoExecuteSearchUTXOResponseSchema
     */
    'preparationUtxoSearchResponse'?: PrepareTransactionResponse;
}
/**
 * 
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'blockId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Block
     */
    'number'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Block
     */
    'transactionIds'?: Array<string>;
    /**
     * 
     * @type {Array<BlockSize>}
     * @memberof Block
     */
    'size'?: Array<BlockSize>;
    /**
     * 
     * @type {Array<BlockHash>}
     * @memberof Block
     */
    'hashes'?: Array<BlockHash>;
    /**
     * 
     * @type {LinkedBlocks}
     * @memberof Block
     */
    'linkedBlocks'?: LinkedBlocks;
    /**
     * 
     * @type {number}
     * @memberof Block
     */
    'numberOfTransactions'?: number;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'timestamp'?: string;
    /**
     * 
     * @type {object}
     * @memberof Block
     */
    'nativeData'?: object;
}
/**
 * 
 * @export
 * @interface BlockHash
 */
export interface BlockHash {
    /**
     * 
     * @type {string}
     * @memberof BlockHash
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockHash
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface BlockSize
 */
export interface BlockSize {
    /**
     * 
     * @type {string}
     * @memberof BlockSize
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockSize
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockSize
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface CreateSmartContractMonitoringSchema
 */
export interface CreateSmartContractMonitoringSchema {
    /**
     * 
     * @type {ResourceMonitoringSubscriptionDetails}
     * @memberof CreateSmartContractMonitoringSchema
     */
    'subscriptionDetails'?: ResourceMonitoringSubscriptionDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof CreateSmartContractMonitoringSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
    /**
     * 
     * @type {ResourceMonitoringSubscription}
     * @memberof CreateSmartContractMonitoringSchema
     */
    'subscription'?: ResourceMonitoringSubscription;
}
/**
 * 
 * @export
 * @interface CreateSubscriptionRequestSchema
 */
export interface CreateSubscriptionRequestSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateSubscriptionRequestSchema
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateSubscriptionRequestSchema
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSubscriptionRequestSchema
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CreateSubscriptionResponseSchema
 */
export interface CreateSubscriptionResponseSchema {
    /**
     * 
     * @type {SubscriptionDetailsSchema}
     * @memberof CreateSubscriptionResponseSchema
     */
    'scubscriptionDetails'?: SubscriptionDetailsSchema;
    /**
     * 
     * @type {string}
     * @memberof CreateSubscriptionResponseSchema
     */
    'subscriptionId'?: string;
}
/**
 * 
 * @export
 * @interface CreditRequestDetailsSchema
 */
export interface CreditRequestDetailsSchema {
    /**
     * Who are the payees of this transaction
     * @type {Array<PayeeCreditSchema>}
     * @memberof CreditRequestDetailsSchema
     */
    'payee'?: Array<PayeeCreditSchema>;
    /**
     * 
     * @type {string}
     * @memberof CreditRequestDetailsSchema
     */
    'overledgerSigningType'?: string;
    /**
     * Any text-based element of the data payload
     * @type {string}
     * @memberof CreditRequestDetailsSchema
     */
    'message'?: string;
    /**
     * Who are the payers of this transaction
     * @type {Array<PayerCreditSchema>}
     * @memberof CreditRequestDetailsSchema
     */
    'payer'?: Array<PayerCreditSchema>;
}
/**
 * 
 * @export
 * @interface DeleteResourceMonitoringAddressSchema
 */
export interface DeleteResourceMonitoringAddressSchema {
    /**
     * 
     * @type {ResourceMonitoringAddressDetails}
     * @memberof DeleteResourceMonitoringAddressSchema
     */
    'addressMonitoringDetails'?: ResourceMonitoringAddressDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof DeleteResourceMonitoringAddressSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
}
/**
 * The Destination of this transaction
 * @export
 * @interface Destination
 */
export interface Destination {
    /**
     * 
     * @type {Transfer}
     * @memberof Destination
     */
    'transfer'?: Transfer;
    /**
     * 
     * @type {SmartContract}
     * @memberof Destination
     */
    'smartContract'?: SmartContract;
    /**
     * 
     * @type {Payment}
     * @memberof Destination
     */
    'payment'?: Payment;
    /**
     * The unique identifiers of the destination
     * @type {string}
     * @memberof Destination
     */
    'destinationId'?: string;
}
/**
 * The Destination of this transaction
 * @export
 * @interface DestinationPaymentSchema
 */
export interface DestinationPaymentSchema {
    /**
     * 
     * @type {PaymentSchema}
     * @memberof DestinationPaymentSchema
     */
    'payment'?: PaymentSchema;
    /**
     * The unique identifiers of the destination
     * @type {string}
     * @memberof DestinationPaymentSchema
     */
    'destinationId'?: string;
}
/**
 * 
 * @export
 * @interface DestinationTransferSchema
 */
export interface DestinationTransferSchema {
    /**
     * 
     * @type {TransferSchema}
     * @memberof DestinationTransferSchema
     */
    'transfer'?: TransferSchema;
    /**
     * 
     * @type {string}
     * @memberof DestinationTransferSchema
     */
    'destinationId'?: string;
}
/**
 * 
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetails
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetails
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetails
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface ErrorList
 */
export interface ErrorList {
    /**
     * 
     * @type {Array<Error>}
     * @memberof ErrorList
     */
    'errors'?: Array<Error>;
    /**
     * 
     * @type {number}
     * @memberof ErrorList
     */
    'errorCount'?: number;
}
/**
 * 
 * @export
 * @interface ExecuteSearchBalanceResponse
 */
export interface ExecuteSearchBalanceResponse {
    /**
     * 
     * @type {Array<AddressBalanceResponse>}
     * @memberof ExecuteSearchBalanceResponse
     */
    'balances'?: Array<AddressBalanceResponse>;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchBalanceResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchBalanceResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchBalanceResponse
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteSearchBlockResponse
 */
export interface ExecuteSearchBlockResponse {
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchBlockResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {Block}
     * @memberof ExecuteSearchBlockResponse
     */
    'block'?: Block;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteSearchBlockResponse
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface ExecuteSearchSequenceResponse
 */
export interface ExecuteSearchSequenceResponse {
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchSequenceResponse
     */
    'sequence'?: string;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchSequenceResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchSequenceResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchSequenceResponse
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface ExecuteSearchTransactionResponse
 */
export interface ExecuteSearchTransactionResponse {
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchTransactionResponse
     */
    'location'?: Location;
    /**
     * The type of the transaction object returned
     * @type {string}
     * @memberof ExecuteSearchTransactionResponse
     */
    'type'?: string;
    /**
     * 
     * @type {Transaction}
     * @memberof ExecuteSearchTransactionResponse
     */
    'transaction'?: Transaction;
    /**
     * The unix time to read the object from
     * @type {string}
     * @memberof ExecuteSearchTransactionResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteSearchTransactionResponse
     */
    'status'?: Status;
    /**
     * 
     * @type {object}
     * @memberof ExecuteSearchTransactionResponse
     */
    'extraFields'?: object;
}
/**
 * 
 * @export
 * @interface ExecuteSearchUTXOResponse
 */
export interface ExecuteSearchUTXOResponse {
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchUTXOResponse
     */
    'utxoId'?: string;
    /**
     * 
     * @type {Array<Destination>}
     * @memberof ExecuteSearchUTXOResponse
     */
    'destination'?: Array<Destination>;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchUTXOResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchUTXOResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteSearchUTXOResponse
     */
    'status'?: Status;
    /**
     * 
     * @type {object}
     * @memberof ExecuteSearchUTXOResponse
     */
    'nativeData'?: object;
}
/**
 * 
 * @export
 * @interface ExecuteSearchUTXOResponseSchema
 */
export interface ExecuteSearchUTXOResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'utxoId'?: string;
    /**
     * 
     * @type {Array<UTXODestination>}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'destination'?: Array<UTXODestination>;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {UTXOTimestampSchema}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'timestamp'?: UTXOTimestampSchema;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'status'?: Status;
    /**
     * 
     * @type {UTXONativeData}
     * @memberof ExecuteSearchUTXOResponseSchema
     */
    'nativeData'?: UTXONativeData;
}
/**
 * 
 * @export
 * @interface ExecuteSmartContractReadResponseSchema
 */
export interface ExecuteSmartContractReadResponseSchema {
    /**
     * 
     * @type {SmartContractReadSchema}
     * @memberof ExecuteSmartContractReadResponseSchema
     */
    'smartContract'?: SmartContractReadSchema;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteSmartContractReadResponseSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface ExecuteTransactionRequest
 */
export interface ExecuteTransactionRequest {
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof ExecuteTransactionRequest
     */
    'requestId': string;
    /**
     * The raw data after transaction signing
     * @type {string}
     * @memberof ExecuteTransactionRequest
     */
    'signed': string;
}
/**
 * 
 * @export
 * @interface ExecuteTransactionResponse
 */
export interface ExecuteTransactionResponse {
    /**
     * 
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'urgency'?: string;
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'requestId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'overledgerTransactionId'?: string;
    /**
     * 
     * @type {Location}
     * @memberof ExecuteTransactionResponse
     */
    'location'?: Location;
    /**
     * The type of the transaction executed
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'type'?: string;
    /**
     * The ID assigned by Overledger to a transaction submitted to a DLT via Overledger
     * @type {string}
     * @memberof ExecuteTransactionResponse
     */
    'transactionId'?: string;
    /**
     * 
     * @type {Status}
     * @memberof ExecuteTransactionResponse
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface ExtraFields
 */
export interface ExtraFields {
    /**
     * 
     * @type {number}
     * @memberof ExtraFields
     */
    'requiredSignatures'?: number;
}
/**
 * 
 * @export
 * @interface Fee
 */
export interface Fee {
    /**
     * The amount of a currency
     * @type {string}
     * @memberof Fee
     */
    'amount': string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof Fee
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface Function
 */
export interface Function {
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    'functionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof Function
     */
    'inputParameters'?: Array<Parameter>;
    /**
     * 
     * @type {Array<Parameter>}
     * @memberof Function
     */
    'outputParameters'?: Array<Parameter>;
}
/**
 * 
 * @export
 * @interface InternalServerErrorSchema
 */
export interface InternalServerErrorSchema {
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorSchema
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorSchema
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorSchema
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorSchema
     */
    'timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalServerErrorSchema
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface LinkedBlocks
 */
export interface LinkedBlocks {
    /**
     * 
     * @type {string}
     * @memberof LinkedBlocks
     */
    'parent'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedBlocks
     */
    'child'?: string;
}
/**
 * 
 * @export
 * @interface ListSubscriptionResponseSchema
 */
export interface ListSubscriptionResponseSchema {
    /**
     * 
     * @type {SubscriptionDetailsSchema}
     * @memberof ListSubscriptionResponseSchema
     */
    'subscriptionDetails'?: SubscriptionDetailsSchema;
    /**
     * 
     * @type {string}
     * @memberof ListSubscriptionResponseSchema
     */
    'subscribedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSubscriptionResponseSchema
     */
    'lastUpdatedTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSubscriptionResponseSchema
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSubscriptionResponseSchema
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSubscriptionResponseSchema
     */
    'type'?: string;
}
/**
 * Unique reference to the ledger on a particular ledger network (optionally accessed from a particular node)
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * The technology used by the desired network
     * @type {string}
     * @memberof Location
     */
    'technology': string;
    /**
     * The network that the ledger resides on
     * @type {string}
     * @memberof Location
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface MonitorSmartContractEventParam
 */
export interface MonitorSmartContractEventParam {
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractEventParam
     */
    'selectedIntegerLength'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractEventParam
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractEventParam
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface MonitorSmartContractRequestSchema
 */
export interface MonitorSmartContractRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractRequestSchema
     */
    'callBackURL'?: string;
    /**
     * 
     * @type {Array<MonitorSmartContractEventParam>}
     * @memberof MonitorSmartContractRequestSchema
     */
    'eventParams'?: Array<MonitorSmartContractEventParam>;
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractRequestSchema
     */
    'eventName'?: string;
    /**
     * 
     * @type {Location}
     * @memberof MonitorSmartContractRequestSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof MonitorSmartContractRequestSchema
     */
    'smartContractId'?: string;
}
/**
 * Where is this transaction coming from
 * @export
 * @interface Origin
 */
export interface Origin {
    /**
     * 
     * @type {string}
     * @memberof Origin
     */
    'sequence'?: string;
    /**
     * 
     * @type {string}
     * @memberof Origin
     */
    'originId'?: string;
    /**
     * 
     * @type {SmartContract}
     * @memberof Origin
     */
    'smartContract'?: SmartContract;
}
/**
 * Where is this transaction coming from
 * @export
 * @interface OriginPaymentSchema
 */
export interface OriginPaymentSchema {
    /**
     * Unique Identifier of the originator
     * @type {string}
     * @memberof OriginPaymentSchema
     */
    'originId'?: string;
}
/**
 * 
 * @export
 * @interface OriginTransferSchema
 */
export interface OriginTransferSchema {
    /**
     * 
     * @type {string}
     * @memberof OriginTransferSchema
     */
    'originId'?: string;
}
/**
 * 
 * @export
 * @interface OverledgerTransactionResponseSchema
 */
export interface OverledgerTransactionResponseSchema {
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'requestId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'overledgerTransactionId'?: string;
    /**
     * 
     * @type {Location}
     * @memberof OverledgerTransactionResponseSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {Array<Status>}
     * @memberof OverledgerTransactionResponseSchema
     */
    'transactionHistory'?: Array<Status>;
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OverledgerTransactionResponseSchema
     */
    'transactionId'?: string;
    /**
     * 
     * @type {Status}
     * @memberof OverledgerTransactionResponseSchema
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface Parameter
 */
export interface Parameter {
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    'type'?: string;
    /**
     * 
     * @type {object}
     * @memberof Parameter
     */
    'value'?: object;
    /**
     * 
     * @type {string}
     * @memberof Parameter
     */
    'key'?: string;
}
/**
 * Who are the payees of this transaction
 * @export
 * @interface PayeeCreditSchema
 */
export interface PayeeCreditSchema {
    /**
     * 
     * @type {PaymentSchema}
     * @memberof PayeeCreditSchema
     */
    'payment'?: PaymentSchema;
    /**
     * The unique identifiers of the payees
     * @type {string}
     * @memberof PayeeCreditSchema
     */
    'payeeId'?: string;
}
/**
 * Who are the payers of this transaction
 * @export
 * @interface PayerCreditSchema
 */
export interface PayerCreditSchema {
    /**
     * Unique Identifier of the payer
     * @type {string}
     * @memberof PayerCreditSchema
     */
    'payerId'?: string;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * The amount of a currency
     * @type {string}
     * @memberof Payment
     */
    'amount'?: string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof Payment
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    'issuer'?: string;
}
/**
 * 
 * @export
 * @interface PaymentRequestDetailsSchema
 */
export interface PaymentRequestDetailsSchema {
    /**
     * 
     * @type {string}
     * @memberof PaymentRequestDetailsSchema
     */
    'overledgerSigningType'?: string;
    /**
     * Where is this transaction coming from
     * @type {Array<OriginPaymentSchema>}
     * @memberof PaymentRequestDetailsSchema
     */
    'origin'?: Array<OriginPaymentSchema>;
    /**
     * The Destination of this transaction
     * @type {Array<DestinationPaymentSchema>}
     * @memberof PaymentRequestDetailsSchema
     */
    'destination'?: Array<DestinationPaymentSchema>;
    /**
     * Any text-based element of the data payload
     * @type {string}
     * @memberof PaymentRequestDetailsSchema
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface PaymentSchema
 */
export interface PaymentSchema {
    /**
     * The amount of a currency
     * @type {string}
     * @memberof PaymentSchema
     */
    'amount': string;
    /**
     * The unit of this currency/token
     * @type {string}
     * @memberof PaymentSchema
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface PrepareAndExecuteBalanceDetails
 */
export interface PrepareAndExecuteBalanceDetails {
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteBalanceDetails
     */
    'unit'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteBalanceDetails
     */
    'amount'?: string;
}
/**
 * 
 * @export
 * @interface PrepareAndExecuteOverledgerErrorResponse
 */
export interface PrepareAndExecuteOverledgerErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteOverledgerErrorResponse
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteOverledgerErrorResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteOverledgerErrorResponse
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface PrepareAndExecuteSearchAddressBalanceResponse
 */
export interface PrepareAndExecuteSearchAddressBalanceResponse {
    /**
     * 
     * @type {Array<PrepareAndExecuteBalanceDetails>}
     * @memberof PrepareAndExecuteSearchAddressBalanceResponse
     */
    'balances'?: Array<PrepareAndExecuteBalanceDetails>;
    /**
     * 
     * @type {Location}
     * @memberof PrepareAndExecuteSearchAddressBalanceResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteSearchAddressBalanceResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrepareAndExecuteSearchAddressBalanceResponse
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface PrepareAndExecuteTransactionResponse
 */
export interface PrepareAndExecuteTransactionResponse {
    /**
     * 
     * @type {PrepareAndExecuteOverledgerErrorResponse}
     * @memberof PrepareAndExecuteTransactionResponse
     */
    'executionTransactionSearchOverledgerErrorResponse'?: PrepareAndExecuteOverledgerErrorResponse;
    /**
     * 
     * @type {PrepareTransactionResponse}
     * @memberof PrepareAndExecuteTransactionResponse
     */
    'preparationTransactionSearchResponse'?: PrepareTransactionResponse;
    /**
     * 
     * @type {ExecuteSearchTransactionResponse}
     * @memberof PrepareAndExecuteTransactionResponse
     */
    'executionTransactionSearchResponse'?: ExecuteSearchTransactionResponse;
}
/**
 * 
 * @export
 * @interface PrepareApproveDebitTransactionRequestSchema
 */
export interface PrepareApproveDebitTransactionRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof PrepareApproveDebitTransactionRequestSchema
     */
    'urgency'?: string;
    /**
     * 
     * @type {ApproveRequestDetailsSchema}
     * @memberof PrepareApproveDebitTransactionRequestSchema
     */
    'requestDetails'?: ApproveRequestDetailsSchema;
    /**
     * 
     * @type {Location}
     * @memberof PrepareApproveDebitTransactionRequestSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof PrepareApproveDebitTransactionRequestSchema
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PrepareCreditTransactionRequestSchema
 */
export interface PrepareCreditTransactionRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof PrepareCreditTransactionRequestSchema
     */
    'urgency'?: string;
    /**
     * 
     * @type {CreditRequestDetailsSchema}
     * @memberof PrepareCreditTransactionRequestSchema
     */
    'requestDetails'?: CreditRequestDetailsSchema;
    /**
     * 
     * @type {Location}
     * @memberof PrepareCreditTransactionRequestSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof PrepareCreditTransactionRequestSchema
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PrepareNativeTransactionRequestSchema
 */
export interface PrepareNativeTransactionRequestSchema {
    /**
     * 
     * @type {Location}
     * @memberof PrepareNativeTransactionRequestSchema
     */
    'location'?: Location;
    /**
     * The type of the object
     * @type {string}
     * @memberof PrepareNativeTransactionRequestSchema
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PreparePaymentTransactionRequestSchema
 */
export interface PreparePaymentTransactionRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof PreparePaymentTransactionRequestSchema
     */
    'urgency'?: string;
    /**
     * 
     * @type {PaymentRequestDetailsSchema}
     * @memberof PreparePaymentTransactionRequestSchema
     */
    'requestDetails'?: PaymentRequestDetailsSchema;
    /**
     * 
     * @type {Location}
     * @memberof PreparePaymentTransactionRequestSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof PreparePaymentTransactionRequestSchema
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PrepareSearchResponseSchema
 */
export interface PrepareSearchResponseSchema {
    /**
     * 
     * @type {Fee}
     * @memberof PrepareSearchResponseSchema
     */
    'gatewayFee'?: Fee;
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof PrepareSearchResponseSchema
     */
    'requestId'?: string;
}
/**
 * 
 * @export
 * @interface PrepareSearchSchema
 */
export interface PrepareSearchSchema {
    /**
     * 
     * @type {Location}
     * @memberof PrepareSearchSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface PrepareSearchSmartContractRequestSchema
 */
export interface PrepareSearchSmartContractRequestSchema {
    /**
     * 
     * @type {SmartContractSearchRequestDetails}
     * @memberof PrepareSearchSmartContractRequestSchema
     */
    'requestDetails'?: SmartContractSearchRequestDetails;
    /**
     * 
     * @type {Location}
     * @memberof PrepareSearchSmartContractRequestSchema
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface PrepareTransactionResponse
 */
export interface PrepareTransactionResponse {
    /**
     * 
     * @type {Fee}
     * @memberof PrepareTransactionResponse
     */
    'gatewayFee'?: Fee;
    /**
     * The ID assigned to a preparation request in Overledger
     * @type {string}
     * @memberof PrepareTransactionResponse
     */
    'requestId'?: string;
    /**
     * 
     * @type {Fee}
     * @memberof PrepareTransactionResponse
     */
    'dltFee'?: Fee;
    /**
     * 
     * @type {object}
     * @memberof PrepareTransactionResponse
     */
    'nativeData'?: object;
}
/**
 * 
 * @export
 * @interface PrepareTransactionSmartContractInvokeRequestSchema
 */
export interface PrepareTransactionSmartContractInvokeRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof PrepareTransactionSmartContractInvokeRequestSchema
     */
    'urgency'?: string;
    /**
     * 
     * @type {SmartContractInvokeRequestDetailsSchema}
     * @memberof PrepareTransactionSmartContractInvokeRequestSchema
     */
    'requestDetails'?: SmartContractInvokeRequestDetailsSchema;
    /**
     * 
     * @type {Location}
     * @memberof PrepareTransactionSmartContractInvokeRequestSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof PrepareTransactionSmartContractInvokeRequestSchema
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PrepareTransferTransactionRequestSchema
 */
export interface PrepareTransferTransactionRequestSchema {
    /**
     * 
     * @type {string}
     * @memberof PrepareTransferTransactionRequestSchema
     */
    'urgency'?: string;
    /**
     * 
     * @type {TransferRequestDetailsSchema}
     * @memberof PrepareTransferTransactionRequestSchema
     */
    'requestDetails'?: TransferRequestDetailsSchema;
    /**
     * 
     * @type {Location}
     * @memberof PrepareTransferTransactionRequestSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof PrepareTransferTransactionRequestSchema
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoredAddressDetails
 */
export interface ResourceMonitoredAddressDetails {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoredAddressDetails
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringAddressDetails
 */
export interface ResourceMonitoringAddressDetails {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringAddressDetails
     */
    'addressId'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringAddressSchema
 */
export interface ResourceMonitoringAddressSchema {
    /**
     * 
     * @type {ResourceMonitoringAddressDetails}
     * @memberof ResourceMonitoringAddressSchema
     */
    'addressMonitoringDetails'?: ResourceMonitoringAddressDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof ResourceMonitoringAddressSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringDetails
 */
export interface ResourceMonitoringDetails {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringDetails
     */
    'resourceMonitoringId'?: string;
    /**
     * 
     * @type {Location}
     * @memberof ResourceMonitoringDetails
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringDetails
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringDetails
     */
    'timestamp'?: string;
    /**
     * 
     * @type {Status}
     * @memberof ResourceMonitoringDetails
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringSmartContractEventDetails
 */
export interface ResourceMonitoringSmartContractEventDetails {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSmartContractEventDetails
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSmartContractEventDetails
     */
    'eventParameters'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSmartContractEventDetails
     */
    'smartContractId'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringSubscription
 */
export interface ResourceMonitoringSubscription {
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSubscription
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSubscription
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceMonitoringSubscription
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ResourceMonitoringSubscriptionDetails
 */
export interface ResourceMonitoringSubscriptionDetails {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourceMonitoringSubscriptionDetails
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {Status}
     * @memberof ResourceMonitoringSubscriptionDetails
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface ScriptPubKey
 */
export interface ScriptPubKey {
    /**
     * 
     * @type {Array<string>}
     * @memberof ScriptPubKey
     */
    'addresses'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ScriptPubKey
     */
    'asm'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScriptPubKey
     */
    'hex'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScriptPubKey
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScriptPubKey
     */
    'reqSigs'?: string;
}
/**
 * Computer program storage in a DLT system where the outcome is recorded on the distributed ledger
 * @export
 * @interface SmartContract
 */
export interface SmartContract {
    /**
     * 
     * @type {Function}
     * @memberof SmartContract
     */
    'function'?: Function;
    /**
     * 
     * @type {string}
     * @memberof SmartContract
     */
    'detail'?: string;
    /**
     * Information on the object type
     * @type {string}
     * @memberof SmartContract
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContract
     */
    'smartContractId'?: string;
    /**
     * 
     * @type {object}
     * @memberof SmartContract
     */
    'extraFields'?: object;
}
/**
 * 
 * @export
 * @interface SmartContractDestinationSchema
 */
export interface SmartContractDestinationSchema {
    /**
     * 
     * @type {SmartContractSchema}
     * @memberof SmartContractDestinationSchema
     */
    'smartContract'?: SmartContractSchema;
    /**
     * 
     * @type {SmartContractPaymentSchema}
     * @memberof SmartContractDestinationSchema
     */
    'payment'?: SmartContractPaymentSchema;
    /**
     * 
     * @type {string}
     * @memberof SmartContractDestinationSchema
     */
    'destinationId'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractEventHistory
 */
export interface SmartContractEventHistory {
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'eventId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'eventParameters'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'transactionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractEventHistory
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractFunctionSchema
 */
export interface SmartContractFunctionSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractFunctionSchema
     */
    'name'?: string;
    /**
     * 
     * @type {Array<SmartContractInputParameterSchema>}
     * @memberof SmartContractFunctionSchema
     */
    'inputParameters'?: Array<SmartContractInputParameterSchema>;
}
/**
 * 
 * @export
 * @interface SmartContractInputParameterSchema
 */
export interface SmartContractInputParameterSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractInputParameterSchema
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractInputParameterSchema
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractInvokeRequestDetailsSchema
 */
export interface SmartContractInvokeRequestDetailsSchema {
    /**
     * 
     * @type {Array<SmartContractRequestDetailsOrigin>}
     * @memberof SmartContractInvokeRequestDetailsSchema
     */
    'origin'?: Array<SmartContractRequestDetailsOrigin>;
    /**
     * 
     * @type {Array<SmartContractDestinationSchema>}
     * @memberof SmartContractInvokeRequestDetailsSchema
     */
    'destination'?: Array<SmartContractDestinationSchema>;
}
/**
 * 
 * @export
 * @interface SmartContractMonitoringDetailsSchema
 */
export interface SmartContractMonitoringDetailsSchema {
    /**
     * 
     * @type {Array<SmartContractEventHistory>}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'smartContractEventHistory'?: Array<SmartContractEventHistory>;
    /**
     * 
     * @type {ResourceMonitoringSmartContractEventDetails}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'smartContractEventDetails'?: ResourceMonitoringSmartContractEventDetails;
    /**
     * 
     * @type {Location}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'location'?: Location;
    /**
     * 
     * @type {string}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'type'?: string;
    /**
     * 
     * @type {Status}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'status'?: Status;
    /**
     * 
     * @type {string}
     * @memberof SmartContractMonitoringDetailsSchema
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractMonitoringSchema
 */
export interface SmartContractMonitoringSchema {
    /**
     * 
     * @type {ResourceMonitoringSmartContractEventDetails}
     * @memberof SmartContractMonitoringSchema
     */
    'smartContractEventMonitoringDetails'?: ResourceMonitoringSmartContractEventDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof SmartContractMonitoringSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
}
/**
 * 
 * @export
 * @interface SmartContractOutputParameterSchema
 */
export interface SmartContractOutputParameterSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractOutputParameterSchema
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractPaymentSchema
 */
export interface SmartContractPaymentSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractPaymentSchema
     */
    'amount'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractPaymentSchema
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractReadFunctionSchema
 */
export interface SmartContractReadFunctionSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractReadFunctionSchema
     */
    'functionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SmartContractReadFunctionSchema
     */
    'name'?: string;
    /**
     * 
     * @type {Array<SmartContractInputParameterSchema>}
     * @memberof SmartContractReadFunctionSchema
     */
    'inputParameters'?: Array<SmartContractInputParameterSchema>;
    /**
     * 
     * @type {Array<SmartContractInputParameterSchema>}
     * @memberof SmartContractReadFunctionSchema
     */
    'outputParameters'?: Array<SmartContractInputParameterSchema>;
}
/**
 * Computer program storage in a DLT system where the outcome is recorded on the distributed ledger
 * @export
 * @interface SmartContractReadSchema
 */
export interface SmartContractReadSchema {
    /**
     * 
     * @type {SmartContractReadFunctionSchema}
     * @memberof SmartContractReadSchema
     */
    'function'?: SmartContractReadFunctionSchema;
    /**
     * 
     * @type {string}
     * @memberof SmartContractReadSchema
     */
    'smartContractId'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractRequestDetailsOrigin
 */
export interface SmartContractRequestDetailsOrigin {
    /**
     * 
     * @type {string}
     * @memberof SmartContractRequestDetailsOrigin
     */
    'originId'?: string;
}
/**
 * 
 * @export
 * @interface SmartContractSchema
 */
export interface SmartContractSchema {
    /**
     * 
     * @type {SmartContractFunctionSchema}
     * @memberof SmartContractSchema
     */
    'function'?: SmartContractFunctionSchema;
}
/**
 * 
 * @export
 * @interface SmartContractSearchDestinationSchema
 */
export interface SmartContractSearchDestinationSchema {
    /**
     * 
     * @type {SmartContractSearchSchema}
     * @memberof SmartContractSearchDestinationSchema
     */
    'smartContract'?: SmartContractSearchSchema;
}
/**
 * 
 * @export
 * @interface SmartContractSearchFunctionSchema
 */
export interface SmartContractSearchFunctionSchema {
    /**
     * 
     * @type {string}
     * @memberof SmartContractSearchFunctionSchema
     */
    'name'?: string;
    /**
     * 
     * @type {Array<SmartContractInputParameterSchema>}
     * @memberof SmartContractSearchFunctionSchema
     */
    'inputParameters'?: Array<SmartContractInputParameterSchema>;
    /**
     * 
     * @type {Array<SmartContractOutputParameterSchema>}
     * @memberof SmartContractSearchFunctionSchema
     */
    'outputParameters'?: Array<SmartContractOutputParameterSchema>;
}
/**
 * 
 * @export
 * @interface SmartContractSearchRequestDetails
 */
export interface SmartContractSearchRequestDetails {
    /**
     * 
     * @type {Array<SmartContractSearchDestinationSchema>}
     * @memberof SmartContractSearchRequestDetails
     */
    'destination'?: Array<SmartContractSearchDestinationSchema>;
}
/**
 * 
 * @export
 * @interface SmartContractSearchSchema
 */
export interface SmartContractSearchSchema {
    /**
     * 
     * @type {SmartContractSearchFunctionSchema}
     * @memberof SmartContractSearchSchema
     */
    'function'?: SmartContractSearchFunctionSchema;
    /**
     * 
     * @type {string}
     * @memberof SmartContractSearchSchema
     */
    'smartContractId'?: string;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * The code of an object
     * @type {string}
     * @memberof Status
     */
    'code'?: string;
    /**
     * The description of an object
     * @type {string}
     * @memberof Status
     */
    'description'?: string;
    /**
     * The message of an object
     * @type {string}
     * @memberof Status
     */
    'message'?: string;
    /**
     * The value of an object
     * @type {string}
     * @memberof Status
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface StatusUpdateMonitoringRequestSchema
 */
export interface StatusUpdateMonitoringRequestSchema {
    /**
     * 
     * @type {StatusUpdateSchema}
     * @memberof StatusUpdateMonitoringRequestSchema
     */
    'statusUpdate'?: StatusUpdateSchema;
}
/**
 * 
 * @export
 * @interface StatusUpdateSchema
 */
export interface StatusUpdateSchema {
    /**
     * 
     * @type {string}
     * @memberof StatusUpdateSchema
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionDeletionResponse
 */
export interface SubscriptionDeletionResponse {
    /**
     * 
     * @type {SubscriptionDetails}
     * @memberof SubscriptionDeletionResponse
     */
    'subscriptionDetails'?: SubscriptionDetails;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDeletionResponse
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDeletionResponse
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionDeletionResponse
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionDetails
 */
export interface SubscriptionDetails {
    /**
     * 
     * @type {Array<string>}
     * @memberof SubscriptionDetails
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {Status}
     * @memberof SubscriptionDetails
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface SubscriptionDetailsSchema
 */
export interface SubscriptionDetailsSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof SubscriptionDetailsSchema
     */
    'ids'?: Array<string>;
    /**
     * 
     * @type {Status}
     * @memberof SubscriptionDetailsSchema
     */
    'status'?: Status;
}
/**
 * 
 * @export
 * @interface SubscriptionUpdateResponse
 */
export interface SubscriptionUpdateResponse {
    /**
     * 
     * @type {SubscriptionDetails}
     * @memberof SubscriptionUpdateResponse
     */
    'subscriptionDetails'?: SubscriptionDetails;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUpdateResponse
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUpdateResponse
     */
    'subscriptionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUpdateResponse
     */
    'type'?: string;
}
/**
 * Smallest unit of a work process related to interactions with distributed ledgers
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * The signatures of this transaction
     * @type {Array<string>}
     * @memberof Transaction
     */
    'signature'?: Array<string>;
    /**
     * 
     * @type {Array<Origin>}
     * @memberof Transaction
     */
    'origin'?: Array<Origin>;
    /**
     * 
     * @type {Fee}
     * @memberof Transaction
     */
    'fee'?: Fee;
    /**
     * 
     * @type {Array<Destination>}
     * @memberof Transaction
     */
    'destination'?: Array<Destination>;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'signed'?: string;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof Transaction
     */
    'totalPaymentAmount'?: Array<Payment>;
    /**
     * Any text-based element of the data payload
     * @type {string}
     * @memberof Transaction
     */
    'message'?: string;
    /**
     * The unique identifier of the transaction on this DLN
     * @type {string}
     * @memberof Transaction
     */
    'transactionId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Transaction
     */
    'encoded'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof Transaction
     */
    'extraFields'?: object;
    /**
     * 
     * @type {object}
     * @memberof Transaction
     */
    'nativeData'?: object;
}
/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'tokenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    'tokenName'?: string;
}
/**
 * 
 * @export
 * @interface TransferRequestDetailsSchema
 */
export interface TransferRequestDetailsSchema {
    /**
     * 
     * @type {string}
     * @memberof TransferRequestDetailsSchema
     */
    'overledgerSigningType'?: string;
    /**
     * 
     * @type {Array<OriginTransferSchema>}
     * @memberof TransferRequestDetailsSchema
     */
    'origin'?: Array<OriginTransferSchema>;
    /**
     * 
     * @type {Array<DestinationTransferSchema>}
     * @memberof TransferRequestDetailsSchema
     */
    'destination'?: Array<DestinationTransferSchema>;
    /**
     * 
     * @type {string}
     * @memberof TransferRequestDetailsSchema
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface TransferSchema
 */
export interface TransferSchema {
    /**
     * 
     * @type {string}
     * @memberof TransferSchema
     */
    'tokenId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransferSchema
     */
    'tokenName'?: string;
}
/**
 * 
 * @export
 * @interface UTXODestination
 */
export interface UTXODestination {
    /**
     * 
     * @type {UTXOSmartContract}
     * @memberof UTXODestination
     */
    'smartContract'?: UTXOSmartContract;
    /**
     * 
     * @type {Payment}
     * @memberof UTXODestination
     */
    'payment'?: Payment;
    /**
     * 
     * @type {string}
     * @memberof UTXODestination
     */
    'destinationId'?: string;
}
/**
 * 
 * @export
 * @interface UTXONativeData
 */
export interface UTXONativeData {
    /**
     * 
     * @type {Array<Vout>}
     * @memberof UTXONativeData
     */
    'vout'?: Array<Vout>;
}
/**
 * 
 * @export
 * @interface UTXOSmartContract
 */
export interface UTXOSmartContract {
    /**
     * 
     * @type {string}
     * @memberof UTXOSmartContract
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof UTXOSmartContract
     */
    'type'?: string;
    /**
     * 
     * @type {ExtraFields}
     * @memberof UTXOSmartContract
     */
    'extraFields'?: ExtraFields;
}
/**
 * 
 * @export
 * @interface UTXOTimestampSchema
 */
export interface UTXOTimestampSchema {
    /**
     * 
     * @type {string}
     * @memberof UTXOTimestampSchema
     */
    'nano'?: string;
    /**
     * 
     * @type {string}
     * @memberof UTXOTimestampSchema
     */
    'epochSecond'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAddressMonitoringSchema
 */
export interface UpdateAddressMonitoringSchema {
    /**
     * 
     * @type {ResourceMonitoringAddressDetails}
     * @memberof UpdateAddressMonitoringSchema
     */
    'addressMonitoringDetails'?: ResourceMonitoringAddressDetails;
    /**
     * 
     * @type {ResourceMonitoringDetails}
     * @memberof UpdateAddressMonitoringSchema
     */
    'resourceMonitoring'?: ResourceMonitoringDetails;
}
/**
 * 
 * @export
 * @interface UpdateSubscriptionRequestSchema
 */
export interface UpdateSubscriptionRequestSchema {
    /**
     * 
     * @type {StatusUpdateSchema}
     * @memberof UpdateSubscriptionRequestSchema
     */
    'statusUpdate'?: StatusUpdateSchema;
    /**
     * 
     * @type {string}
     * @memberof UpdateSubscriptionRequestSchema
     */
    'callbackUrl'?: string;
}
/**
 * 
 * @export
 * @interface Vout
 */
export interface Vout {
    /**
     * 
     * @type {ScriptPubKey}
     * @memberof Vout
     */
    'scriptPubKey'?: ScriptPubKey;
    /**
     * 
     * @type {number}
     * @memberof Vout
     */
    'value'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vout
     */
    'n'?: number;
}

/**
 * AddressSearchApi - axios parameter creator
 * @export
 */
export const AddressSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the address balance search on the requested DLT.
         * @summary Prepare and automatically execute a search for an address balance on a DLT.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchAddressBalanceRequest: async (authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchAddressBalanceRequest', 'authorization', authorization)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('autoExecuteSearchAddressBalanceRequest', 'addressId', addressId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchAddressBalanceRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/address/balance/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID, searches for the address and retrieves the balance on the requested DLT. This API is only applicable for account based DLTs
         * @summary Execute a search for an address balance on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestAddressBalance: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequestAddressBalance', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequestAddressBalance', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/address/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID, searches for the address and retrieves the sequence on the requested DLT. This API is only applicable for account based DLT\'s
         * @summary Execute a search for an address sequence on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestAddressSequence: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequestAddressSequence', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequestAddressSequence', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/address/sequence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform an address balance search on the requested DLT. Returns a request ID to execute
         * @summary Prepare Search for an Address Balance.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressBalanceSearchRequest: async (authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareAddressBalanceSearchRequest', 'authorization', authorization)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('prepareAddressBalanceSearchRequest', 'addressId', addressId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareAddressBalanceSearchRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/address/balance/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform an address sequence search on the requested DLT.Returns a request ID to execute
         * @summary Prepare Search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressSequenceSearchRequest: async (authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest', 'authorization', authorization)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest', 'addressId', addressId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/address/sequence/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a request ID and automatically executes the address sequence search on the requested DLT.
         * @summary Prepare and automatically execute a search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressSequenceSearchRequest1: async (authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest1', 'authorization', authorization)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest1', 'addressId', addressId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareAddressSequenceSearchRequest1', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/address/sequence/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressSearchApi - functional programming interface
 * @export
 */
export const AddressSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the address balance search on the requested DLT.
         * @summary Prepare and automatically execute a search for an address balance on a DLT.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchAddressBalanceRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecuteSearchAddressBalanceResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchAddressBalanceRequest(authorization, addressId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID, searches for the address and retrieves the balance on the requested DLT. This API is only applicable for account based DLTs
         * @summary Execute a search for an address balance on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequestAddressBalance(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequestAddressBalance(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID, searches for the address and retrieves the sequence on the requested DLT. This API is only applicable for account based DLT\'s
         * @summary Execute a search for an address sequence on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequestAddressSequence(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchSequenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequestAddressSequence(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform an address balance search on the requested DLT. Returns a request ID to execute
         * @summary Prepare Search for an Address Balance.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareAddressBalanceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareAddressBalanceSearchRequest(authorization, addressId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform an address sequence search on the requested DLT.Returns a request ID to execute
         * @summary Prepare Search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareAddressSequenceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareAddressSequenceSearchRequest(authorization, addressId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates a request ID and automatically executes the address sequence search on the requested DLT.
         * @summary Prepare and automatically execute a search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareAddressSequenceSearchRequest1(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecSearchAddressSequenceResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareAddressSequenceSearchRequest1(authorization, addressId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressSearchApi - factory interface
 * @export
 */
export const AddressSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the address balance search on the requested DLT.
         * @summary Prepare and automatically execute a search for an address balance on a DLT.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchAddressBalanceRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecuteSearchAddressBalanceResponseSchema> {
            return localVarFp.autoExecuteSearchAddressBalanceRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID, searches for the address and retrieves the balance on the requested DLT. This API is only applicable for account based DLTs
         * @summary Execute a search for an address balance on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestAddressBalance(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchBalanceResponse> {
            return localVarFp.executePreparedSearchRequestAddressBalance(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID, searches for the address and retrieves the sequence on the requested DLT. This API is only applicable for account based DLT\'s
         * @summary Execute a search for an address sequence on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestAddressSequence(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchSequenceResponse> {
            return localVarFp.executePreparedSearchRequestAddressSequence(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform an address balance search on the requested DLT. Returns a request ID to execute
         * @summary Prepare Search for an Address Balance.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressBalanceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareAddressBalanceSearchRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform an address sequence search on the requested DLT.Returns a request ID to execute
         * @summary Prepare Search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressSequenceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareAddressSequenceSearchRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a request ID and automatically executes the address sequence search on the requested DLT.
         * @summary Prepare and automatically execute a search for an Address Sequence.
         * @param {string} authorization 
         * @param {string} addressId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareAddressSequenceSearchRequest1(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecSearchAddressSequenceResponseSchema> {
            return localVarFp.prepareAddressSequenceSearchRequest1(authorization, addressId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressSearchApi - object-oriented interface
 * @export
 * @class AddressSearchApi
 * @extends {BaseAPI}
 */
export class AddressSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the address balance search on the requested DLT.
     * @summary Prepare and automatically execute a search for an address balance on a DLT.
     * @param {string} authorization 
     * @param {string} addressId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public autoExecuteSearchAddressBalanceRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).autoExecuteSearchAddressBalanceRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID, searches for the address and retrieves the balance on the requested DLT. This API is only applicable for account based DLTs
     * @summary Execute a search for an address balance on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public executePreparedSearchRequestAddressBalance(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).executePreparedSearchRequestAddressBalance(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID, searches for the address and retrieves the sequence on the requested DLT. This API is only applicable for account based DLT\'s
     * @summary Execute a search for an address sequence on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public executePreparedSearchRequestAddressSequence(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).executePreparedSearchRequestAddressSequence(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform an address balance search on the requested DLT. Returns a request ID to execute
     * @summary Prepare Search for an Address Balance.
     * @param {string} authorization 
     * @param {string} addressId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public prepareAddressBalanceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).prepareAddressBalanceSearchRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform an address sequence search on the requested DLT.Returns a request ID to execute
     * @summary Prepare Search for an Address Sequence.
     * @param {string} authorization 
     * @param {string} addressId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public prepareAddressSequenceSearchRequest(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).prepareAddressSequenceSearchRequest(authorization, addressId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a request ID and automatically executes the address sequence search on the requested DLT.
     * @summary Prepare and automatically execute a search for an Address Sequence.
     * @param {string} authorization 
     * @param {string} addressId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressSearchApi
     */
    public prepareAddressSequenceSearchRequest1(authorization: string, addressId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return AddressSearchApiFp(this.configuration).prepareAddressSequenceSearchRequest1(authorization, addressId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockSearchApi - axios parameter creator
 * @export
 */
export const BlockSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the block search on the requested DLT.
         * @summary Prepare and automatically execute a search for a block on a DLT.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchBlockRequest: async (authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchBlockRequest', 'authorization', authorization)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('autoExecuteSearchBlockRequest', 'blockId', blockId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchBlockRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/block/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID and searches for the block on the requested DLT based on the parameters specified in the prepare request
         * @summary Execute a search for a block on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestBlock: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequestBlock', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequestBlock', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a request ID for executing a block search on the requested DLT. Block searches can be prepared based on the Block ID, Block Number or for the latest block at the time
         * @summary Prepare Search Block by Block Id.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchBlockByBlockId: async (authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSearchBlockByBlockId', 'authorization', authorization)
            // verify required parameter 'blockId' is not null or undefined
            assertParamExists('prepareSearchBlockByBlockId', 'blockId', blockId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareSearchBlockByBlockId', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/block/{blockId}`
                .replace(`{${"blockId"}}`, encodeURIComponent(String(blockId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockSearchApi - functional programming interface
 * @export
 */
export const BlockSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the block search on the requested DLT.
         * @summary Prepare and automatically execute a search for a block on a DLT.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchBlockRequest(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecuteSearchBlockResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchBlockRequest(authorization, blockId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID and searches for the block on the requested DLT based on the parameters specified in the prepare request
         * @summary Execute a search for a block on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequestBlock(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchBlockResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequestBlock(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a request ID for executing a block search on the requested DLT. Block searches can be prepared based on the Block ID, Block Number or for the latest block at the time
         * @summary Prepare Search Block by Block Id.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSearchBlockByBlockId(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSearchBlockByBlockId(authorization, blockId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlockSearchApi - factory interface
 * @export
 */
export const BlockSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the block search on the requested DLT.
         * @summary Prepare and automatically execute a search for a block on a DLT.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchBlockRequest(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecuteSearchBlockResponseSchema> {
            return localVarFp.autoExecuteSearchBlockRequest(authorization, blockId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID and searches for the block on the requested DLT based on the parameters specified in the prepare request
         * @summary Execute a search for a block on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestBlock(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchBlockResponse> {
            return localVarFp.executePreparedSearchRequestBlock(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a request ID for executing a block search on the requested DLT. Block searches can be prepared based on the Block ID, Block Number or for the latest block at the time
         * @summary Prepare Search Block by Block Id.
         * @param {string} authorization 
         * @param {string} blockId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchBlockByBlockId(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareSearchBlockByBlockId(authorization, blockId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockSearchApi - object-oriented interface
 * @export
 * @class BlockSearchApi
 * @extends {BaseAPI}
 */
export class BlockSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the block search on the requested DLT.
     * @summary Prepare and automatically execute a search for a block on a DLT.
     * @param {string} authorization 
     * @param {string} blockId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockSearchApi
     */
    public autoExecuteSearchBlockRequest(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return BlockSearchApiFp(this.configuration).autoExecuteSearchBlockRequest(authorization, blockId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID and searches for the block on the requested DLT based on the parameters specified in the prepare request
     * @summary Execute a search for a block on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockSearchApi
     */
    public executePreparedSearchRequestBlock(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return BlockSearchApiFp(this.configuration).executePreparedSearchRequestBlock(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a request ID for executing a block search on the requested DLT. Block searches can be prepared based on the Block ID, Block Number or for the latest block at the time
     * @summary Prepare Search Block by Block Id.
     * @param {string} authorization 
     * @param {string} blockId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockSearchApi
     */
    public prepareSearchBlockByBlockId(authorization: string, blockId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return BlockSearchApiFp(this.configuration).prepareSearchBlockByBlockId(authorization, blockId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateAQRC20CreditTransactionApi - axios parameter creator
 * @export
 */
export const CreateAQRC20CreditTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is \"Create Credit\" which will allow you to make a payment to another specified account.
         * @summary Prepare a QRC20 token credit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareCreditRequest: async (authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareCreditRequest', 'authorization', authorization)
            // verify required parameter 'prepareCreditTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareCreditRequest', 'prepareCreditTransactionRequestSchema', prepareCreditTransactionRequestSchema)
            const localVarPath = `/v2/preparation/credit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareCreditTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateAQRC20CreditTransactionApi - functional programming interface
 * @export
 */
export const CreateAQRC20CreditTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateAQRC20CreditTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is \"Create Credit\" which will allow you to make a payment to another specified account.
         * @summary Prepare a QRC20 token credit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareCreditRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareCreditRequest(authorization, prepareCreditTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateAQRC20CreditTransactionApi - factory interface
 * @export
 */
export const CreateAQRC20CreditTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateAQRC20CreditTransactionApiFp(configuration)
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is \"Create Credit\" which will allow you to make a payment to another specified account.
         * @summary Prepare a QRC20 token credit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareCreditRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareCreditRequest(authorization, prepareCreditTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateAQRC20CreditTransactionApi - object-oriented interface
 * @export
 * @class CreateAQRC20CreditTransactionApi
 * @extends {BaseAPI}
 */
export class CreateAQRC20CreditTransactionApi extends BaseAPI {
    /**
     * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction type is \"Create Credit\" which will allow you to make a payment to another specified account.
     * @summary Prepare a QRC20 token credit transaction for signing
     * @param {string} authorization 
     * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAQRC20CreditTransactionApi
     */
    public prepareCreditRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateAQRC20CreditTransactionApiFp(this.configuration).prepareCreditRequest(authorization, prepareCreditTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateAQRC20DebitTransactionApi - axios parameter creator
 * @export
 */
export const CreateAQRC20DebitTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are \"Approve Debit\" and \"Create Debit\". The \'Approve Debit\' transaction type will allow you to approve someone to make a pull payment from your account and the \"Create Debit\" transaction type will create the payment to pull the approved amount from an account.
         * @summary Prepare a QRC20 token debit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDebitRequest: async (authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareDebitRequest', 'authorization', authorization)
            // verify required parameter 'prepareCreditTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareDebitRequest', 'prepareCreditTransactionRequestSchema', prepareCreditTransactionRequestSchema)
            const localVarPath = `/v2/preparation/debit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareCreditTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateAQRC20DebitTransactionApi - functional programming interface
 * @export
 */
export const CreateAQRC20DebitTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateAQRC20DebitTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are \"Approve Debit\" and \"Create Debit\". The \'Approve Debit\' transaction type will allow you to approve someone to make a pull payment from your account and the \"Create Debit\" transaction type will create the payment to pull the approved amount from an account.
         * @summary Prepare a QRC20 token debit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareDebitRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareDebitRequest(authorization, prepareCreditTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateAQRC20DebitTransactionApi - factory interface
 * @export
 */
export const CreateAQRC20DebitTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateAQRC20DebitTransactionApiFp(configuration)
    return {
        /**
         * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are \"Approve Debit\" and \"Create Debit\". The \'Approve Debit\' transaction type will allow you to approve someone to make a pull payment from your account and the \"Create Debit\" transaction type will create the payment to pull the approved amount from an account.
         * @summary Prepare a QRC20 token debit transaction for signing
         * @param {string} authorization 
         * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareDebitRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareDebitRequest(authorization, prepareCreditTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateAQRC20DebitTransactionApi - object-oriented interface
 * @export
 * @class CreateAQRC20DebitTransactionApi
 * @extends {BaseAPI}
 */
export class CreateAQRC20DebitTransactionApi extends BaseAPI {
    /**
     * Transforms a transaction request ready to be signed and returns a request ID for executing. The supported transaction types are \"Approve Debit\" and \"Create Debit\". The \'Approve Debit\' transaction type will allow you to approve someone to make a pull payment from your account and the \"Create Debit\" transaction type will create the payment to pull the approved amount from an account.
     * @summary Prepare a QRC20 token debit transaction for signing
     * @param {string} authorization 
     * @param {PrepareCreditTransactionRequestSchema} prepareCreditTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateAQRC20DebitTransactionApi
     */
    public prepareDebitRequest(authorization: string, prepareCreditTransactionRequestSchema: PrepareCreditTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateAQRC20DebitTransactionApiFp(this.configuration).prepareDebitRequest(authorization, prepareCreditTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateSubscriptionApi - axios parameter creator
 * @export
 */
export const CreateSubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a subscription to receive status updates for a transaction created in Overledger, or to receive updates each time a transaction happens on the requested DLT for a resource (e.g. address) being monitored, to the requested callback URL.  Subscriptions are created using an Overledger Transaction ID or Resource Monitoring ID
         * @summary Create a subscription for a transaction or monitored resource 
         * @param {string} authorization 
         * @param {CreateSubscriptionRequestSchema} createSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscription: async (authorization: string, createSubscriptionRequestSchema: CreateSubscriptionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('subscription', 'authorization', authorization)
            // verify required parameter 'createSubscriptionRequestSchema' is not null or undefined
            assertParamExists('subscription', 'createSubscriptionRequestSchema', createSubscriptionRequestSchema)
            const localVarPath = `/v2/webhook/subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSubscriptionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateSubscriptionApi - functional programming interface
 * @export
 */
export const CreateSubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateSubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a subscription to receive status updates for a transaction created in Overledger, or to receive updates each time a transaction happens on the requested DLT for a resource (e.g. address) being monitored, to the requested callback URL.  Subscriptions are created using an Overledger Transaction ID or Resource Monitoring ID
         * @summary Create a subscription for a transaction or monitored resource 
         * @param {string} authorization 
         * @param {CreateSubscriptionRequestSchema} createSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscription(authorization: string, createSubscriptionRequestSchema: CreateSubscriptionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CreateSubscriptionResponseSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscription(authorization, createSubscriptionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateSubscriptionApi - factory interface
 * @export
 */
export const CreateSubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateSubscriptionApiFp(configuration)
    return {
        /**
         * Creates a subscription to receive status updates for a transaction created in Overledger, or to receive updates each time a transaction happens on the requested DLT for a resource (e.g. address) being monitored, to the requested callback URL.  Subscriptions are created using an Overledger Transaction ID or Resource Monitoring ID
         * @summary Create a subscription for a transaction or monitored resource 
         * @param {string} authorization 
         * @param {CreateSubscriptionRequestSchema} createSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscription(authorization: string, createSubscriptionRequestSchema: CreateSubscriptionRequestSchema, options?: any): AxiosPromise<Array<CreateSubscriptionResponseSchema>> {
            return localVarFp.subscription(authorization, createSubscriptionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateSubscriptionApi - object-oriented interface
 * @export
 * @class CreateSubscriptionApi
 * @extends {BaseAPI}
 */
export class CreateSubscriptionApi extends BaseAPI {
    /**
     * Creates a subscription to receive status updates for a transaction created in Overledger, or to receive updates each time a transaction happens on the requested DLT for a resource (e.g. address) being monitored, to the requested callback URL.  Subscriptions are created using an Overledger Transaction ID or Resource Monitoring ID
     * @summary Create a subscription for a transaction or monitored resource 
     * @param {string} authorization 
     * @param {CreateSubscriptionRequestSchema} createSubscriptionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateSubscriptionApi
     */
    public subscription(authorization: string, createSubscriptionRequestSchema: CreateSubscriptionRequestSchema, options?: AxiosRequestConfig) {
        return CreateSubscriptionApiFp(this.configuration).subscription(authorization, createSubscriptionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CreateTransactionApi - axios parameter creator
 * @export
 */
export const CreateTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a request ID and submits a signed native transaction to the requested DLT
         * @summary Execute a native transaction on the DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestNativeTransaction: async (authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedRequestNativeTransaction', 'authorization', authorization)
            // verify required parameter 'executeTransactionRequest' is not null or undefined
            assertParamExists('executePreparedRequestNativeTransaction', 'executeTransactionRequest', executeTransactionRequest)
            const localVarPath = `/v2/execution/nativetransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on the DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction: async (authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'authorization', authorization)
            // verify required parameter 'executeTransactionRequest' is not null or undefined
            assertParamExists('executePreparedRequestTransaction', 'executeTransactionRequest', executeTransactionRequest)
            const localVarPath = `/v2/execution/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows advanced developers to submit their own DLT native transactions via Overledger. Returns a request ID for executing a DLT native transaction on the requested DLT
         * @summary Prepare a DLT native transaction
         * @param {string} authorization 
         * @param {PrepareNativeTransactionRequestSchema} prepareNativeTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareNativeTransaction: async (authorization: string, prepareNativeTransactionRequestSchema: PrepareNativeTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareNativeTransaction', 'authorization', authorization)
            // verify required parameter 'prepareNativeTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareNativeTransaction', 'prepareNativeTransactionRequestSchema', prepareNativeTransactionRequestSchema)
            const localVarPath = `/v2/preparation/nativetransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareNativeTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transforms a transaction request into a payload ready for signing for the requested DLT and returns a request ID for executing. Supported transaction types in this release are \"Payment\" (to send payments) and \"Smart Contract Invoke\" (to invoke arbitrary smart contract functions).   Warning: Bitcoin transaction fees will be deducted from the last destination provided in the transaction payment request. If the last destination payment value is not enough to cover the fees, your Bitcoin payment transaction will fail.
         * @summary Prepare a DLT transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareTransactionRequest: async (authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareTransactionRequest', 'authorization', authorization)
            // verify required parameter 'preparePaymentTransactionRequestSchema' is not null or undefined
            assertParamExists('prepareTransactionRequest', 'preparePaymentTransactionRequestSchema', preparePaymentTransactionRequestSchema)
            const localVarPath = `/v2/preparation/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preparePaymentTransactionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreateTransactionApi - functional programming interface
 * @export
 */
export const CreateTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CreateTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a request ID and submits a signed native transaction to the requested DLT
         * @summary Execute a native transaction on the DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedRequestNativeTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedRequestNativeTransaction(authorization, executeTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on the DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedRequestTransaction(authorization, executeTransactionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Allows advanced developers to submit their own DLT native transactions via Overledger. Returns a request ID for executing a DLT native transaction on the requested DLT
         * @summary Prepare a DLT native transaction
         * @param {string} authorization 
         * @param {PrepareNativeTransactionRequestSchema} prepareNativeTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareNativeTransaction(authorization: string, prepareNativeTransactionRequestSchema: PrepareNativeTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareNativeTransaction(authorization, prepareNativeTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Transforms a transaction request into a payload ready for signing for the requested DLT and returns a request ID for executing. Supported transaction types in this release are \"Payment\" (to send payments) and \"Smart Contract Invoke\" (to invoke arbitrary smart contract functions).   Warning: Bitcoin transaction fees will be deducted from the last destination provided in the transaction payment request. If the last destination payment value is not enough to cover the fees, your Bitcoin payment transaction will fail.
         * @summary Prepare a DLT transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareTransactionRequest(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareTransactionRequest(authorization, preparePaymentTransactionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CreateTransactionApi - factory interface
 * @export
 */
export const CreateTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreateTransactionApiFp(configuration)
    return {
        /**
         * Takes a request ID and submits a signed native transaction to the requested DLT
         * @summary Execute a native transaction on the DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestNativeTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: any): AxiosPromise<ExecuteTransactionResponse> {
            return localVarFp.executePreparedRequestNativeTransaction(authorization, executeTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID and submits a signed transaction to the requested DLT.
         * @summary Execute a transaction on the DLT
         * @param {string} authorization 
         * @param {ExecuteTransactionRequest} executeTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: any): AxiosPromise<ExecuteTransactionResponse> {
            return localVarFp.executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows advanced developers to submit their own DLT native transactions via Overledger. Returns a request ID for executing a DLT native transaction on the requested DLT
         * @summary Prepare a DLT native transaction
         * @param {string} authorization 
         * @param {PrepareNativeTransactionRequestSchema} prepareNativeTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareNativeTransaction(authorization: string, prepareNativeTransactionRequestSchema: PrepareNativeTransactionRequestSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareNativeTransaction(authorization, prepareNativeTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Transforms a transaction request into a payload ready for signing for the requested DLT and returns a request ID for executing. Supported transaction types in this release are \"Payment\" (to send payments) and \"Smart Contract Invoke\" (to invoke arbitrary smart contract functions).   Warning: Bitcoin transaction fees will be deducted from the last destination provided in the transaction payment request. If the last destination payment value is not enough to cover the fees, your Bitcoin payment transaction will fail.
         * @summary Prepare a DLT transaction for signing
         * @param {string} authorization 
         * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareTransactionRequest(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: any): AxiosPromise<PrepareTransactionResponse> {
            return localVarFp.prepareTransactionRequest(authorization, preparePaymentTransactionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreateTransactionApi - object-oriented interface
 * @export
 * @class CreateTransactionApi
 * @extends {BaseAPI}
 */
export class CreateTransactionApi extends BaseAPI {
    /**
     * Takes a request ID and submits a signed native transaction to the requested DLT
     * @summary Execute a native transaction on the DLT
     * @param {string} authorization 
     * @param {ExecuteTransactionRequest} executeTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateTransactionApi
     */
    public executePreparedRequestNativeTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig) {
        return CreateTransactionApiFp(this.configuration).executePreparedRequestNativeTransaction(authorization, executeTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID and submits a signed transaction to the requested DLT.
     * @summary Execute a transaction on the DLT
     * @param {string} authorization 
     * @param {ExecuteTransactionRequest} executeTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateTransactionApi
     */
    public executePreparedRequestTransaction(authorization: string, executeTransactionRequest: ExecuteTransactionRequest, options?: AxiosRequestConfig) {
        return CreateTransactionApiFp(this.configuration).executePreparedRequestTransaction(authorization, executeTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows advanced developers to submit their own DLT native transactions via Overledger. Returns a request ID for executing a DLT native transaction on the requested DLT
     * @summary Prepare a DLT native transaction
     * @param {string} authorization 
     * @param {PrepareNativeTransactionRequestSchema} prepareNativeTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateTransactionApi
     */
    public prepareNativeTransaction(authorization: string, prepareNativeTransactionRequestSchema: PrepareNativeTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateTransactionApiFp(this.configuration).prepareNativeTransaction(authorization, prepareNativeTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transforms a transaction request into a payload ready for signing for the requested DLT and returns a request ID for executing. Supported transaction types in this release are \"Payment\" (to send payments) and \"Smart Contract Invoke\" (to invoke arbitrary smart contract functions).   Warning: Bitcoin transaction fees will be deducted from the last destination provided in the transaction payment request. If the last destination payment value is not enough to cover the fees, your Bitcoin payment transaction will fail.
     * @summary Prepare a DLT transaction for signing
     * @param {string} authorization 
     * @param {PreparePaymentTransactionRequestSchema} preparePaymentTransactionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreateTransactionApi
     */
    public prepareTransactionRequest(authorization: string, preparePaymentTransactionRequestSchema: PreparePaymentTransactionRequestSchema, options?: AxiosRequestConfig) {
        return CreateTransactionApiFp(this.configuration).prepareTransactionRequest(authorization, preparePaymentTransactionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MDappTransactionQueryApi - axios parameter creator
 * @export
 */
export const MDappTransactionQueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information for a specific transaction based on a given Overledger Transaction ID. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve information about a specific transaction created by your application in Overledger
         * @param {string} authorization 
         * @param {string} overledgertransactionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvlTransactionByTxId: async (authorization: string, overledgertransactionid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getOvlTransactionByTxId', 'authorization', authorization)
            // verify required parameter 'overledgertransactionid' is not null or undefined
            assertParamExists('getOvlTransactionByTxId', 'overledgertransactionid', overledgertransactionid)
            const localVarPath = `/v2/mdapptransaction/{overledgertransactionid}`
                .replace(`{${"overledgertransactionid"}}`, encodeURIComponent(String(overledgertransactionid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of transactions and the corresponding Overledger Transaction ID your application has created in Overledger. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve a list of transactions created by your application in Overledger
         * @param {string} authorization 
         * @param {number} [offset] 
         * @param {number} [length] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvlTransactionsByClientId: async (authorization: string, offset?: number, length?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getOvlTransactionsByClientId', 'authorization', authorization)
            const localVarPath = `/v2/mdapptransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MDappTransactionQueryApi - functional programming interface
 * @export
 */
export const MDappTransactionQueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MDappTransactionQueryApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns information for a specific transaction based on a given Overledger Transaction ID. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve information about a specific transaction created by your application in Overledger
         * @param {string} authorization 
         * @param {string} overledgertransactionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOvlTransactionByTxId(authorization: string, overledgertransactionid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OverledgerTransactionResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOvlTransactionByTxId(authorization, overledgertransactionid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of transactions and the corresponding Overledger Transaction ID your application has created in Overledger. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve a list of transactions created by your application in Overledger
         * @param {string} authorization 
         * @param {number} [offset] 
         * @param {number} [length] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOvlTransactionsByClientId(authorization: string, offset?: number, length?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OverledgerTransactionResponseSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOvlTransactionsByClientId(authorization, offset, length, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MDappTransactionQueryApi - factory interface
 * @export
 */
export const MDappTransactionQueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MDappTransactionQueryApiFp(configuration)
    return {
        /**
         * Returns information for a specific transaction based on a given Overledger Transaction ID. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve information about a specific transaction created by your application in Overledger
         * @param {string} authorization 
         * @param {string} overledgertransactionid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvlTransactionByTxId(authorization: string, overledgertransactionid: string, options?: any): AxiosPromise<OverledgerTransactionResponseSchema> {
            return localVarFp.getOvlTransactionByTxId(authorization, overledgertransactionid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of transactions and the corresponding Overledger Transaction ID your application has created in Overledger. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
         * @summary Retrieve a list of transactions created by your application in Overledger
         * @param {string} authorization 
         * @param {number} [offset] 
         * @param {number} [length] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOvlTransactionsByClientId(authorization: string, offset?: number, length?: number, options?: any): AxiosPromise<Array<OverledgerTransactionResponseSchema>> {
            return localVarFp.getOvlTransactionsByClientId(authorization, offset, length, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MDappTransactionQueryApi - object-oriented interface
 * @export
 * @class MDappTransactionQueryApi
 * @extends {BaseAPI}
 */
export class MDappTransactionQueryApi extends BaseAPI {
    /**
     * Returns information for a specific transaction based on a given Overledger Transaction ID. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
     * @summary Retrieve information about a specific transaction created by your application in Overledger
     * @param {string} authorization 
     * @param {string} overledgertransactionid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDappTransactionQueryApi
     */
    public getOvlTransactionByTxId(authorization: string, overledgertransactionid: string, options?: AxiosRequestConfig) {
        return MDappTransactionQueryApiFp(this.configuration).getOvlTransactionByTxId(authorization, overledgertransactionid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of transactions and the corresponding Overledger Transaction ID your application has created in Overledger. Does not require a Prepare step, as this data is held within Overledger, rather than on the DLT
     * @summary Retrieve a list of transactions created by your application in Overledger
     * @param {string} authorization 
     * @param {number} [offset] 
     * @param {number} [length] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MDappTransactionQueryApi
     */
    public getOvlTransactionsByClientId(authorization: string, offset?: number, length?: number, options?: AxiosRequestConfig) {
        return MDappTransactionQueryApiFp(this.configuration).getOvlTransactionsByClientId(authorization, offset, length, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManageMonitoredResourcesApi - axios parameter creator
 * @export
 */
export const ManageMonitoredResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for a smart contract based on the given Resource Monitoring ID
         * @summary Stop monitoring a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventMonitoring: async (authorization: string, resourceMonitoringId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteEventMonitoring', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('deleteEventMonitoring', 'resourceMonitoringId', resourceMonitoringId)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevent/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for an address based on the given Resource Monitoring ID
         * @summary Stop monitoring an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceMonitoringAddress: async (authorization: string, resourceMonitoringId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteResourceMonitoringAddress', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('deleteResourceMonitoringAddress', 'resourceMonitoringId', resourceMonitoringId)
            const localVarPath = `/v2/resourcemonitoring/address/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of addresses being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of addresses being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfAddresses: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getListOfAddresses', 'authorization', authorization)
            const localVarPath = `/v2/resourcemonitoring/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all of the resources being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of all resources being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfResources: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getListOfResources', 'authorization', authorization)
            const localVarPath = `/v2/resourcemonitoring`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of smart contracts being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of smart contracts being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfSmartContractEvents: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getListOfSmartContractEvents', 'authorization', authorization)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the update information recorded in Overledger for an address being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoredAddress: async (authorization: string, resourceMonitoringId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getMonitoredAddress', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('getMonitoredAddress', 'resourceMonitoringId', resourceMonitoringId)
            const localVarPath = `/v2/resourcemonitoring/address/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the update information recorded in Overledger for asmart contract being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoredSmartContractEventDetails: async (authorization: string, resourceMonitoringId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('getMonitoredSmartContractEventDetails', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('getMonitoredSmartContractEventDetails', 'resourceMonitoringId', resourceMonitoringId)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevent/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to be inactive will pause Overledger recording updates for the requested smart contract
         * @summary Update the monitoring status of a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventMonitoring: async (authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateEventMonitoring', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('updateEventMonitoring', 'resourceMonitoringId', resourceMonitoringId)
            // verify required parameter 'statusUpdateMonitoringRequestSchema' is not null or undefined
            assertParamExists('updateEventMonitoring', 'statusUpdateMonitoringRequestSchema', statusUpdateMonitoringRequestSchema)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevent/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statusUpdateMonitoringRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to beinactive will pause Overledger recording updates for the requested address
         * @summary Update the monitoring status of an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceMonitoringAddress: async (authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateResourceMonitoringAddress', 'authorization', authorization)
            // verify required parameter 'resourceMonitoringId' is not null or undefined
            assertParamExists('updateResourceMonitoringAddress', 'resourceMonitoringId', resourceMonitoringId)
            // verify required parameter 'statusUpdateMonitoringRequestSchema' is not null or undefined
            assertParamExists('updateResourceMonitoringAddress', 'statusUpdateMonitoringRequestSchema', statusUpdateMonitoringRequestSchema)
            const localVarPath = `/v2/resourcemonitoring/address/{resourceMonitoringId}`
                .replace(`{${"resourceMonitoringId"}}`, encodeURIComponent(String(resourceMonitoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statusUpdateMonitoringRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageMonitoredResourcesApi - functional programming interface
 * @export
 */
export const ManageMonitoredResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageMonitoredResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for a smart contract based on the given Resource Monitoring ID
         * @summary Stop monitoring a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventMonitoring(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContractMonitoringSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventMonitoring(authorization, resourceMonitoringId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for an address based on the given Resource Monitoring ID
         * @summary Stop monitoring an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteResourceMonitoringAddressSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteResourceMonitoringAddress(authorization, resourceMonitoringId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of addresses being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of addresses being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfAddresses(authorization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceMonitoringAddressSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfAddresses(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all of the resources being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of all resources being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfResources(authorization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SmartContractMonitoringSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfResources(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of smart contracts being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of smart contracts being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListOfSmartContractEvents(authorization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SmartContractMonitoringSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListOfSmartContractEvents(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the update information recorded in Overledger for an address being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonitoredAddress(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressMonitoringDetailsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonitoredAddress(authorization, resourceMonitoringId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the update information recorded in Overledger for asmart contract being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMonitoredSmartContractEventDetails(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContractMonitoringDetailsSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMonitoredSmartContractEventDetails(authorization, resourceMonitoringId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to be inactive will pause Overledger recording updates for the requested smart contract
         * @summary Update the monitoring status of a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventMonitoring(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContractMonitoringSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventMonitoring(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to beinactive will pause Overledger recording updates for the requested address
         * @summary Update the monitoring status of an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAddressMonitoringSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateResourceMonitoringAddress(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManageMonitoredResourcesApi - factory interface
 * @export
 */
export const ManageMonitoredResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageMonitoredResourcesApiFp(configuration)
    return {
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for a smart contract based on the given Resource Monitoring ID
         * @summary Stop monitoring a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventMonitoring(authorization: string, resourceMonitoringId: string, options?: any): AxiosPromise<SmartContractMonitoringSchema> {
            return localVarFp.deleteEventMonitoring(authorization, resourceMonitoringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the tracking record in Overledger to stop Overledger from recording updates for an address based on the given Resource Monitoring ID
         * @summary Stop monitoring an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, options?: any): AxiosPromise<DeleteResourceMonitoringAddressSchema> {
            return localVarFp.deleteResourceMonitoringAddress(authorization, resourceMonitoringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of addresses being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of addresses being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfAddresses(authorization: string, options?: any): AxiosPromise<Array<ResourceMonitoringAddressSchema>> {
            return localVarFp.getListOfAddresses(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all of the resources being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of all resources being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfResources(authorization: string, options?: any): AxiosPromise<Array<SmartContractMonitoringSchema>> {
            return localVarFp.getListOfResources(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of smart contracts being monitored for your application and the corresponding Resource Monitoring ID
         * @summary Retrieve a list of smart contracts being monitored
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfSmartContractEvents(authorization: string, options?: any): AxiosPromise<Array<SmartContractMonitoringSchema>> {
            return localVarFp.getListOfSmartContractEvents(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the update information recorded in Overledger for an address being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoredAddress(authorization: string, resourceMonitoringId: string, options?: any): AxiosPromise<AddressMonitoringDetailsSchema> {
            return localVarFp.getMonitoredAddress(authorization, resourceMonitoringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the update information recorded in Overledger for asmart contract being monitored by your application for a given Resource Monitoring ID
         * @summary Retrieve recorded updates for a specific monitored smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMonitoredSmartContractEventDetails(authorization: string, resourceMonitoringId: string, options?: any): AxiosPromise<SmartContractMonitoringDetailsSchema> {
            return localVarFp.getMonitoredSmartContractEventDetails(authorization, resourceMonitoringId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to be inactive will pause Overledger recording updates for the requested smart contract
         * @summary Update the monitoring status of a smart contract
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventMonitoring(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: any): AxiosPromise<SmartContractMonitoringSchema> {
            return localVarFp.updateEventMonitoring(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to beinactive will pause Overledger recording updates for the requested address
         * @summary Update the monitoring status of an address
         * @param {string} authorization 
         * @param {string} resourceMonitoringId 
         * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: any): AxiosPromise<UpdateAddressMonitoringSchema> {
            return localVarFp.updateResourceMonitoringAddress(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageMonitoredResourcesApi - object-oriented interface
 * @export
 * @class ManageMonitoredResourcesApi
 * @extends {BaseAPI}
 */
export class ManageMonitoredResourcesApi extends BaseAPI {
    /**
     * Deletes the tracking record in Overledger to stop Overledger from recording updates for a smart contract based on the given Resource Monitoring ID
     * @summary Stop monitoring a smart contract
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public deleteEventMonitoring(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).deleteEventMonitoring(authorization, resourceMonitoringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the tracking record in Overledger to stop Overledger from recording updates for an address based on the given Resource Monitoring ID
     * @summary Stop monitoring an address
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public deleteResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).deleteResourceMonitoringAddress(authorization, resourceMonitoringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of addresses being monitored for your application and the corresponding Resource Monitoring ID
     * @summary Retrieve a list of addresses being monitored
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getListOfAddresses(authorization: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getListOfAddresses(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all of the resources being monitored for your application and the corresponding Resource Monitoring ID
     * @summary Retrieve a list of all resources being monitored
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getListOfResources(authorization: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getListOfResources(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of smart contracts being monitored for your application and the corresponding Resource Monitoring ID
     * @summary Retrieve a list of smart contracts being monitored
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getListOfSmartContractEvents(authorization: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getListOfSmartContractEvents(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the update information recorded in Overledger for an address being monitored by your application for a given Resource Monitoring ID
     * @summary Retrieve recorded updates for a specific monitored address
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getMonitoredAddress(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getMonitoredAddress(authorization, resourceMonitoringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the update information recorded in Overledger for asmart contract being monitored by your application for a given Resource Monitoring ID
     * @summary Retrieve recorded updates for a specific monitored smart contract
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public getMonitoredSmartContractEventDetails(authorization: string, resourceMonitoringId: string, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).getMonitoredSmartContractEventDetails(authorization, resourceMonitoringId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to be inactive will pause Overledger recording updates for the requested smart contract
     * @summary Update the monitoring status of a smart contract
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public updateEventMonitoring(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).updateEventMonitoring(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the resource monitoring status to be either active or inactive for the given Resource Monitoring ID. Updating the status to beinactive will pause Overledger recording updates for the requested address
     * @summary Update the monitoring status of an address
     * @param {string} authorization 
     * @param {string} resourceMonitoringId 
     * @param {StatusUpdateMonitoringRequestSchema} statusUpdateMonitoringRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageMonitoredResourcesApi
     */
    public updateResourceMonitoringAddress(authorization: string, resourceMonitoringId: string, statusUpdateMonitoringRequestSchema: StatusUpdateMonitoringRequestSchema, options?: AxiosRequestConfig) {
        return ManageMonitoredResourcesApiFp(this.configuration).updateResourceMonitoringAddress(authorization, resourceMonitoringId, statusUpdateMonitoringRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManageSubscriptionApi - axios parameter creator
 * @export
 */
export const ManageSubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a subscription created by your application based onthe given Subscription ID. Deleting a subscription will stop updates being sent to the requested callback URL
         * @summary Remove a subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription: async (authorization: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('deleteSubscription', 'authorization', authorization)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deleteSubscription', 'subscriptionId', subscriptionId)
            const localVarPath = `/v2/webhook/subscription/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of active or paused subscriptions and the corresponding Subscription IDs that were created by your application
         * @summary Retrieve a list of subscriptions created by your application
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions: async (authorization: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('listSubscriptions', 'authorization', authorization)
            const localVarPath = `/v2/webhook/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the subscription callback URL and/or the subscription status to be either active or track only for the given Subscription ID. Updating the status to be track only will pause updates being sent to the requested callback URL
         * @summary Update a specific subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {UpdateSubscriptionRequestSchema} updateSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription: async (authorization: string, subscriptionId: string, updateSubscriptionRequestSchema: UpdateSubscriptionRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updateSubscription', 'authorization', authorization)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscription', 'subscriptionId', subscriptionId)
            // verify required parameter 'updateSubscriptionRequestSchema' is not null or undefined
            assertParamExists('updateSubscription', 'updateSubscriptionRequestSchema', updateSubscriptionRequestSchema)
            const localVarPath = `/v2/webhook/subscription/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSubscriptionRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageSubscriptionApi - functional programming interface
 * @export
 */
export const ManageSubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageSubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a subscription created by your application based onthe given Subscription ID. Deleting a subscription will stop updates being sent to the requested callback URL
         * @summary Remove a subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubscription(authorization: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionDeletionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubscription(authorization, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of active or paused subscriptions and the corresponding Subscription IDs that were created by your application
         * @summary Retrieve a list of subscriptions created by your application
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptions(authorization: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListSubscriptionResponseSchema>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptions(authorization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the subscription callback URL and/or the subscription status to be either active or track only for the given Subscription ID. Updating the status to be track only will pause updates being sent to the requested callback URL
         * @summary Update a specific subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {UpdateSubscriptionRequestSchema} updateSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscription(authorization: string, subscriptionId: string, updateSubscriptionRequestSchema: UpdateSubscriptionRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscription(authorization, subscriptionId, updateSubscriptionRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManageSubscriptionApi - factory interface
 * @export
 */
export const ManageSubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageSubscriptionApiFp(configuration)
    return {
        /**
         * Deletes a subscription created by your application based onthe given Subscription ID. Deleting a subscription will stop updates being sent to the requested callback URL
         * @summary Remove a subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(authorization: string, subscriptionId: string, options?: any): AxiosPromise<SubscriptionDeletionResponse> {
            return localVarFp.deleteSubscription(authorization, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of active or paused subscriptions and the corresponding Subscription IDs that were created by your application
         * @summary Retrieve a list of subscriptions created by your application
         * @param {string} authorization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptions(authorization: string, options?: any): AxiosPromise<Array<ListSubscriptionResponseSchema>> {
            return localVarFp.listSubscriptions(authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the subscription callback URL and/or the subscription status to be either active or track only for the given Subscription ID. Updating the status to be track only will pause updates being sent to the requested callback URL
         * @summary Update a specific subscription created by your application
         * @param {string} authorization 
         * @param {string} subscriptionId 
         * @param {UpdateSubscriptionRequestSchema} updateSubscriptionRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscription(authorization: string, subscriptionId: string, updateSubscriptionRequestSchema: UpdateSubscriptionRequestSchema, options?: any): AxiosPromise<SubscriptionUpdateResponse> {
            return localVarFp.updateSubscription(authorization, subscriptionId, updateSubscriptionRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageSubscriptionApi - object-oriented interface
 * @export
 * @class ManageSubscriptionApi
 * @extends {BaseAPI}
 */
export class ManageSubscriptionApi extends BaseAPI {
    /**
     * Deletes a subscription created by your application based onthe given Subscription ID. Deleting a subscription will stop updates being sent to the requested callback URL
     * @summary Remove a subscription created by your application
     * @param {string} authorization 
     * @param {string} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageSubscriptionApi
     */
    public deleteSubscription(authorization: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return ManageSubscriptionApiFp(this.configuration).deleteSubscription(authorization, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of active or paused subscriptions and the corresponding Subscription IDs that were created by your application
     * @summary Retrieve a list of subscriptions created by your application
     * @param {string} authorization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageSubscriptionApi
     */
    public listSubscriptions(authorization: string, options?: AxiosRequestConfig) {
        return ManageSubscriptionApiFp(this.configuration).listSubscriptions(authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the subscription callback URL and/or the subscription status to be either active or track only for the given Subscription ID. Updating the status to be track only will pause updates being sent to the requested callback URL
     * @summary Update a specific subscription created by your application
     * @param {string} authorization 
     * @param {string} subscriptionId 
     * @param {UpdateSubscriptionRequestSchema} updateSubscriptionRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageSubscriptionApi
     */
    public updateSubscription(authorization: string, subscriptionId: string, updateSubscriptionRequestSchema: UpdateSubscriptionRequestSchema, options?: AxiosRequestConfig) {
        return ManageSubscriptionApiFp(this.configuration).updateSubscription(authorization, subscriptionId, updateSubscriptionRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MonitorAResourceApi - axios parameter creator
 * @export
 */
export const MonitorAResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Overledger creates a tracking record for the given address and records information each time the given address receives or sends transactions on the DLT
         * @summary Monitor an address for incoming and outgoing transactions
         * @param {string} authorization 
         * @param {AddressMonitoringRequestSchema} addressMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceMonitoringAddress: async (authorization: string, addressMonitoringRequestSchema: AddressMonitoringRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('resourceMonitoringAddress', 'authorization', authorization)
            // verify required parameter 'addressMonitoringRequestSchema' is not null or undefined
            assertParamExists('resourceMonitoringAddress', 'addressMonitoringRequestSchema', addressMonitoringRequestSchema)
            const localVarPath = `/v2/resourcemonitoring/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressMonitoringRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Overledger creates a tracking record for the given smart contract and records information each time a transaction on the DLT triggers a specific event
         * @summary Monitor a smart contract for an event
         * @param {string} authorization 
         * @param {MonitorSmartContractRequestSchema} monitorSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackAndSubscribeEvent: async (authorization: string, monitorSmartContractRequestSchema: MonitorSmartContractRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('trackAndSubscribeEvent', 'authorization', authorization)
            // verify required parameter 'monitorSmartContractRequestSchema' is not null or undefined
            assertParamExists('trackAndSubscribeEvent', 'monitorSmartContractRequestSchema', monitorSmartContractRequestSchema)
            const localVarPath = `/v2/resourcemonitoring/smartcontractevent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(monitorSmartContractRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonitorAResourceApi - functional programming interface
 * @export
 */
export const MonitorAResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonitorAResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Overledger creates a tracking record for the given address and records information each time the given address receives or sends transactions on the DLT
         * @summary Monitor an address for incoming and outgoing transactions
         * @param {string} authorization 
         * @param {AddressMonitoringRequestSchema} addressMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceMonitoringAddress(authorization: string, addressMonitoringRequestSchema: AddressMonitoringRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressMonitoringResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceMonitoringAddress(authorization, addressMonitoringRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Overledger creates a tracking record for the given smart contract and records information each time a transaction on the DLT triggers a specific event
         * @summary Monitor a smart contract for an event
         * @param {string} authorization 
         * @param {MonitorSmartContractRequestSchema} monitorSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackAndSubscribeEvent(authorization: string, monitorSmartContractRequestSchema: MonitorSmartContractRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSmartContractMonitoringSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackAndSubscribeEvent(authorization, monitorSmartContractRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MonitorAResourceApi - factory interface
 * @export
 */
export const MonitorAResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonitorAResourceApiFp(configuration)
    return {
        /**
         * Overledger creates a tracking record for the given address and records information each time the given address receives or sends transactions on the DLT
         * @summary Monitor an address for incoming and outgoing transactions
         * @param {string} authorization 
         * @param {AddressMonitoringRequestSchema} addressMonitoringRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceMonitoringAddress(authorization: string, addressMonitoringRequestSchema: AddressMonitoringRequestSchema, options?: any): AxiosPromise<AddressMonitoringResponseSchema> {
            return localVarFp.resourceMonitoringAddress(authorization, addressMonitoringRequestSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Overledger creates a tracking record for the given smart contract and records information each time a transaction on the DLT triggers a specific event
         * @summary Monitor a smart contract for an event
         * @param {string} authorization 
         * @param {MonitorSmartContractRequestSchema} monitorSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackAndSubscribeEvent(authorization: string, monitorSmartContractRequestSchema: MonitorSmartContractRequestSchema, options?: any): AxiosPromise<CreateSmartContractMonitoringSchema> {
            return localVarFp.trackAndSubscribeEvent(authorization, monitorSmartContractRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonitorAResourceApi - object-oriented interface
 * @export
 * @class MonitorAResourceApi
 * @extends {BaseAPI}
 */
export class MonitorAResourceApi extends BaseAPI {
    /**
     * Overledger creates a tracking record for the given address and records information each time the given address receives or sends transactions on the DLT
     * @summary Monitor an address for incoming and outgoing transactions
     * @param {string} authorization 
     * @param {AddressMonitoringRequestSchema} addressMonitoringRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorAResourceApi
     */
    public resourceMonitoringAddress(authorization: string, addressMonitoringRequestSchema: AddressMonitoringRequestSchema, options?: AxiosRequestConfig) {
        return MonitorAResourceApiFp(this.configuration).resourceMonitoringAddress(authorization, addressMonitoringRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Overledger creates a tracking record for the given smart contract and records information each time a transaction on the DLT triggers a specific event
     * @summary Monitor a smart contract for an event
     * @param {string} authorization 
     * @param {MonitorSmartContractRequestSchema} monitorSmartContractRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorAResourceApi
     */
    public trackAndSubscribeEvent(authorization: string, monitorSmartContractRequestSchema: MonitorSmartContractRequestSchema, options?: AxiosRequestConfig) {
        return MonitorAResourceApiFp(this.configuration).trackAndSubscribeEvent(authorization, monitorSmartContractRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SmartContractSearchApi - axios parameter creator
 * @export
 */
export const SmartContractSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the smart contract query search on the requested DLT.
         * @summary Prepare and automatically execute a search for a smart contract query on a DLT.
         * @param {string} authorization 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchSmartContractQueryRequest: async (authorization: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchSmartContractQueryRequest', 'authorization', authorization)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchSmartContractQueryRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/smartcontract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID and reads the smart contract on Ethereum based on the parameters specified in the prepare request.
         * @summary Execute a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequest: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequest', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequest', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/smartcontract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a request ID for executing a smart contract read on Ethereum.
         * @summary Prepare a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {PrepareSearchSmartContractRequestSchema} prepareSearchSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSmartContractQueryRequest: async (authorization: string, prepareSearchSmartContractRequestSchema: PrepareSearchSmartContractRequestSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSmartContractQueryRequest', 'authorization', authorization)
            // verify required parameter 'prepareSearchSmartContractRequestSchema' is not null or undefined
            assertParamExists('prepareSmartContractQueryRequest', 'prepareSearchSmartContractRequestSchema', prepareSearchSmartContractRequestSchema)
            const localVarPath = `/v2/preparation/search/smartcontract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSmartContractRequestSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SmartContractSearchApi - functional programming interface
 * @export
 */
export const SmartContractSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartContractSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the smart contract query search on the requested DLT.
         * @summary Prepare and automatically execute a search for a smart contract query on a DLT.
         * @param {string} authorization 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchSmartContractQueryRequest(authorization: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecuteSearchAddressBalanceResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchSmartContractQueryRequest(authorization, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID and reads the smart contract on Ethereum based on the parameters specified in the prepare request.
         * @summary Execute a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequest(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSmartContractReadResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequest(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a request ID for executing a smart contract read on Ethereum.
         * @summary Prepare a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {PrepareSearchSmartContractRequestSchema} prepareSearchSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSmartContractQueryRequest(authorization: string, prepareSearchSmartContractRequestSchema: PrepareSearchSmartContractRequestSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSmartContractQueryRequest(authorization, prepareSearchSmartContractRequestSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SmartContractSearchApi - factory interface
 * @export
 */
export const SmartContractSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SmartContractSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the smart contract query search on the requested DLT.
         * @summary Prepare and automatically execute a search for a smart contract query on a DLT.
         * @param {string} authorization 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchSmartContractQueryRequest(authorization: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecuteSearchAddressBalanceResponseSchema> {
            return localVarFp.autoExecuteSearchSmartContractQueryRequest(authorization, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID and reads the smart contract on Ethereum based on the parameters specified in the prepare request.
         * @summary Execute a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequest(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSmartContractReadResponseSchema> {
            return localVarFp.executePreparedSearchRequest(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a request ID for executing a smart contract read on Ethereum.
         * @summary Prepare a read of a smart contract on a DLT
         * @param {string} authorization 
         * @param {PrepareSearchSmartContractRequestSchema} prepareSearchSmartContractRequestSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSmartContractQueryRequest(authorization: string, prepareSearchSmartContractRequestSchema: PrepareSearchSmartContractRequestSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareSmartContractQueryRequest(authorization, prepareSearchSmartContractRequestSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SmartContractSearchApi - object-oriented interface
 * @export
 * @class SmartContractSearchApi
 * @extends {BaseAPI}
 */
export class SmartContractSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the smart contract query search on the requested DLT.
     * @summary Prepare and automatically execute a search for a smart contract query on a DLT.
     * @param {string} authorization 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractSearchApi
     */
    public autoExecuteSearchSmartContractQueryRequest(authorization: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return SmartContractSearchApiFp(this.configuration).autoExecuteSearchSmartContractQueryRequest(authorization, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID and reads the smart contract on Ethereum based on the parameters specified in the prepare request.
     * @summary Execute a read of a smart contract on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractSearchApi
     */
    public executePreparedSearchRequest(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return SmartContractSearchApiFp(this.configuration).executePreparedSearchRequest(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a request ID for executing a smart contract read on Ethereum.
     * @summary Prepare a read of a smart contract on a DLT
     * @param {string} authorization 
     * @param {PrepareSearchSmartContractRequestSchema} prepareSearchSmartContractRequestSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartContractSearchApi
     */
    public prepareSmartContractQueryRequest(authorization: string, prepareSearchSmartContractRequestSchema: PrepareSearchSmartContractRequestSchema, options?: AxiosRequestConfig) {
        return SmartContractSearchApiFp(this.configuration).prepareSmartContractQueryRequest(authorization, prepareSearchSmartContractRequestSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionSearchApi - axios parameter creator
 * @export
 */
export const TransactionSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the transaction search on the requested DLT.
         * @summary Prepare and automatically execute a search for a transaction on a DLT.
         * @param {string} authorization 
         * @param {string} transactionId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchTransactionRequest: async (authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchTransactionRequest', 'authorization', authorization)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('autoExecuteSearchTransactionRequest', 'transactionId', transactionId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchTransactionRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID and searches for the transaction on the requested DLT
         * @summary Execute a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestTransaction: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executePreparedSearchRequestTransaction', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executePreparedSearchRequestTransaction', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for and returns data on transactions on a particular DLT. Returns a request ID for executing a transaction search on the requested DLT
         * @summary Prepare a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} transactionId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchRequest: async (authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSearchRequest', 'authorization', authorization)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('prepareSearchRequest', 'transactionId', transactionId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareSearchRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionSearchApi - functional programming interface
 * @export
 */
export const TransactionSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the transaction search on the requested DLT.
         * @summary Prepare and automatically execute a search for a transaction on a DLT.
         * @param {string} authorization 
         * @param {string} transactionId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchTransactionRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareAndExecuteTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchTransactionRequest(authorization, transactionId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID and searches for the transaction on the requested DLT
         * @summary Execute a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executePreparedSearchRequestTransaction(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executePreparedSearchRequestTransaction(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Searches for and returns data on transactions on a particular DLT. Returns a request ID for executing a transaction search on the requested DLT
         * @summary Prepare a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} transactionId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSearchRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSearchRequest(authorization, transactionId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionSearchApi - factory interface
 * @export
 */
export const TransactionSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the transaction search on the requested DLT.
         * @summary Prepare and automatically execute a search for a transaction on a DLT.
         * @param {string} authorization 
         * @param {string} transactionId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchTransactionRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareAndExecuteTransactionResponse> {
            return localVarFp.autoExecuteSearchTransactionRequest(authorization, transactionId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID and searches for the transaction on the requested DLT
         * @summary Execute a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePreparedSearchRequestTransaction(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchTransactionResponse> {
            return localVarFp.executePreparedSearchRequestTransaction(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for and returns data on transactions on a particular DLT. Returns a request ID for executing a transaction search on the requested DLT
         * @summary Prepare a search for a transaction on a DLT
         * @param {string} authorization 
         * @param {string} transactionId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareSearchRequest(authorization, transactionId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionSearchApi - object-oriented interface
 * @export
 * @class TransactionSearchApi
 * @extends {BaseAPI}
 */
export class TransactionSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the transaction search on the requested DLT.
     * @summary Prepare and automatically execute a search for a transaction on a DLT.
     * @param {string} authorization 
     * @param {string} transactionId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionSearchApi
     */
    public autoExecuteSearchTransactionRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return TransactionSearchApiFp(this.configuration).autoExecuteSearchTransactionRequest(authorization, transactionId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID and searches for the transaction on the requested DLT
     * @summary Execute a search for a transaction on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionSearchApi
     */
    public executePreparedSearchRequestTransaction(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return TransactionSearchApiFp(this.configuration).executePreparedSearchRequestTransaction(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for and returns data on transactions on a particular DLT. Returns a request ID for executing a transaction search on the requested DLT
     * @summary Prepare a search for a transaction on a DLT
     * @param {string} authorization 
     * @param {string} transactionId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionSearchApi
     */
    public prepareSearchRequest(authorization: string, transactionId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return TransactionSearchApiFp(this.configuration).prepareSearchRequest(authorization, transactionId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UTXOStatusSearchApi - axios parameter creator
 * @export
 */
export const UTXOStatusSearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a request ID and automatically executes the utxo search on the requested DLT.
         * @summary Prepare and automatically execute a search for a UTXO on a DLT.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchUtxoRequest: async (authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('autoExecuteSearchUtxoRequest', 'authorization', authorization)
            // verify required parameter 'utxoId' is not null or undefined
            assertParamExists('autoExecuteSearchUtxoRequest', 'utxoId', utxoId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('autoExecuteSearchUtxoRequest', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/autoexecution/search/utxo/{utxoId}`
                .replace(`{${"utxoId"}}`, encodeURIComponent(String(utxoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a request ID, searches for the UTXO state and retrieves the details on the requested DLT. This API is only applicable for Bitcoin.
         * @summary Execute a search for UTXO state on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeUTXOPreparedSearchRequest: async (authorization: string, requestId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('executeUTXOPreparedSearchRequest', 'authorization', authorization)
            // verify required parameter 'requestId' is not null or undefined
            assertParamExists('executeUTXOPreparedSearchRequest', 'requestId', requestId)
            const localVarPath = `/v2/execution/search/utxo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (requestId !== undefined) {
                localVarQueryParameter['requestId'] = requestId;
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a request ID for executing a search for the status ofa UTXO on UTXO based DLT\'s
         * @summary Prepare Search for a UTXO State.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchUTXOState: async (authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('prepareSearchUTXOState', 'authorization', authorization)
            // verify required parameter 'utxoId' is not null or undefined
            assertParamExists('prepareSearchUTXOState', 'utxoId', utxoId)
            // verify required parameter 'prepareSearchSchema' is not null or undefined
            assertParamExists('prepareSearchUTXOState', 'prepareSearchSchema', prepareSearchSchema)
            const localVarPath = `/v2/preparation/search/utxo/{utxoId}`
                .replace(`{${"utxoId"}}`, encodeURIComponent(String(utxoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2_Security_Scheme required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2_Security_Scheme", ["overledger/read.scope"], configuration)

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prepareSearchSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UTXOStatusSearchApi - functional programming interface
 * @export
 */
export const UTXOStatusSearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UTXOStatusSearchApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the utxo search on the requested DLT.
         * @summary Prepare and automatically execute a search for a UTXO on a DLT.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoExecuteSearchUtxoRequest(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoExecuteSearchUTXOResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoExecuteSearchUtxoRequest(authorization, utxoId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Takes a request ID, searches for the UTXO state and retrieves the details on the requested DLT. This API is only applicable for Bitcoin.
         * @summary Execute a search for UTXO state on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeUTXOPreparedSearchRequest(authorization: string, requestId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteSearchUTXOResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeUTXOPreparedSearchRequest(authorization, requestId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a request ID for executing a search for the status ofa UTXO on UTXO based DLT\'s
         * @summary Prepare Search for a UTXO State.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async prepareSearchUTXOState(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareSearchResponseSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.prepareSearchUTXOState(authorization, utxoId, prepareSearchSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UTXOStatusSearchApi - factory interface
 * @export
 */
export const UTXOStatusSearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UTXOStatusSearchApiFp(configuration)
    return {
        /**
         * Generates a request ID and automatically executes the utxo search on the requested DLT.
         * @summary Prepare and automatically execute a search for a UTXO on a DLT.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoExecuteSearchUtxoRequest(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<AutoExecuteSearchUTXOResponseSchema> {
            return localVarFp.autoExecuteSearchUtxoRequest(authorization, utxoId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a request ID, searches for the UTXO state and retrieves the details on the requested DLT. This API is only applicable for Bitcoin.
         * @summary Execute a search for UTXO state on a DLT
         * @param {string} authorization 
         * @param {string} requestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeUTXOPreparedSearchRequest(authorization: string, requestId: string, options?: any): AxiosPromise<ExecuteSearchUTXOResponseSchema> {
            return localVarFp.executeUTXOPreparedSearchRequest(authorization, requestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a request ID for executing a search for the status ofa UTXO on UTXO based DLT\'s
         * @summary Prepare Search for a UTXO State.
         * @param {string} authorization 
         * @param {string} utxoId 
         * @param {PrepareSearchSchema} prepareSearchSchema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        prepareSearchUTXOState(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: any): AxiosPromise<PrepareSearchResponseSchema> {
            return localVarFp.prepareSearchUTXOState(authorization, utxoId, prepareSearchSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UTXOStatusSearchApi - object-oriented interface
 * @export
 * @class UTXOStatusSearchApi
 * @extends {BaseAPI}
 */
export class UTXOStatusSearchApi extends BaseAPI {
    /**
     * Generates a request ID and automatically executes the utxo search on the requested DLT.
     * @summary Prepare and automatically execute a search for a UTXO on a DLT.
     * @param {string} authorization 
     * @param {string} utxoId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UTXOStatusSearchApi
     */
    public autoExecuteSearchUtxoRequest(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return UTXOStatusSearchApiFp(this.configuration).autoExecuteSearchUtxoRequest(authorization, utxoId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a request ID, searches for the UTXO state and retrieves the details on the requested DLT. This API is only applicable for Bitcoin.
     * @summary Execute a search for UTXO state on a DLT
     * @param {string} authorization 
     * @param {string} requestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UTXOStatusSearchApi
     */
    public executeUTXOPreparedSearchRequest(authorization: string, requestId: string, options?: AxiosRequestConfig) {
        return UTXOStatusSearchApiFp(this.configuration).executeUTXOPreparedSearchRequest(authorization, requestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a request ID for executing a search for the status ofa UTXO on UTXO based DLT\'s
     * @summary Prepare Search for a UTXO State.
     * @param {string} authorization 
     * @param {string} utxoId 
     * @param {PrepareSearchSchema} prepareSearchSchema 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UTXOStatusSearchApi
     */
    public prepareSearchUTXOState(authorization: string, utxoId: string, prepareSearchSchema: PrepareSearchSchema, options?: AxiosRequestConfig) {
        return UTXOStatusSearchApiFp(this.configuration).prepareSearchUTXOState(authorization, utxoId, prepareSearchSchema, options).then((request) => request(this.axios, this.basePath));
    }
}



{-
   Quant Overledger API

   Quant’s Overledger API allows developers to create applications for multiple DLT’s using a single standard set of operations and data structures.In order to maintain the security of private keys, most operations have two steps – prepare and execute. The prepare step is the point at which all arguments are specified and standardised payloads are sent. Overledger converts this standard payload into a DLT-specific transaction object. In the execute step, the SDK signs the transaction object that Overledger created and submits it to Overledger to perform the operation  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->

   OpenAPI Version: 3.0.1
   Quant Overledger API API version: 2.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : QuantOverledger.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module QuantOverledger.Model where

import QuantOverledger.Core
import QuantOverledger.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AddressId
newtype AddressId = AddressId { unAddressId :: Text } deriving (P.Eq, P.Show)

-- ** Authorization
newtype Authorization = Authorization { unAuthorization :: Text } deriving (P.Eq, P.Show)

-- ** BlockId
newtype BlockId = BlockId { unBlockId :: Text } deriving (P.Eq, P.Show)

-- ** Length
newtype Length = Length { unLength :: Int } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** Overledgertransactionid
newtype Overledgertransactionid = Overledgertransactionid { unOverledgertransactionid :: Text } deriving (P.Eq, P.Show)

-- ** RequestId
newtype RequestId = RequestId { unRequestId :: Text } deriving (P.Eq, P.Show)

-- ** ResourceMonitoringId
newtype ResourceMonitoringId = ResourceMonitoringId { unResourceMonitoringId :: Text } deriving (P.Eq, P.Show)

-- ** SubscriptionId
newtype SubscriptionId = SubscriptionId { unSubscriptionId :: Text } deriving (P.Eq, P.Show)

-- ** TransactionId
newtype TransactionId = TransactionId { unTransactionId :: Text } deriving (P.Eq, P.Show)

-- ** UtxoId
newtype UtxoId = UtxoId { unUtxoId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AddressBalanceResponse
-- | AddressBalanceResponse
data AddressBalanceResponse = AddressBalanceResponse
  { addressBalanceResponseUnit :: !(Maybe Text) -- ^ "unit"
  , addressBalanceResponseValue :: !(Maybe Double) -- ^ "value"
  , addressBalanceResponseAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressBalanceResponse
instance A.FromJSON AddressBalanceResponse where
  parseJSON = A.withObject "AddressBalanceResponse" $ \o ->
    AddressBalanceResponse
      <$> (o .:? "unit")
      <*> (o .:? "value")
      <*> (o .:? "addressId")

-- | ToJSON AddressBalanceResponse
instance A.ToJSON AddressBalanceResponse where
  toJSON AddressBalanceResponse {..} =
   _omitNulls
      [ "unit" .= addressBalanceResponseUnit
      , "value" .= addressBalanceResponseValue
      , "addressId" .= addressBalanceResponseAddressId
      ]


-- | Construct a value of type 'AddressBalanceResponse' (by applying it's required fields, if any)
mkAddressBalanceResponse
  :: AddressBalanceResponse
mkAddressBalanceResponse =
  AddressBalanceResponse
  { addressBalanceResponseUnit = Nothing
  , addressBalanceResponseValue = Nothing
  , addressBalanceResponseAddressId = Nothing
  }

-- ** AddressMonitoringDetailsSchema
-- | AddressMonitoringDetailsSchema
data AddressMonitoringDetailsSchema = AddressMonitoringDetailsSchema
  { addressMonitoringDetailsSchemaLocation :: !(Maybe Location) -- ^ "location"
  , addressMonitoringDetailsSchemaAddressDetails :: !(Maybe ResourceMonitoredAddressDetails) -- ^ "addressDetails"
  , addressMonitoringDetailsSchemaType :: !(Maybe Text) -- ^ "type"
  , addressMonitoringDetailsSchemaTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressMonitoringDetailsSchema
instance A.FromJSON AddressMonitoringDetailsSchema where
  parseJSON = A.withObject "AddressMonitoringDetailsSchema" $ \o ->
    AddressMonitoringDetailsSchema
      <$> (o .:? "location")
      <*> (o .:? "addressDetails")
      <*> (o .:? "type")
      <*> (o .:? "timestamp")

-- | ToJSON AddressMonitoringDetailsSchema
instance A.ToJSON AddressMonitoringDetailsSchema where
  toJSON AddressMonitoringDetailsSchema {..} =
   _omitNulls
      [ "location" .= addressMonitoringDetailsSchemaLocation
      , "addressDetails" .= addressMonitoringDetailsSchemaAddressDetails
      , "type" .= addressMonitoringDetailsSchemaType
      , "timestamp" .= addressMonitoringDetailsSchemaTimestamp
      ]


-- | Construct a value of type 'AddressMonitoringDetailsSchema' (by applying it's required fields, if any)
mkAddressMonitoringDetailsSchema
  :: AddressMonitoringDetailsSchema
mkAddressMonitoringDetailsSchema =
  AddressMonitoringDetailsSchema
  { addressMonitoringDetailsSchemaLocation = Nothing
  , addressMonitoringDetailsSchemaAddressDetails = Nothing
  , addressMonitoringDetailsSchemaType = Nothing
  , addressMonitoringDetailsSchemaTimestamp = Nothing
  }

-- ** AddressMonitoringRequestSchema
-- | AddressMonitoringRequestSchema
data AddressMonitoringRequestSchema = AddressMonitoringRequestSchema
  { addressMonitoringRequestSchemaCallBackUrl :: !(Maybe Text) -- ^ "callBackURL"
  , addressMonitoringRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  , addressMonitoringRequestSchemaAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressMonitoringRequestSchema
instance A.FromJSON AddressMonitoringRequestSchema where
  parseJSON = A.withObject "AddressMonitoringRequestSchema" $ \o ->
    AddressMonitoringRequestSchema
      <$> (o .:? "callBackURL")
      <*> (o .:? "location")
      <*> (o .:? "addressId")

-- | ToJSON AddressMonitoringRequestSchema
instance A.ToJSON AddressMonitoringRequestSchema where
  toJSON AddressMonitoringRequestSchema {..} =
   _omitNulls
      [ "callBackURL" .= addressMonitoringRequestSchemaCallBackUrl
      , "location" .= addressMonitoringRequestSchemaLocation
      , "addressId" .= addressMonitoringRequestSchemaAddressId
      ]


-- | Construct a value of type 'AddressMonitoringRequestSchema' (by applying it's required fields, if any)
mkAddressMonitoringRequestSchema
  :: AddressMonitoringRequestSchema
mkAddressMonitoringRequestSchema =
  AddressMonitoringRequestSchema
  { addressMonitoringRequestSchemaCallBackUrl = Nothing
  , addressMonitoringRequestSchemaLocation = Nothing
  , addressMonitoringRequestSchemaAddressId = Nothing
  }

-- ** AddressMonitoringResponseSchema
-- | AddressMonitoringResponseSchema
data AddressMonitoringResponseSchema = AddressMonitoringResponseSchema
  { addressMonitoringResponseSchemaSubscriptionDetails :: !(Maybe ResourceMonitoringSubscriptionDetails) -- ^ "subscriptionDetails"
  , addressMonitoringResponseSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  , addressMonitoringResponseSchemaSubscription :: !(Maybe ResourceMonitoringSubscription) -- ^ "subscription"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressMonitoringResponseSchema
instance A.FromJSON AddressMonitoringResponseSchema where
  parseJSON = A.withObject "AddressMonitoringResponseSchema" $ \o ->
    AddressMonitoringResponseSchema
      <$> (o .:? "subscriptionDetails")
      <*> (o .:? "resourceMonitoring")
      <*> (o .:? "subscription")

-- | ToJSON AddressMonitoringResponseSchema
instance A.ToJSON AddressMonitoringResponseSchema where
  toJSON AddressMonitoringResponseSchema {..} =
   _omitNulls
      [ "subscriptionDetails" .= addressMonitoringResponseSchemaSubscriptionDetails
      , "resourceMonitoring" .= addressMonitoringResponseSchemaResourceMonitoring
      , "subscription" .= addressMonitoringResponseSchemaSubscription
      ]


-- | Construct a value of type 'AddressMonitoringResponseSchema' (by applying it's required fields, if any)
mkAddressMonitoringResponseSchema
  :: AddressMonitoringResponseSchema
mkAddressMonitoringResponseSchema =
  AddressMonitoringResponseSchema
  { addressMonitoringResponseSchemaSubscriptionDetails = Nothing
  , addressMonitoringResponseSchemaResourceMonitoring = Nothing
  , addressMonitoringResponseSchemaSubscription = Nothing
  }

-- ** Block
-- | Block
data Block = Block
  { blockBlockId :: !(Maybe Text) -- ^ "blockId"
  , blockNumber :: !(Maybe Int) -- ^ "number"
  , blockTransactionIds :: !(Maybe [Text]) -- ^ "transactionIds"
  , blockSize :: !(Maybe [BlockSize]) -- ^ "size"
  , blockHashes :: !(Maybe [BlockHash]) -- ^ "hashes"
  , blockLinkedBlocks :: !(Maybe LinkedBlocks) -- ^ "linkedBlocks"
  , blockNumberOfTransactions :: !(Maybe Int) -- ^ "numberOfTransactions"
  , blockMessage :: !(Maybe Text) -- ^ "message"
  , blockTimestamp :: !(Maybe Int) -- ^ "timestamp"
  , blockNativeData :: !(Maybe A.Value) -- ^ "nativeData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Block
instance A.FromJSON Block where
  parseJSON = A.withObject "Block" $ \o ->
    Block
      <$> (o .:? "blockId")
      <*> (o .:? "number")
      <*> (o .:? "transactionIds")
      <*> (o .:? "size")
      <*> (o .:? "hashes")
      <*> (o .:? "linkedBlocks")
      <*> (o .:? "numberOfTransactions")
      <*> (o .:? "message")
      <*> (o .:? "timestamp")
      <*> (o .:? "nativeData")

-- | ToJSON Block
instance A.ToJSON Block where
  toJSON Block {..} =
   _omitNulls
      [ "blockId" .= blockBlockId
      , "number" .= blockNumber
      , "transactionIds" .= blockTransactionIds
      , "size" .= blockSize
      , "hashes" .= blockHashes
      , "linkedBlocks" .= blockLinkedBlocks
      , "numberOfTransactions" .= blockNumberOfTransactions
      , "message" .= blockMessage
      , "timestamp" .= blockTimestamp
      , "nativeData" .= blockNativeData
      ]


-- | Construct a value of type 'Block' (by applying it's required fields, if any)
mkBlock
  :: Block
mkBlock =
  Block
  { blockBlockId = Nothing
  , blockNumber = Nothing
  , blockTransactionIds = Nothing
  , blockSize = Nothing
  , blockHashes = Nothing
  , blockLinkedBlocks = Nothing
  , blockNumberOfTransactions = Nothing
  , blockMessage = Nothing
  , blockTimestamp = Nothing
  , blockNativeData = Nothing
  }

-- ** BlockHash
-- | BlockHash
data BlockHash = BlockHash
  { blockHashType :: !(Maybe Text) -- ^ "type"
  , blockHashValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BlockHash
instance A.FromJSON BlockHash where
  parseJSON = A.withObject "BlockHash" $ \o ->
    BlockHash
      <$> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON BlockHash
instance A.ToJSON BlockHash where
  toJSON BlockHash {..} =
   _omitNulls
      [ "type" .= blockHashType
      , "value" .= blockHashValue
      ]


-- | Construct a value of type 'BlockHash' (by applying it's required fields, if any)
mkBlockHash
  :: BlockHash
mkBlockHash =
  BlockHash
  { blockHashType = Nothing
  , blockHashValue = Nothing
  }

-- ** BlockSize
-- | BlockSize
data BlockSize = BlockSize
  { blockSizeType :: !(Maybe Text) -- ^ "type"
  , blockSizeValue :: !(Maybe Text) -- ^ "value"
  , blockSizeKey :: !(Maybe Text) -- ^ "key"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BlockSize
instance A.FromJSON BlockSize where
  parseJSON = A.withObject "BlockSize" $ \o ->
    BlockSize
      <$> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "key")

-- | ToJSON BlockSize
instance A.ToJSON BlockSize where
  toJSON BlockSize {..} =
   _omitNulls
      [ "type" .= blockSizeType
      , "value" .= blockSizeValue
      , "key" .= blockSizeKey
      ]


-- | Construct a value of type 'BlockSize' (by applying it's required fields, if any)
mkBlockSize
  :: BlockSize
mkBlockSize =
  BlockSize
  { blockSizeType = Nothing
  , blockSizeValue = Nothing
  , blockSizeKey = Nothing
  }

-- ** CreateSmartContractMonitoringSchema
-- | CreateSmartContractMonitoringSchema
data CreateSmartContractMonitoringSchema = CreateSmartContractMonitoringSchema
  { createSmartContractMonitoringSchemaSubscriptionDetails :: !(Maybe ResourceMonitoringSubscriptionDetails) -- ^ "subscriptionDetails"
  , createSmartContractMonitoringSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  , createSmartContractMonitoringSchemaSubscription :: !(Maybe ResourceMonitoringSubscription) -- ^ "subscription"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSmartContractMonitoringSchema
instance A.FromJSON CreateSmartContractMonitoringSchema where
  parseJSON = A.withObject "CreateSmartContractMonitoringSchema" $ \o ->
    CreateSmartContractMonitoringSchema
      <$> (o .:? "subscriptionDetails")
      <*> (o .:? "resourceMonitoring")
      <*> (o .:? "subscription")

-- | ToJSON CreateSmartContractMonitoringSchema
instance A.ToJSON CreateSmartContractMonitoringSchema where
  toJSON CreateSmartContractMonitoringSchema {..} =
   _omitNulls
      [ "subscriptionDetails" .= createSmartContractMonitoringSchemaSubscriptionDetails
      , "resourceMonitoring" .= createSmartContractMonitoringSchemaResourceMonitoring
      , "subscription" .= createSmartContractMonitoringSchemaSubscription
      ]


-- | Construct a value of type 'CreateSmartContractMonitoringSchema' (by applying it's required fields, if any)
mkCreateSmartContractMonitoringSchema
  :: CreateSmartContractMonitoringSchema
mkCreateSmartContractMonitoringSchema =
  CreateSmartContractMonitoringSchema
  { createSmartContractMonitoringSchemaSubscriptionDetails = Nothing
  , createSmartContractMonitoringSchemaResourceMonitoring = Nothing
  , createSmartContractMonitoringSchemaSubscription = Nothing
  }

-- ** CreateSubscriptionRequestSchema
-- | CreateSubscriptionRequestSchema
data CreateSubscriptionRequestSchema = CreateSubscriptionRequestSchema
  { createSubscriptionRequestSchemaIds :: !(Maybe [Text]) -- ^ "ids"
  , createSubscriptionRequestSchemaCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  , createSubscriptionRequestSchemaType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSubscriptionRequestSchema
instance A.FromJSON CreateSubscriptionRequestSchema where
  parseJSON = A.withObject "CreateSubscriptionRequestSchema" $ \o ->
    CreateSubscriptionRequestSchema
      <$> (o .:? "ids")
      <*> (o .:? "callbackUrl")
      <*> (o .:? "type")

-- | ToJSON CreateSubscriptionRequestSchema
instance A.ToJSON CreateSubscriptionRequestSchema where
  toJSON CreateSubscriptionRequestSchema {..} =
   _omitNulls
      [ "ids" .= createSubscriptionRequestSchemaIds
      , "callbackUrl" .= createSubscriptionRequestSchemaCallbackUrl
      , "type" .= createSubscriptionRequestSchemaType
      ]


-- | Construct a value of type 'CreateSubscriptionRequestSchema' (by applying it's required fields, if any)
mkCreateSubscriptionRequestSchema
  :: CreateSubscriptionRequestSchema
mkCreateSubscriptionRequestSchema =
  CreateSubscriptionRequestSchema
  { createSubscriptionRequestSchemaIds = Nothing
  , createSubscriptionRequestSchemaCallbackUrl = Nothing
  , createSubscriptionRequestSchemaType = Nothing
  }

-- ** CreateSubscriptionResponseSchema
-- | CreateSubscriptionResponseSchema
data CreateSubscriptionResponseSchema = CreateSubscriptionResponseSchema
  { createSubscriptionResponseSchemaScubscriptionDetails :: !(Maybe SubscriptionDetailsSchema) -- ^ "scubscriptionDetails"
  , createSubscriptionResponseSchemaSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSubscriptionResponseSchema
instance A.FromJSON CreateSubscriptionResponseSchema where
  parseJSON = A.withObject "CreateSubscriptionResponseSchema" $ \o ->
    CreateSubscriptionResponseSchema
      <$> (o .:? "scubscriptionDetails")
      <*> (o .:? "subscriptionId")

-- | ToJSON CreateSubscriptionResponseSchema
instance A.ToJSON CreateSubscriptionResponseSchema where
  toJSON CreateSubscriptionResponseSchema {..} =
   _omitNulls
      [ "scubscriptionDetails" .= createSubscriptionResponseSchemaScubscriptionDetails
      , "subscriptionId" .= createSubscriptionResponseSchemaSubscriptionId
      ]


-- | Construct a value of type 'CreateSubscriptionResponseSchema' (by applying it's required fields, if any)
mkCreateSubscriptionResponseSchema
  :: CreateSubscriptionResponseSchema
mkCreateSubscriptionResponseSchema =
  CreateSubscriptionResponseSchema
  { createSubscriptionResponseSchemaScubscriptionDetails = Nothing
  , createSubscriptionResponseSchemaSubscriptionId = Nothing
  }

-- ** DeleteResourceMonitoringAddressSchema
-- | DeleteResourceMonitoringAddressSchema
data DeleteResourceMonitoringAddressSchema = DeleteResourceMonitoringAddressSchema
  { deleteResourceMonitoringAddressSchemaAddressMonitoringDetails :: !(Maybe ResourceMonitoringAddressDetails) -- ^ "addressMonitoringDetails"
  , deleteResourceMonitoringAddressSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteResourceMonitoringAddressSchema
instance A.FromJSON DeleteResourceMonitoringAddressSchema where
  parseJSON = A.withObject "DeleteResourceMonitoringAddressSchema" $ \o ->
    DeleteResourceMonitoringAddressSchema
      <$> (o .:? "addressMonitoringDetails")
      <*> (o .:? "resourceMonitoring")

-- | ToJSON DeleteResourceMonitoringAddressSchema
instance A.ToJSON DeleteResourceMonitoringAddressSchema where
  toJSON DeleteResourceMonitoringAddressSchema {..} =
   _omitNulls
      [ "addressMonitoringDetails" .= deleteResourceMonitoringAddressSchemaAddressMonitoringDetails
      , "resourceMonitoring" .= deleteResourceMonitoringAddressSchemaResourceMonitoring
      ]


-- | Construct a value of type 'DeleteResourceMonitoringAddressSchema' (by applying it's required fields, if any)
mkDeleteResourceMonitoringAddressSchema
  :: DeleteResourceMonitoringAddressSchema
mkDeleteResourceMonitoringAddressSchema =
  DeleteResourceMonitoringAddressSchema
  { deleteResourceMonitoringAddressSchemaAddressMonitoringDetails = Nothing
  , deleteResourceMonitoringAddressSchemaResourceMonitoring = Nothing
  }

-- ** Destination
-- | Destination
-- The Destination of this transaction
data Destination = Destination
  { destinationTransfer :: !(Maybe Transfer) -- ^ "transfer"
  , destinationSmartContract :: !(Maybe SmartContract) -- ^ "smartContract"
  , destinationPayment :: !(Maybe Payment) -- ^ "payment"
  , destinationDestinationId :: !(Maybe Text) -- ^ "destinationId" - The unique identifiers of the destination
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Destination
instance A.FromJSON Destination where
  parseJSON = A.withObject "Destination" $ \o ->
    Destination
      <$> (o .:? "transfer")
      <*> (o .:? "smartContract")
      <*> (o .:? "payment")
      <*> (o .:? "destinationId")

-- | ToJSON Destination
instance A.ToJSON Destination where
  toJSON Destination {..} =
   _omitNulls
      [ "transfer" .= destinationTransfer
      , "smartContract" .= destinationSmartContract
      , "payment" .= destinationPayment
      , "destinationId" .= destinationDestinationId
      ]


-- | Construct a value of type 'Destination' (by applying it's required fields, if any)
mkDestination
  :: Destination
mkDestination =
  Destination
  { destinationTransfer = Nothing
  , destinationSmartContract = Nothing
  , destinationPayment = Nothing
  , destinationDestinationId = Nothing
  }

-- ** DestinationPaymentSchema
-- | DestinationPaymentSchema
-- The Destination of this transaction
data DestinationPaymentSchema = DestinationPaymentSchema
  { destinationPaymentSchemaPayment :: !(Maybe PaymentSchema) -- ^ "payment"
  , destinationPaymentSchemaDestinationId :: !(Maybe Text) -- ^ "destinationId" - The unique identifiers of the destination
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DestinationPaymentSchema
instance A.FromJSON DestinationPaymentSchema where
  parseJSON = A.withObject "DestinationPaymentSchema" $ \o ->
    DestinationPaymentSchema
      <$> (o .:? "payment")
      <*> (o .:? "destinationId")

-- | ToJSON DestinationPaymentSchema
instance A.ToJSON DestinationPaymentSchema where
  toJSON DestinationPaymentSchema {..} =
   _omitNulls
      [ "payment" .= destinationPaymentSchemaPayment
      , "destinationId" .= destinationPaymentSchemaDestinationId
      ]


-- | Construct a value of type 'DestinationPaymentSchema' (by applying it's required fields, if any)
mkDestinationPaymentSchema
  :: DestinationPaymentSchema
mkDestinationPaymentSchema =
  DestinationPaymentSchema
  { destinationPaymentSchemaPayment = Nothing
  , destinationPaymentSchemaDestinationId = Nothing
  }

-- ** DestinationTransferSchema
-- | DestinationTransferSchema
data DestinationTransferSchema = DestinationTransferSchema
  { destinationTransferSchemaTransfer :: !(Maybe TransferSchema) -- ^ "transfer"
  , destinationTransferSchemaDestinationId :: !(Maybe Text) -- ^ "destinationId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DestinationTransferSchema
instance A.FromJSON DestinationTransferSchema where
  parseJSON = A.withObject "DestinationTransferSchema" $ \o ->
    DestinationTransferSchema
      <$> (o .:? "transfer")
      <*> (o .:? "destinationId")

-- | ToJSON DestinationTransferSchema
instance A.ToJSON DestinationTransferSchema where
  toJSON DestinationTransferSchema {..} =
   _omitNulls
      [ "transfer" .= destinationTransferSchemaTransfer
      , "destinationId" .= destinationTransferSchemaDestinationId
      ]


-- | Construct a value of type 'DestinationTransferSchema' (by applying it's required fields, if any)
mkDestinationTransferSchema
  :: DestinationTransferSchema
mkDestinationTransferSchema =
  DestinationTransferSchema
  { destinationTransferSchemaTransfer = Nothing
  , destinationTransferSchemaDestinationId = Nothing
  }

-- ** Error
-- | Error
data Error = Error
  { errorCode :: !(Maybe Int) -- ^ "code"
  , errorService :: !(Maybe Text) -- ^ "service"
  , errorMessage :: !(Maybe Text) -- ^ "message"
  , errorTimestamp :: !(Maybe Integer) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:? "code")
      <*> (o .:? "service")
      <*> (o .:? "message")
      <*> (o .:? "timestamp")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "code" .= errorCode
      , "service" .= errorService
      , "message" .= errorMessage
      , "timestamp" .= errorTimestamp
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Error
mkError =
  Error
  { errorCode = Nothing
  , errorService = Nothing
  , errorMessage = Nothing
  , errorTimestamp = Nothing
  }

-- ** ErrorDetails
-- | ErrorDetails
data ErrorDetails = ErrorDetails
  { errorDetailsCode :: !(Maybe Text) -- ^ "code"
  , errorDetailsDescription :: !(Maybe Text) -- ^ "description"
  , errorDetailsCategory :: !(Maybe Text) -- ^ "category"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorDetails
instance A.FromJSON ErrorDetails where
  parseJSON = A.withObject "ErrorDetails" $ \o ->
    ErrorDetails
      <$> (o .:? "code")
      <*> (o .:? "description")
      <*> (o .:? "category")

-- | ToJSON ErrorDetails
instance A.ToJSON ErrorDetails where
  toJSON ErrorDetails {..} =
   _omitNulls
      [ "code" .= errorDetailsCode
      , "description" .= errorDetailsDescription
      , "category" .= errorDetailsCategory
      ]


-- | Construct a value of type 'ErrorDetails' (by applying it's required fields, if any)
mkErrorDetails
  :: ErrorDetails
mkErrorDetails =
  ErrorDetails
  { errorDetailsCode = Nothing
  , errorDetailsDescription = Nothing
  , errorDetailsCategory = Nothing
  }

-- ** ErrorList
-- | ErrorList
data ErrorList = ErrorList
  { errorListErrors :: !(Maybe [Error]) -- ^ "errors"
  , errorListErrorCount :: !(Maybe Int) -- ^ "errorCount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorList
instance A.FromJSON ErrorList where
  parseJSON = A.withObject "ErrorList" $ \o ->
    ErrorList
      <$> (o .:? "errors")
      <*> (o .:? "errorCount")

-- | ToJSON ErrorList
instance A.ToJSON ErrorList where
  toJSON ErrorList {..} =
   _omitNulls
      [ "errors" .= errorListErrors
      , "errorCount" .= errorListErrorCount
      ]


-- | Construct a value of type 'ErrorList' (by applying it's required fields, if any)
mkErrorList
  :: ErrorList
mkErrorList =
  ErrorList
  { errorListErrors = Nothing
  , errorListErrorCount = Nothing
  }

-- ** ExecuteSearchBalanceResponse
-- | ExecuteSearchBalanceResponse
data ExecuteSearchBalanceResponse = ExecuteSearchBalanceResponse
  { executeSearchBalanceResponseBalances :: !(Maybe [AddressBalanceResponse]) -- ^ "balances"
  , executeSearchBalanceResponseLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchBalanceResponse
instance A.FromJSON ExecuteSearchBalanceResponse where
  parseJSON = A.withObject "ExecuteSearchBalanceResponse" $ \o ->
    ExecuteSearchBalanceResponse
      <$> (o .:? "balances")
      <*> (o .:? "location")

-- | ToJSON ExecuteSearchBalanceResponse
instance A.ToJSON ExecuteSearchBalanceResponse where
  toJSON ExecuteSearchBalanceResponse {..} =
   _omitNulls
      [ "balances" .= executeSearchBalanceResponseBalances
      , "location" .= executeSearchBalanceResponseLocation
      ]


-- | Construct a value of type 'ExecuteSearchBalanceResponse' (by applying it's required fields, if any)
mkExecuteSearchBalanceResponse
  :: ExecuteSearchBalanceResponse
mkExecuteSearchBalanceResponse =
  ExecuteSearchBalanceResponse
  { executeSearchBalanceResponseBalances = Nothing
  , executeSearchBalanceResponseLocation = Nothing
  }

-- ** ExecuteSearchBlockResponse
-- | ExecuteSearchBlockResponse
data ExecuteSearchBlockResponse = ExecuteSearchBlockResponse
  { executeSearchBlockResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchBlockResponseBlock :: !(Maybe Block) -- ^ "block"
  , executeSearchBlockResponseStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchBlockResponse
instance A.FromJSON ExecuteSearchBlockResponse where
  parseJSON = A.withObject "ExecuteSearchBlockResponse" $ \o ->
    ExecuteSearchBlockResponse
      <$> (o .:? "location")
      <*> (o .:? "block")
      <*> (o .:? "status")

-- | ToJSON ExecuteSearchBlockResponse
instance A.ToJSON ExecuteSearchBlockResponse where
  toJSON ExecuteSearchBlockResponse {..} =
   _omitNulls
      [ "location" .= executeSearchBlockResponseLocation
      , "block" .= executeSearchBlockResponseBlock
      , "status" .= executeSearchBlockResponseStatus
      ]


-- | Construct a value of type 'ExecuteSearchBlockResponse' (by applying it's required fields, if any)
mkExecuteSearchBlockResponse
  :: ExecuteSearchBlockResponse
mkExecuteSearchBlockResponse =
  ExecuteSearchBlockResponse
  { executeSearchBlockResponseLocation = Nothing
  , executeSearchBlockResponseBlock = Nothing
  , executeSearchBlockResponseStatus = Nothing
  }

-- ** ExecuteSearchSequenceResponse
-- | ExecuteSearchSequenceResponse
data ExecuteSearchSequenceResponse = ExecuteSearchSequenceResponse
  { executeSearchSequenceResponseSequence :: !(Maybe Text) -- ^ "sequence"
  , executeSearchSequenceResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchSequenceResponseAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchSequenceResponse
instance A.FromJSON ExecuteSearchSequenceResponse where
  parseJSON = A.withObject "ExecuteSearchSequenceResponse" $ \o ->
    ExecuteSearchSequenceResponse
      <$> (o .:? "sequence")
      <*> (o .:? "location")
      <*> (o .:? "addressId")

-- | ToJSON ExecuteSearchSequenceResponse
instance A.ToJSON ExecuteSearchSequenceResponse where
  toJSON ExecuteSearchSequenceResponse {..} =
   _omitNulls
      [ "sequence" .= executeSearchSequenceResponseSequence
      , "location" .= executeSearchSequenceResponseLocation
      , "addressId" .= executeSearchSequenceResponseAddressId
      ]


-- | Construct a value of type 'ExecuteSearchSequenceResponse' (by applying it's required fields, if any)
mkExecuteSearchSequenceResponse
  :: ExecuteSearchSequenceResponse
mkExecuteSearchSequenceResponse =
  ExecuteSearchSequenceResponse
  { executeSearchSequenceResponseSequence = Nothing
  , executeSearchSequenceResponseLocation = Nothing
  , executeSearchSequenceResponseAddressId = Nothing
  }

-- ** ExecuteSearchTransactionResponse
-- | ExecuteSearchTransactionResponse
data ExecuteSearchTransactionResponse = ExecuteSearchTransactionResponse
  { executeSearchTransactionResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchTransactionResponseType :: !(Maybe Text) -- ^ "type" - The type of the transaction object returned
  , executeSearchTransactionResponseTransaction :: !(Maybe Transaction) -- ^ "transaction"
  , executeSearchTransactionResponseTimestamp :: !(Maybe DateTime) -- ^ "timestamp" - The unix time to read the object from
  , executeSearchTransactionResponseStatus :: !(Maybe Status) -- ^ "status"
  , executeSearchTransactionResponseExtraFields :: !(Maybe A.Value) -- ^ "extraFields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchTransactionResponse
instance A.FromJSON ExecuteSearchTransactionResponse where
  parseJSON = A.withObject "ExecuteSearchTransactionResponse" $ \o ->
    ExecuteSearchTransactionResponse
      <$> (o .:? "location")
      <*> (o .:? "type")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "status")
      <*> (o .:? "extraFields")

-- | ToJSON ExecuteSearchTransactionResponse
instance A.ToJSON ExecuteSearchTransactionResponse where
  toJSON ExecuteSearchTransactionResponse {..} =
   _omitNulls
      [ "location" .= executeSearchTransactionResponseLocation
      , "type" .= executeSearchTransactionResponseType
      , "transaction" .= executeSearchTransactionResponseTransaction
      , "timestamp" .= executeSearchTransactionResponseTimestamp
      , "status" .= executeSearchTransactionResponseStatus
      , "extraFields" .= executeSearchTransactionResponseExtraFields
      ]


-- | Construct a value of type 'ExecuteSearchTransactionResponse' (by applying it's required fields, if any)
mkExecuteSearchTransactionResponse
  :: ExecuteSearchTransactionResponse
mkExecuteSearchTransactionResponse =
  ExecuteSearchTransactionResponse
  { executeSearchTransactionResponseLocation = Nothing
  , executeSearchTransactionResponseType = Nothing
  , executeSearchTransactionResponseTransaction = Nothing
  , executeSearchTransactionResponseTimestamp = Nothing
  , executeSearchTransactionResponseStatus = Nothing
  , executeSearchTransactionResponseExtraFields = Nothing
  }

-- ** ExecuteSearchUTXOResponseSchema
-- | ExecuteSearchUTXOResponseSchema
data ExecuteSearchUTXOResponseSchema = ExecuteSearchUTXOResponseSchema
  { executeSearchUTXOResponseSchemaDestination :: !(Maybe [UTXODestination]) -- ^ "destination"
  , executeSearchUTXOResponseSchemaLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchUTXOResponseSchemaTimestamp :: !(Maybe UTXOTimestampSchema) -- ^ "timestamp"
  , executeSearchUTXOResponseSchemaStatus :: !(Maybe Status) -- ^ "status"
  , executeSearchUTXOResponseSchemaNativeData :: !(Maybe UTXONativeData) -- ^ "nativeData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchUTXOResponseSchema
instance A.FromJSON ExecuteSearchUTXOResponseSchema where
  parseJSON = A.withObject "ExecuteSearchUTXOResponseSchema" $ \o ->
    ExecuteSearchUTXOResponseSchema
      <$> (o .:? "destination")
      <*> (o .:? "location")
      <*> (o .:? "timestamp")
      <*> (o .:? "status")
      <*> (o .:? "nativeData")

-- | ToJSON ExecuteSearchUTXOResponseSchema
instance A.ToJSON ExecuteSearchUTXOResponseSchema where
  toJSON ExecuteSearchUTXOResponseSchema {..} =
   _omitNulls
      [ "destination" .= executeSearchUTXOResponseSchemaDestination
      , "location" .= executeSearchUTXOResponseSchemaLocation
      , "timestamp" .= executeSearchUTXOResponseSchemaTimestamp
      , "status" .= executeSearchUTXOResponseSchemaStatus
      , "nativeData" .= executeSearchUTXOResponseSchemaNativeData
      ]


-- | Construct a value of type 'ExecuteSearchUTXOResponseSchema' (by applying it's required fields, if any)
mkExecuteSearchUTXOResponseSchema
  :: ExecuteSearchUTXOResponseSchema
mkExecuteSearchUTXOResponseSchema =
  ExecuteSearchUTXOResponseSchema
  { executeSearchUTXOResponseSchemaDestination = Nothing
  , executeSearchUTXOResponseSchemaLocation = Nothing
  , executeSearchUTXOResponseSchemaTimestamp = Nothing
  , executeSearchUTXOResponseSchemaStatus = Nothing
  , executeSearchUTXOResponseSchemaNativeData = Nothing
  }

-- ** ExecuteSmartContractReadResponseSchema
-- | ExecuteSmartContractReadResponseSchema
data ExecuteSmartContractReadResponseSchema = ExecuteSmartContractReadResponseSchema
  { executeSmartContractReadResponseSchemaSmartContract :: !(Maybe SmartContractReadSchema) -- ^ "smartContract"
  , executeSmartContractReadResponseSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSmartContractReadResponseSchema
instance A.FromJSON ExecuteSmartContractReadResponseSchema where
  parseJSON = A.withObject "ExecuteSmartContractReadResponseSchema" $ \o ->
    ExecuteSmartContractReadResponseSchema
      <$> (o .:? "smartContract")
      <*> (o .:? "location")

-- | ToJSON ExecuteSmartContractReadResponseSchema
instance A.ToJSON ExecuteSmartContractReadResponseSchema where
  toJSON ExecuteSmartContractReadResponseSchema {..} =
   _omitNulls
      [ "smartContract" .= executeSmartContractReadResponseSchemaSmartContract
      , "location" .= executeSmartContractReadResponseSchemaLocation
      ]


-- | Construct a value of type 'ExecuteSmartContractReadResponseSchema' (by applying it's required fields, if any)
mkExecuteSmartContractReadResponseSchema
  :: ExecuteSmartContractReadResponseSchema
mkExecuteSmartContractReadResponseSchema =
  ExecuteSmartContractReadResponseSchema
  { executeSmartContractReadResponseSchemaSmartContract = Nothing
  , executeSmartContractReadResponseSchemaLocation = Nothing
  }

-- ** ExecuteTransactionRequest
-- | ExecuteTransactionRequest
data ExecuteTransactionRequest = ExecuteTransactionRequest
  { executeTransactionRequestRequestId :: !(Text) -- ^ /Required/ "requestId" - The ID assigned to a preparation request in Overledger
  , executeTransactionRequestSigned :: !(Text) -- ^ /Required/ "signed" - The raw data after transaction signing
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteTransactionRequest
instance A.FromJSON ExecuteTransactionRequest where
  parseJSON = A.withObject "ExecuteTransactionRequest" $ \o ->
    ExecuteTransactionRequest
      <$> (o .:  "requestId")
      <*> (o .:  "signed")

-- | ToJSON ExecuteTransactionRequest
instance A.ToJSON ExecuteTransactionRequest where
  toJSON ExecuteTransactionRequest {..} =
   _omitNulls
      [ "requestId" .= executeTransactionRequestRequestId
      , "signed" .= executeTransactionRequestSigned
      ]


-- | Construct a value of type 'ExecuteTransactionRequest' (by applying it's required fields, if any)
mkExecuteTransactionRequest
  :: Text -- ^ 'executeTransactionRequestRequestId': The ID assigned to a preparation request in Overledger
  -> Text -- ^ 'executeTransactionRequestSigned': The raw data after transaction signing
  -> ExecuteTransactionRequest
mkExecuteTransactionRequest executeTransactionRequestRequestId executeTransactionRequestSigned =
  ExecuteTransactionRequest
  { executeTransactionRequestRequestId
  , executeTransactionRequestSigned
  }

-- ** ExecuteTransactionResponse
-- | ExecuteTransactionResponse
data ExecuteTransactionResponse = ExecuteTransactionResponse
  { executeTransactionResponseUrgency :: !(Maybe Text) -- ^ "urgency"
  , executeTransactionResponseRequestId :: !(Maybe Text) -- ^ "requestId" - The ID assigned to a preparation request in Overledger
  , executeTransactionResponseOverledgerTransactionId :: !(Maybe Text) -- ^ "overledgerTransactionId"
  , executeTransactionResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeTransactionResponseType :: !(Maybe Text) -- ^ "type" - The type of the transaction executed
  , executeTransactionResponseTransactionId :: !(Maybe Text) -- ^ "transactionId" - The ID assigned by Overledger to a transaction submitted to a DLT via Overledger
  , executeTransactionResponseStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteTransactionResponse
instance A.FromJSON ExecuteTransactionResponse where
  parseJSON = A.withObject "ExecuteTransactionResponse" $ \o ->
    ExecuteTransactionResponse
      <$> (o .:? "urgency")
      <*> (o .:? "requestId")
      <*> (o .:? "overledgerTransactionId")
      <*> (o .:? "location")
      <*> (o .:? "type")
      <*> (o .:? "transactionId")
      <*> (o .:? "status")

-- | ToJSON ExecuteTransactionResponse
instance A.ToJSON ExecuteTransactionResponse where
  toJSON ExecuteTransactionResponse {..} =
   _omitNulls
      [ "urgency" .= executeTransactionResponseUrgency
      , "requestId" .= executeTransactionResponseRequestId
      , "overledgerTransactionId" .= executeTransactionResponseOverledgerTransactionId
      , "location" .= executeTransactionResponseLocation
      , "type" .= executeTransactionResponseType
      , "transactionId" .= executeTransactionResponseTransactionId
      , "status" .= executeTransactionResponseStatus
      ]


-- | Construct a value of type 'ExecuteTransactionResponse' (by applying it's required fields, if any)
mkExecuteTransactionResponse
  :: ExecuteTransactionResponse
mkExecuteTransactionResponse =
  ExecuteTransactionResponse
  { executeTransactionResponseUrgency = Nothing
  , executeTransactionResponseRequestId = Nothing
  , executeTransactionResponseOverledgerTransactionId = Nothing
  , executeTransactionResponseLocation = Nothing
  , executeTransactionResponseType = Nothing
  , executeTransactionResponseTransactionId = Nothing
  , executeTransactionResponseStatus = Nothing
  }

-- ** ExtraFields
-- | ExtraFields
data ExtraFields = ExtraFields
  { extraFieldsRequiredSignatures :: !(Maybe Double) -- ^ "requiredSignatures"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtraFields
instance A.FromJSON ExtraFields where
  parseJSON = A.withObject "ExtraFields" $ \o ->
    ExtraFields
      <$> (o .:? "requiredSignatures")

-- | ToJSON ExtraFields
instance A.ToJSON ExtraFields where
  toJSON ExtraFields {..} =
   _omitNulls
      [ "requiredSignatures" .= extraFieldsRequiredSignatures
      ]


-- | Construct a value of type 'ExtraFields' (by applying it's required fields, if any)
mkExtraFields
  :: ExtraFields
mkExtraFields =
  ExtraFields
  { extraFieldsRequiredSignatures = Nothing
  }

-- ** Fee
-- | Fee
data Fee = Fee
  { feeAmount :: !(Text) -- ^ /Required/ "amount" - The amount of a currency
  , feeUnit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Fee
instance A.FromJSON Fee where
  parseJSON = A.withObject "Fee" $ \o ->
    Fee
      <$> (o .:  "amount")
      <*> (o .:? "unit")

-- | ToJSON Fee
instance A.ToJSON Fee where
  toJSON Fee {..} =
   _omitNulls
      [ "amount" .= feeAmount
      , "unit" .= feeUnit
      ]


-- | Construct a value of type 'Fee' (by applying it's required fields, if any)
mkFee
  :: Text -- ^ 'feeAmount': The amount of a currency
  -> Fee
mkFee feeAmount =
  Fee
  { feeAmount
  , feeUnit = Nothing
  }

-- ** Function
-- | Function
data Function = Function
  { functionFunctionId :: !(Maybe Text) -- ^ "functionId"
  , functionCode :: !(Maybe Text) -- ^ "code"
  , functionName :: !(Maybe Text) -- ^ "name"
  , functionInputParameters :: !(Maybe [Parameter]) -- ^ "inputParameters"
  , functionOutputParameters :: !(Maybe [Parameter]) -- ^ "outputParameters"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Function
instance A.FromJSON Function where
  parseJSON = A.withObject "Function" $ \o ->
    Function
      <$> (o .:? "functionId")
      <*> (o .:? "code")
      <*> (o .:? "name")
      <*> (o .:? "inputParameters")
      <*> (o .:? "outputParameters")

-- | ToJSON Function
instance A.ToJSON Function where
  toJSON Function {..} =
   _omitNulls
      [ "functionId" .= functionFunctionId
      , "code" .= functionCode
      , "name" .= functionName
      , "inputParameters" .= functionInputParameters
      , "outputParameters" .= functionOutputParameters
      ]


-- | Construct a value of type 'Function' (by applying it's required fields, if any)
mkFunction
  :: Function
mkFunction =
  Function
  { functionFunctionId = Nothing
  , functionCode = Nothing
  , functionName = Nothing
  , functionInputParameters = Nothing
  , functionOutputParameters = Nothing
  }

-- ** InternalServerErrorSchema
-- | InternalServerErrorSchema
data InternalServerErrorSchema = InternalServerErrorSchema
  { internalServerErrorSchemaPath :: !(Maybe Text) -- ^ "path"
  , internalServerErrorSchemaError :: !(Maybe Text) -- ^ "error"
  , internalServerErrorSchemaMessage :: !(Maybe Text) -- ^ "message"
  , internalServerErrorSchemaTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  , internalServerErrorSchemaStatus :: !(Maybe Int) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InternalServerErrorSchema
instance A.FromJSON InternalServerErrorSchema where
  parseJSON = A.withObject "InternalServerErrorSchema" $ \o ->
    InternalServerErrorSchema
      <$> (o .:? "path")
      <*> (o .:? "error")
      <*> (o .:? "message")
      <*> (o .:? "timestamp")
      <*> (o .:? "status")

-- | ToJSON InternalServerErrorSchema
instance A.ToJSON InternalServerErrorSchema where
  toJSON InternalServerErrorSchema {..} =
   _omitNulls
      [ "path" .= internalServerErrorSchemaPath
      , "error" .= internalServerErrorSchemaError
      , "message" .= internalServerErrorSchemaMessage
      , "timestamp" .= internalServerErrorSchemaTimestamp
      , "status" .= internalServerErrorSchemaStatus
      ]


-- | Construct a value of type 'InternalServerErrorSchema' (by applying it's required fields, if any)
mkInternalServerErrorSchema
  :: InternalServerErrorSchema
mkInternalServerErrorSchema =
  InternalServerErrorSchema
  { internalServerErrorSchemaPath = Nothing
  , internalServerErrorSchemaError = Nothing
  , internalServerErrorSchemaMessage = Nothing
  , internalServerErrorSchemaTimestamp = Nothing
  , internalServerErrorSchemaStatus = Nothing
  }

-- ** LinkedBlocks
-- | LinkedBlocks
data LinkedBlocks = LinkedBlocks
  { linkedBlocksParent :: !(Maybe Text) -- ^ "parent"
  , linkedBlocksChild :: !(Maybe Text) -- ^ "child"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkedBlocks
instance A.FromJSON LinkedBlocks where
  parseJSON = A.withObject "LinkedBlocks" $ \o ->
    LinkedBlocks
      <$> (o .:? "parent")
      <*> (o .:? "child")

-- | ToJSON LinkedBlocks
instance A.ToJSON LinkedBlocks where
  toJSON LinkedBlocks {..} =
   _omitNulls
      [ "parent" .= linkedBlocksParent
      , "child" .= linkedBlocksChild
      ]


-- | Construct a value of type 'LinkedBlocks' (by applying it's required fields, if any)
mkLinkedBlocks
  :: LinkedBlocks
mkLinkedBlocks =
  LinkedBlocks
  { linkedBlocksParent = Nothing
  , linkedBlocksChild = Nothing
  }

-- ** ListSubscriptionResponseSchema
-- | ListSubscriptionResponseSchema
data ListSubscriptionResponseSchema = ListSubscriptionResponseSchema
  { listSubscriptionResponseSchemaSubscriptionDetails :: !(Maybe SubscriptionDetailsSchema) -- ^ "subscriptionDetails"
  , listSubscriptionResponseSchemaSubscribedTime :: !(Maybe DateTime) -- ^ "subscribedTime"
  , listSubscriptionResponseSchemaLastUpdatedTime :: !(Maybe DateTime) -- ^ "lastUpdatedTime"
  , listSubscriptionResponseSchemaCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  , listSubscriptionResponseSchemaSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  , listSubscriptionResponseSchemaType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListSubscriptionResponseSchema
instance A.FromJSON ListSubscriptionResponseSchema where
  parseJSON = A.withObject "ListSubscriptionResponseSchema" $ \o ->
    ListSubscriptionResponseSchema
      <$> (o .:? "subscriptionDetails")
      <*> (o .:? "subscribedTime")
      <*> (o .:? "lastUpdatedTime")
      <*> (o .:? "callbackUrl")
      <*> (o .:? "subscriptionId")
      <*> (o .:? "type")

-- | ToJSON ListSubscriptionResponseSchema
instance A.ToJSON ListSubscriptionResponseSchema where
  toJSON ListSubscriptionResponseSchema {..} =
   _omitNulls
      [ "subscriptionDetails" .= listSubscriptionResponseSchemaSubscriptionDetails
      , "subscribedTime" .= listSubscriptionResponseSchemaSubscribedTime
      , "lastUpdatedTime" .= listSubscriptionResponseSchemaLastUpdatedTime
      , "callbackUrl" .= listSubscriptionResponseSchemaCallbackUrl
      , "subscriptionId" .= listSubscriptionResponseSchemaSubscriptionId
      , "type" .= listSubscriptionResponseSchemaType
      ]


-- | Construct a value of type 'ListSubscriptionResponseSchema' (by applying it's required fields, if any)
mkListSubscriptionResponseSchema
  :: ListSubscriptionResponseSchema
mkListSubscriptionResponseSchema =
  ListSubscriptionResponseSchema
  { listSubscriptionResponseSchemaSubscriptionDetails = Nothing
  , listSubscriptionResponseSchemaSubscribedTime = Nothing
  , listSubscriptionResponseSchemaLastUpdatedTime = Nothing
  , listSubscriptionResponseSchemaCallbackUrl = Nothing
  , listSubscriptionResponseSchemaSubscriptionId = Nothing
  , listSubscriptionResponseSchemaType = Nothing
  }

-- ** Location
-- | Location
-- Unique reference to the ledger on a particular ledger network (optionally accessed from a particular node)
data Location = Location
  { locationTechnology :: !(Text) -- ^ /Required/ "technology" - The technology used by the desired network
  , locationNetwork :: !(Text) -- ^ /Required/ "network" - The network that the ledger resides on
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Location
instance A.FromJSON Location where
  parseJSON = A.withObject "Location" $ \o ->
    Location
      <$> (o .:  "technology")
      <*> (o .:  "network")

-- | ToJSON Location
instance A.ToJSON Location where
  toJSON Location {..} =
   _omitNulls
      [ "technology" .= locationTechnology
      , "network" .= locationNetwork
      ]


-- | Construct a value of type 'Location' (by applying it's required fields, if any)
mkLocation
  :: Text -- ^ 'locationTechnology': The technology used by the desired network
  -> Text -- ^ 'locationNetwork': The network that the ledger resides on
  -> Location
mkLocation locationTechnology locationNetwork =
  Location
  { locationTechnology
  , locationNetwork
  }

-- ** MonitorSmartContractEventParam
-- | MonitorSmartContractEventParam
data MonitorSmartContractEventParam = MonitorSmartContractEventParam
  { monitorSmartContractEventParamSelectedIntegerLength :: !(Maybe Text) -- ^ "selectedIntegerLength"
  , monitorSmartContractEventParamType :: !(Maybe Text) -- ^ "type"
  , monitorSmartContractEventParamValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MonitorSmartContractEventParam
instance A.FromJSON MonitorSmartContractEventParam where
  parseJSON = A.withObject "MonitorSmartContractEventParam" $ \o ->
    MonitorSmartContractEventParam
      <$> (o .:? "selectedIntegerLength")
      <*> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON MonitorSmartContractEventParam
instance A.ToJSON MonitorSmartContractEventParam where
  toJSON MonitorSmartContractEventParam {..} =
   _omitNulls
      [ "selectedIntegerLength" .= monitorSmartContractEventParamSelectedIntegerLength
      , "type" .= monitorSmartContractEventParamType
      , "value" .= monitorSmartContractEventParamValue
      ]


-- | Construct a value of type 'MonitorSmartContractEventParam' (by applying it's required fields, if any)
mkMonitorSmartContractEventParam
  :: MonitorSmartContractEventParam
mkMonitorSmartContractEventParam =
  MonitorSmartContractEventParam
  { monitorSmartContractEventParamSelectedIntegerLength = Nothing
  , monitorSmartContractEventParamType = Nothing
  , monitorSmartContractEventParamValue = Nothing
  }

-- ** MonitorSmartContractRequestSchema
-- | MonitorSmartContractRequestSchema
data MonitorSmartContractRequestSchema = MonitorSmartContractRequestSchema
  { monitorSmartContractRequestSchemaCallBackUrl :: !(Maybe Text) -- ^ "callBackURL"
  , monitorSmartContractRequestSchemaEventParams :: !(Maybe [MonitorSmartContractEventParam]) -- ^ "eventParams"
  , monitorSmartContractRequestSchemaEventName :: !(Maybe Text) -- ^ "eventName"
  , monitorSmartContractRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  , monitorSmartContractRequestSchemaSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MonitorSmartContractRequestSchema
instance A.FromJSON MonitorSmartContractRequestSchema where
  parseJSON = A.withObject "MonitorSmartContractRequestSchema" $ \o ->
    MonitorSmartContractRequestSchema
      <$> (o .:? "callBackURL")
      <*> (o .:? "eventParams")
      <*> (o .:? "eventName")
      <*> (o .:? "location")
      <*> (o .:? "smartContractId")

-- | ToJSON MonitorSmartContractRequestSchema
instance A.ToJSON MonitorSmartContractRequestSchema where
  toJSON MonitorSmartContractRequestSchema {..} =
   _omitNulls
      [ "callBackURL" .= monitorSmartContractRequestSchemaCallBackUrl
      , "eventParams" .= monitorSmartContractRequestSchemaEventParams
      , "eventName" .= monitorSmartContractRequestSchemaEventName
      , "location" .= monitorSmartContractRequestSchemaLocation
      , "smartContractId" .= monitorSmartContractRequestSchemaSmartContractId
      ]


-- | Construct a value of type 'MonitorSmartContractRequestSchema' (by applying it's required fields, if any)
mkMonitorSmartContractRequestSchema
  :: MonitorSmartContractRequestSchema
mkMonitorSmartContractRequestSchema =
  MonitorSmartContractRequestSchema
  { monitorSmartContractRequestSchemaCallBackUrl = Nothing
  , monitorSmartContractRequestSchemaEventParams = Nothing
  , monitorSmartContractRequestSchemaEventName = Nothing
  , monitorSmartContractRequestSchemaLocation = Nothing
  , monitorSmartContractRequestSchemaSmartContractId = Nothing
  }

-- ** Origin
-- | Origin
-- Where is this transaction coming from
data Origin = Origin
  { originSequence :: !(Maybe Text) -- ^ "sequence"
  , originOriginId :: !(Maybe Text) -- ^ "originId"
  , originSmartContract :: !(Maybe SmartContract) -- ^ "smartContract"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Origin
instance A.FromJSON Origin where
  parseJSON = A.withObject "Origin" $ \o ->
    Origin
      <$> (o .:? "sequence")
      <*> (o .:? "originId")
      <*> (o .:? "smartContract")

-- | ToJSON Origin
instance A.ToJSON Origin where
  toJSON Origin {..} =
   _omitNulls
      [ "sequence" .= originSequence
      , "originId" .= originOriginId
      , "smartContract" .= originSmartContract
      ]


-- | Construct a value of type 'Origin' (by applying it's required fields, if any)
mkOrigin
  :: Origin
mkOrigin =
  Origin
  { originSequence = Nothing
  , originOriginId = Nothing
  , originSmartContract = Nothing
  }

-- ** OriginPaymentSchema
-- | OriginPaymentSchema
-- Where is this transaction coming from
data OriginPaymentSchema = OriginPaymentSchema
  { originPaymentSchemaOriginId :: !(Maybe Text) -- ^ "originId" - Unique Identifier of the originator
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OriginPaymentSchema
instance A.FromJSON OriginPaymentSchema where
  parseJSON = A.withObject "OriginPaymentSchema" $ \o ->
    OriginPaymentSchema
      <$> (o .:? "originId")

-- | ToJSON OriginPaymentSchema
instance A.ToJSON OriginPaymentSchema where
  toJSON OriginPaymentSchema {..} =
   _omitNulls
      [ "originId" .= originPaymentSchemaOriginId
      ]


-- | Construct a value of type 'OriginPaymentSchema' (by applying it's required fields, if any)
mkOriginPaymentSchema
  :: OriginPaymentSchema
mkOriginPaymentSchema =
  OriginPaymentSchema
  { originPaymentSchemaOriginId = Nothing
  }

-- ** OriginTransferSchema
-- | OriginTransferSchema
data OriginTransferSchema = OriginTransferSchema
  { originTransferSchemaOriginId :: !(Maybe Text) -- ^ "originId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OriginTransferSchema
instance A.FromJSON OriginTransferSchema where
  parseJSON = A.withObject "OriginTransferSchema" $ \o ->
    OriginTransferSchema
      <$> (o .:? "originId")

-- | ToJSON OriginTransferSchema
instance A.ToJSON OriginTransferSchema where
  toJSON OriginTransferSchema {..} =
   _omitNulls
      [ "originId" .= originTransferSchemaOriginId
      ]


-- | Construct a value of type 'OriginTransferSchema' (by applying it's required fields, if any)
mkOriginTransferSchema
  :: OriginTransferSchema
mkOriginTransferSchema =
  OriginTransferSchema
  { originTransferSchemaOriginId = Nothing
  }

-- ** OverledgerTransactionResponseSchema
-- | OverledgerTransactionResponseSchema
data OverledgerTransactionResponseSchema = OverledgerTransactionResponseSchema
  { overledgerTransactionResponseSchemaClientId :: !(Maybe Text) -- ^ "clientId"
  , overledgerTransactionResponseSchemaRequestId :: !(Maybe Text) -- ^ "requestId"
  , overledgerTransactionResponseSchemaOverledgerTransactionId :: !(Maybe Text) -- ^ "overledgerTransactionId"
  , overledgerTransactionResponseSchemaLocation :: !(Maybe Location) -- ^ "location"
  , overledgerTransactionResponseSchemaTransactionHistory :: !(Maybe [Status]) -- ^ "transactionHistory"
  , overledgerTransactionResponseSchemaType :: !(Maybe Text) -- ^ "type"
  , overledgerTransactionResponseSchemaTransactionId :: !(Maybe Text) -- ^ "transactionId"
  , overledgerTransactionResponseSchemaStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OverledgerTransactionResponseSchema
instance A.FromJSON OverledgerTransactionResponseSchema where
  parseJSON = A.withObject "OverledgerTransactionResponseSchema" $ \o ->
    OverledgerTransactionResponseSchema
      <$> (o .:? "clientId")
      <*> (o .:? "requestId")
      <*> (o .:? "overledgerTransactionId")
      <*> (o .:? "location")
      <*> (o .:? "transactionHistory")
      <*> (o .:? "type")
      <*> (o .:? "transactionId")
      <*> (o .:? "status")

-- | ToJSON OverledgerTransactionResponseSchema
instance A.ToJSON OverledgerTransactionResponseSchema where
  toJSON OverledgerTransactionResponseSchema {..} =
   _omitNulls
      [ "clientId" .= overledgerTransactionResponseSchemaClientId
      , "requestId" .= overledgerTransactionResponseSchemaRequestId
      , "overledgerTransactionId" .= overledgerTransactionResponseSchemaOverledgerTransactionId
      , "location" .= overledgerTransactionResponseSchemaLocation
      , "transactionHistory" .= overledgerTransactionResponseSchemaTransactionHistory
      , "type" .= overledgerTransactionResponseSchemaType
      , "transactionId" .= overledgerTransactionResponseSchemaTransactionId
      , "status" .= overledgerTransactionResponseSchemaStatus
      ]


-- | Construct a value of type 'OverledgerTransactionResponseSchema' (by applying it's required fields, if any)
mkOverledgerTransactionResponseSchema
  :: OverledgerTransactionResponseSchema
mkOverledgerTransactionResponseSchema =
  OverledgerTransactionResponseSchema
  { overledgerTransactionResponseSchemaClientId = Nothing
  , overledgerTransactionResponseSchemaRequestId = Nothing
  , overledgerTransactionResponseSchemaOverledgerTransactionId = Nothing
  , overledgerTransactionResponseSchemaLocation = Nothing
  , overledgerTransactionResponseSchemaTransactionHistory = Nothing
  , overledgerTransactionResponseSchemaType = Nothing
  , overledgerTransactionResponseSchemaTransactionId = Nothing
  , overledgerTransactionResponseSchemaStatus = Nothing
  }

-- ** Parameter
-- | Parameter
data Parameter = Parameter
  { parameterType :: !(Maybe Text) -- ^ "type"
  , parameterValue :: !(Maybe A.Value) -- ^ "value"
  , parameterKey :: !(Maybe Text) -- ^ "key"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Parameter
instance A.FromJSON Parameter where
  parseJSON = A.withObject "Parameter" $ \o ->
    Parameter
      <$> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "key")

-- | ToJSON Parameter
instance A.ToJSON Parameter where
  toJSON Parameter {..} =
   _omitNulls
      [ "type" .= parameterType
      , "value" .= parameterValue
      , "key" .= parameterKey
      ]


-- | Construct a value of type 'Parameter' (by applying it's required fields, if any)
mkParameter
  :: Parameter
mkParameter =
  Parameter
  { parameterType = Nothing
  , parameterValue = Nothing
  , parameterKey = Nothing
  }

-- ** Payment
-- | Payment
data Payment = Payment
  { paymentAmount :: !(Maybe Text) -- ^ "amount" - The amount of a currency
  , paymentUnit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  , paymentIssuer :: !(Maybe Text) -- ^ "issuer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Payment
instance A.FromJSON Payment where
  parseJSON = A.withObject "Payment" $ \o ->
    Payment
      <$> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "issuer")

-- | ToJSON Payment
instance A.ToJSON Payment where
  toJSON Payment {..} =
   _omitNulls
      [ "amount" .= paymentAmount
      , "unit" .= paymentUnit
      , "issuer" .= paymentIssuer
      ]


-- | Construct a value of type 'Payment' (by applying it's required fields, if any)
mkPayment
  :: Payment
mkPayment =
  Payment
  { paymentAmount = Nothing
  , paymentUnit = Nothing
  , paymentIssuer = Nothing
  }

-- ** PaymentRequestDetailsSchema
-- | PaymentRequestDetailsSchema
data PaymentRequestDetailsSchema = PaymentRequestDetailsSchema
  { paymentRequestDetailsSchemaOverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  , paymentRequestDetailsSchemaOrigin :: !(Maybe [OriginPaymentSchema]) -- ^ "origin" - Where is this transaction coming from
  , paymentRequestDetailsSchemaDestination :: !(Maybe [DestinationPaymentSchema]) -- ^ "destination" - The Destination of this transaction
  , paymentRequestDetailsSchemaMessage :: !(Maybe Text) -- ^ "message" - Any text-based element of the data payload
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentRequestDetailsSchema
instance A.FromJSON PaymentRequestDetailsSchema where
  parseJSON = A.withObject "PaymentRequestDetailsSchema" $ \o ->
    PaymentRequestDetailsSchema
      <$> (o .:? "overledgerSigningType")
      <*> (o .:? "origin")
      <*> (o .:? "destination")
      <*> (o .:? "message")

-- | ToJSON PaymentRequestDetailsSchema
instance A.ToJSON PaymentRequestDetailsSchema where
  toJSON PaymentRequestDetailsSchema {..} =
   _omitNulls
      [ "overledgerSigningType" .= paymentRequestDetailsSchemaOverledgerSigningType
      , "origin" .= paymentRequestDetailsSchemaOrigin
      , "destination" .= paymentRequestDetailsSchemaDestination
      , "message" .= paymentRequestDetailsSchemaMessage
      ]


-- | Construct a value of type 'PaymentRequestDetailsSchema' (by applying it's required fields, if any)
mkPaymentRequestDetailsSchema
  :: PaymentRequestDetailsSchema
mkPaymentRequestDetailsSchema =
  PaymentRequestDetailsSchema
  { paymentRequestDetailsSchemaOverledgerSigningType = Nothing
  , paymentRequestDetailsSchemaOrigin = Nothing
  , paymentRequestDetailsSchemaDestination = Nothing
  , paymentRequestDetailsSchemaMessage = Nothing
  }

-- ** PaymentSchema
-- | PaymentSchema
data PaymentSchema = PaymentSchema
  { paymentSchemaAmount :: !(Text) -- ^ /Required/ "amount" - The amount of a currency
  , paymentSchemaUnit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentSchema
instance A.FromJSON PaymentSchema where
  parseJSON = A.withObject "PaymentSchema" $ \o ->
    PaymentSchema
      <$> (o .:  "amount")
      <*> (o .:? "unit")

-- | ToJSON PaymentSchema
instance A.ToJSON PaymentSchema where
  toJSON PaymentSchema {..} =
   _omitNulls
      [ "amount" .= paymentSchemaAmount
      , "unit" .= paymentSchemaUnit
      ]


-- | Construct a value of type 'PaymentSchema' (by applying it's required fields, if any)
mkPaymentSchema
  :: Text -- ^ 'paymentSchemaAmount': The amount of a currency
  -> PaymentSchema
mkPaymentSchema paymentSchemaAmount =
  PaymentSchema
  { paymentSchemaAmount
  , paymentSchemaUnit = Nothing
  }

-- ** PrepareNativeTransactionRequestSchema
-- | PrepareNativeTransactionRequestSchema
data PrepareNativeTransactionRequestSchema = PrepareNativeTransactionRequestSchema
  { prepareNativeTransactionRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  , prepareNativeTransactionRequestSchemaType :: !(Maybe Text) -- ^ "type" - The type of the object
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareNativeTransactionRequestSchema
instance A.FromJSON PrepareNativeTransactionRequestSchema where
  parseJSON = A.withObject "PrepareNativeTransactionRequestSchema" $ \o ->
    PrepareNativeTransactionRequestSchema
      <$> (o .:? "location")
      <*> (o .:? "type")

-- | ToJSON PrepareNativeTransactionRequestSchema
instance A.ToJSON PrepareNativeTransactionRequestSchema where
  toJSON PrepareNativeTransactionRequestSchema {..} =
   _omitNulls
      [ "location" .= prepareNativeTransactionRequestSchemaLocation
      , "type" .= prepareNativeTransactionRequestSchemaType
      ]


-- | Construct a value of type 'PrepareNativeTransactionRequestSchema' (by applying it's required fields, if any)
mkPrepareNativeTransactionRequestSchema
  :: PrepareNativeTransactionRequestSchema
mkPrepareNativeTransactionRequestSchema =
  PrepareNativeTransactionRequestSchema
  { prepareNativeTransactionRequestSchemaLocation = Nothing
  , prepareNativeTransactionRequestSchemaType = Nothing
  }

-- ** PreparePaymentTransactionRequestSchema
-- | PreparePaymentTransactionRequestSchema
data PreparePaymentTransactionRequestSchema = PreparePaymentTransactionRequestSchema
  { preparePaymentTransactionRequestSchemaUrgency :: !(Maybe Text) -- ^ "urgency"
  , preparePaymentTransactionRequestSchemaRequestDetails :: !(Maybe PaymentRequestDetailsSchema) -- ^ "requestDetails"
  , preparePaymentTransactionRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  , preparePaymentTransactionRequestSchemaType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PreparePaymentTransactionRequestSchema
instance A.FromJSON PreparePaymentTransactionRequestSchema where
  parseJSON = A.withObject "PreparePaymentTransactionRequestSchema" $ \o ->
    PreparePaymentTransactionRequestSchema
      <$> (o .:? "urgency")
      <*> (o .:? "requestDetails")
      <*> (o .:? "location")
      <*> (o .:? "type")

-- | ToJSON PreparePaymentTransactionRequestSchema
instance A.ToJSON PreparePaymentTransactionRequestSchema where
  toJSON PreparePaymentTransactionRequestSchema {..} =
   _omitNulls
      [ "urgency" .= preparePaymentTransactionRequestSchemaUrgency
      , "requestDetails" .= preparePaymentTransactionRequestSchemaRequestDetails
      , "location" .= preparePaymentTransactionRequestSchemaLocation
      , "type" .= preparePaymentTransactionRequestSchemaType
      ]


-- | Construct a value of type 'PreparePaymentTransactionRequestSchema' (by applying it's required fields, if any)
mkPreparePaymentTransactionRequestSchema
  :: PreparePaymentTransactionRequestSchema
mkPreparePaymentTransactionRequestSchema =
  PreparePaymentTransactionRequestSchema
  { preparePaymentTransactionRequestSchemaUrgency = Nothing
  , preparePaymentTransactionRequestSchemaRequestDetails = Nothing
  , preparePaymentTransactionRequestSchemaLocation = Nothing
  , preparePaymentTransactionRequestSchemaType = Nothing
  }

-- ** PrepareSearchResponseSchema
-- | PrepareSearchResponseSchema
data PrepareSearchResponseSchema = PrepareSearchResponseSchema
  { prepareSearchResponseSchemaGatewayFee :: !(Maybe Fee) -- ^ "gatewayFee"
  , prepareSearchResponseSchemaRequestId :: !(Maybe Text) -- ^ "requestId" - The ID assigned to a preparation request in Overledger
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareSearchResponseSchema
instance A.FromJSON PrepareSearchResponseSchema where
  parseJSON = A.withObject "PrepareSearchResponseSchema" $ \o ->
    PrepareSearchResponseSchema
      <$> (o .:? "gatewayFee")
      <*> (o .:? "requestId")

-- | ToJSON PrepareSearchResponseSchema
instance A.ToJSON PrepareSearchResponseSchema where
  toJSON PrepareSearchResponseSchema {..} =
   _omitNulls
      [ "gatewayFee" .= prepareSearchResponseSchemaGatewayFee
      , "requestId" .= prepareSearchResponseSchemaRequestId
      ]


-- | Construct a value of type 'PrepareSearchResponseSchema' (by applying it's required fields, if any)
mkPrepareSearchResponseSchema
  :: PrepareSearchResponseSchema
mkPrepareSearchResponseSchema =
  PrepareSearchResponseSchema
  { prepareSearchResponseSchemaGatewayFee = Nothing
  , prepareSearchResponseSchemaRequestId = Nothing
  }

-- ** PrepareSearchSchema
-- | PrepareSearchSchema
data PrepareSearchSchema = PrepareSearchSchema
  { prepareSearchSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareSearchSchema
instance A.FromJSON PrepareSearchSchema where
  parseJSON = A.withObject "PrepareSearchSchema" $ \o ->
    PrepareSearchSchema
      <$> (o .:? "location")

-- | ToJSON PrepareSearchSchema
instance A.ToJSON PrepareSearchSchema where
  toJSON PrepareSearchSchema {..} =
   _omitNulls
      [ "location" .= prepareSearchSchemaLocation
      ]


-- | Construct a value of type 'PrepareSearchSchema' (by applying it's required fields, if any)
mkPrepareSearchSchema
  :: PrepareSearchSchema
mkPrepareSearchSchema =
  PrepareSearchSchema
  { prepareSearchSchemaLocation = Nothing
  }

-- ** PrepareSearchSmartContractRequestSchema
-- | PrepareSearchSmartContractRequestSchema
data PrepareSearchSmartContractRequestSchema = PrepareSearchSmartContractRequestSchema
  { prepareSearchSmartContractRequestSchemaRequestDetails :: !(Maybe SmartContractSearchRequestDetails) -- ^ "requestDetails"
  , prepareSearchSmartContractRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareSearchSmartContractRequestSchema
instance A.FromJSON PrepareSearchSmartContractRequestSchema where
  parseJSON = A.withObject "PrepareSearchSmartContractRequestSchema" $ \o ->
    PrepareSearchSmartContractRequestSchema
      <$> (o .:? "requestDetails")
      <*> (o .:? "location")

-- | ToJSON PrepareSearchSmartContractRequestSchema
instance A.ToJSON PrepareSearchSmartContractRequestSchema where
  toJSON PrepareSearchSmartContractRequestSchema {..} =
   _omitNulls
      [ "requestDetails" .= prepareSearchSmartContractRequestSchemaRequestDetails
      , "location" .= prepareSearchSmartContractRequestSchemaLocation
      ]


-- | Construct a value of type 'PrepareSearchSmartContractRequestSchema' (by applying it's required fields, if any)
mkPrepareSearchSmartContractRequestSchema
  :: PrepareSearchSmartContractRequestSchema
mkPrepareSearchSmartContractRequestSchema =
  PrepareSearchSmartContractRequestSchema
  { prepareSearchSmartContractRequestSchemaRequestDetails = Nothing
  , prepareSearchSmartContractRequestSchemaLocation = Nothing
  }

-- ** PrepareTransactionResponse
-- | PrepareTransactionResponse
data PrepareTransactionResponse = PrepareTransactionResponse
  { prepareTransactionResponseGatewayFee :: !(Maybe Fee) -- ^ "gatewayFee"
  , prepareTransactionResponseRequestId :: !(Maybe Text) -- ^ "requestId" - The ID assigned to a preparation request in Overledger
  , prepareTransactionResponseDltFee :: !(Maybe Fee) -- ^ "dltFee"
  , prepareTransactionResponseNativeData :: !(Maybe A.Value) -- ^ "nativeData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareTransactionResponse
instance A.FromJSON PrepareTransactionResponse where
  parseJSON = A.withObject "PrepareTransactionResponse" $ \o ->
    PrepareTransactionResponse
      <$> (o .:? "gatewayFee")
      <*> (o .:? "requestId")
      <*> (o .:? "dltFee")
      <*> (o .:? "nativeData")

-- | ToJSON PrepareTransactionResponse
instance A.ToJSON PrepareTransactionResponse where
  toJSON PrepareTransactionResponse {..} =
   _omitNulls
      [ "gatewayFee" .= prepareTransactionResponseGatewayFee
      , "requestId" .= prepareTransactionResponseRequestId
      , "dltFee" .= prepareTransactionResponseDltFee
      , "nativeData" .= prepareTransactionResponseNativeData
      ]


-- | Construct a value of type 'PrepareTransactionResponse' (by applying it's required fields, if any)
mkPrepareTransactionResponse
  :: PrepareTransactionResponse
mkPrepareTransactionResponse =
  PrepareTransactionResponse
  { prepareTransactionResponseGatewayFee = Nothing
  , prepareTransactionResponseRequestId = Nothing
  , prepareTransactionResponseDltFee = Nothing
  , prepareTransactionResponseNativeData = Nothing
  }

-- ** PrepareTransactionSmartContractInvokeRequestSchema
-- | PrepareTransactionSmartContractInvokeRequestSchema
data PrepareTransactionSmartContractInvokeRequestSchema = PrepareTransactionSmartContractInvokeRequestSchema
  { prepareTransactionSmartContractInvokeRequestSchemaUrgency :: !(Maybe Text) -- ^ "urgency"
  , prepareTransactionSmartContractInvokeRequestSchemaRequestDetails :: !(Maybe SmartContractInvokeRequestDetailsSchema) -- ^ "requestDetails"
  , prepareTransactionSmartContractInvokeRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  , prepareTransactionSmartContractInvokeRequestSchemaType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareTransactionSmartContractInvokeRequestSchema
instance A.FromJSON PrepareTransactionSmartContractInvokeRequestSchema where
  parseJSON = A.withObject "PrepareTransactionSmartContractInvokeRequestSchema" $ \o ->
    PrepareTransactionSmartContractInvokeRequestSchema
      <$> (o .:? "urgency")
      <*> (o .:? "requestDetails")
      <*> (o .:? "location")
      <*> (o .:? "type")

-- | ToJSON PrepareTransactionSmartContractInvokeRequestSchema
instance A.ToJSON PrepareTransactionSmartContractInvokeRequestSchema where
  toJSON PrepareTransactionSmartContractInvokeRequestSchema {..} =
   _omitNulls
      [ "urgency" .= prepareTransactionSmartContractInvokeRequestSchemaUrgency
      , "requestDetails" .= prepareTransactionSmartContractInvokeRequestSchemaRequestDetails
      , "location" .= prepareTransactionSmartContractInvokeRequestSchemaLocation
      , "type" .= prepareTransactionSmartContractInvokeRequestSchemaType
      ]


-- | Construct a value of type 'PrepareTransactionSmartContractInvokeRequestSchema' (by applying it's required fields, if any)
mkPrepareTransactionSmartContractInvokeRequestSchema
  :: PrepareTransactionSmartContractInvokeRequestSchema
mkPrepareTransactionSmartContractInvokeRequestSchema =
  PrepareTransactionSmartContractInvokeRequestSchema
  { prepareTransactionSmartContractInvokeRequestSchemaUrgency = Nothing
  , prepareTransactionSmartContractInvokeRequestSchemaRequestDetails = Nothing
  , prepareTransactionSmartContractInvokeRequestSchemaLocation = Nothing
  , prepareTransactionSmartContractInvokeRequestSchemaType = Nothing
  }

-- ** PrepareTransferTransactionRequestSchema
-- | PrepareTransferTransactionRequestSchema
data PrepareTransferTransactionRequestSchema = PrepareTransferTransactionRequestSchema
  { prepareTransferTransactionRequestSchemaUrgency :: !(Maybe Text) -- ^ "urgency"
  , prepareTransferTransactionRequestSchemaRequestDetails :: !(Maybe TransferRequestDetailsSchema) -- ^ "requestDetails"
  , prepareTransferTransactionRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  , prepareTransferTransactionRequestSchemaType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareTransferTransactionRequestSchema
instance A.FromJSON PrepareTransferTransactionRequestSchema where
  parseJSON = A.withObject "PrepareTransferTransactionRequestSchema" $ \o ->
    PrepareTransferTransactionRequestSchema
      <$> (o .:? "urgency")
      <*> (o .:? "requestDetails")
      <*> (o .:? "location")
      <*> (o .:? "type")

-- | ToJSON PrepareTransferTransactionRequestSchema
instance A.ToJSON PrepareTransferTransactionRequestSchema where
  toJSON PrepareTransferTransactionRequestSchema {..} =
   _omitNulls
      [ "urgency" .= prepareTransferTransactionRequestSchemaUrgency
      , "requestDetails" .= prepareTransferTransactionRequestSchemaRequestDetails
      , "location" .= prepareTransferTransactionRequestSchemaLocation
      , "type" .= prepareTransferTransactionRequestSchemaType
      ]


-- | Construct a value of type 'PrepareTransferTransactionRequestSchema' (by applying it's required fields, if any)
mkPrepareTransferTransactionRequestSchema
  :: PrepareTransferTransactionRequestSchema
mkPrepareTransferTransactionRequestSchema =
  PrepareTransferTransactionRequestSchema
  { prepareTransferTransactionRequestSchemaUrgency = Nothing
  , prepareTransferTransactionRequestSchemaRequestDetails = Nothing
  , prepareTransferTransactionRequestSchemaLocation = Nothing
  , prepareTransferTransactionRequestSchemaType = Nothing
  }

-- ** ResourceMonitoredAddressDetails
-- | ResourceMonitoredAddressDetails
data ResourceMonitoredAddressDetails = ResourceMonitoredAddressDetails
  { resourceMonitoredAddressDetailsAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoredAddressDetails
instance A.FromJSON ResourceMonitoredAddressDetails where
  parseJSON = A.withObject "ResourceMonitoredAddressDetails" $ \o ->
    ResourceMonitoredAddressDetails
      <$> (o .:? "addressId")

-- | ToJSON ResourceMonitoredAddressDetails
instance A.ToJSON ResourceMonitoredAddressDetails where
  toJSON ResourceMonitoredAddressDetails {..} =
   _omitNulls
      [ "addressId" .= resourceMonitoredAddressDetailsAddressId
      ]


-- | Construct a value of type 'ResourceMonitoredAddressDetails' (by applying it's required fields, if any)
mkResourceMonitoredAddressDetails
  :: ResourceMonitoredAddressDetails
mkResourceMonitoredAddressDetails =
  ResourceMonitoredAddressDetails
  { resourceMonitoredAddressDetailsAddressId = Nothing
  }

-- ** ResourceMonitoringAddressDetails
-- | ResourceMonitoringAddressDetails
data ResourceMonitoringAddressDetails = ResourceMonitoringAddressDetails
  { resourceMonitoringAddressDetailsAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringAddressDetails
instance A.FromJSON ResourceMonitoringAddressDetails where
  parseJSON = A.withObject "ResourceMonitoringAddressDetails" $ \o ->
    ResourceMonitoringAddressDetails
      <$> (o .:? "addressId")

-- | ToJSON ResourceMonitoringAddressDetails
instance A.ToJSON ResourceMonitoringAddressDetails where
  toJSON ResourceMonitoringAddressDetails {..} =
   _omitNulls
      [ "addressId" .= resourceMonitoringAddressDetailsAddressId
      ]


-- | Construct a value of type 'ResourceMonitoringAddressDetails' (by applying it's required fields, if any)
mkResourceMonitoringAddressDetails
  :: ResourceMonitoringAddressDetails
mkResourceMonitoringAddressDetails =
  ResourceMonitoringAddressDetails
  { resourceMonitoringAddressDetailsAddressId = Nothing
  }

-- ** ResourceMonitoringAddressSchema
-- | ResourceMonitoringAddressSchema
data ResourceMonitoringAddressSchema = ResourceMonitoringAddressSchema
  { resourceMonitoringAddressSchemaAddressMonitoringDetails :: !(Maybe ResourceMonitoringAddressDetails) -- ^ "addressMonitoringDetails"
  , resourceMonitoringAddressSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringAddressSchema
instance A.FromJSON ResourceMonitoringAddressSchema where
  parseJSON = A.withObject "ResourceMonitoringAddressSchema" $ \o ->
    ResourceMonitoringAddressSchema
      <$> (o .:? "addressMonitoringDetails")
      <*> (o .:? "resourceMonitoring")

-- | ToJSON ResourceMonitoringAddressSchema
instance A.ToJSON ResourceMonitoringAddressSchema where
  toJSON ResourceMonitoringAddressSchema {..} =
   _omitNulls
      [ "addressMonitoringDetails" .= resourceMonitoringAddressSchemaAddressMonitoringDetails
      , "resourceMonitoring" .= resourceMonitoringAddressSchemaResourceMonitoring
      ]


-- | Construct a value of type 'ResourceMonitoringAddressSchema' (by applying it's required fields, if any)
mkResourceMonitoringAddressSchema
  :: ResourceMonitoringAddressSchema
mkResourceMonitoringAddressSchema =
  ResourceMonitoringAddressSchema
  { resourceMonitoringAddressSchemaAddressMonitoringDetails = Nothing
  , resourceMonitoringAddressSchemaResourceMonitoring = Nothing
  }

-- ** ResourceMonitoringDetails
-- | ResourceMonitoringDetails
data ResourceMonitoringDetails = ResourceMonitoringDetails
  { resourceMonitoringDetailsResourceMonitoringId :: !(Maybe Text) -- ^ "resourceMonitoringId"
  , resourceMonitoringDetailsLocation :: !(Maybe Location) -- ^ "location"
  , resourceMonitoringDetailsType :: !(Maybe Text) -- ^ "type"
  , resourceMonitoringDetailsTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  , resourceMonitoringDetailsStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringDetails
instance A.FromJSON ResourceMonitoringDetails where
  parseJSON = A.withObject "ResourceMonitoringDetails" $ \o ->
    ResourceMonitoringDetails
      <$> (o .:? "resourceMonitoringId")
      <*> (o .:? "location")
      <*> (o .:? "type")
      <*> (o .:? "timestamp")
      <*> (o .:? "status")

-- | ToJSON ResourceMonitoringDetails
instance A.ToJSON ResourceMonitoringDetails where
  toJSON ResourceMonitoringDetails {..} =
   _omitNulls
      [ "resourceMonitoringId" .= resourceMonitoringDetailsResourceMonitoringId
      , "location" .= resourceMonitoringDetailsLocation
      , "type" .= resourceMonitoringDetailsType
      , "timestamp" .= resourceMonitoringDetailsTimestamp
      , "status" .= resourceMonitoringDetailsStatus
      ]


-- | Construct a value of type 'ResourceMonitoringDetails' (by applying it's required fields, if any)
mkResourceMonitoringDetails
  :: ResourceMonitoringDetails
mkResourceMonitoringDetails =
  ResourceMonitoringDetails
  { resourceMonitoringDetailsResourceMonitoringId = Nothing
  , resourceMonitoringDetailsLocation = Nothing
  , resourceMonitoringDetailsType = Nothing
  , resourceMonitoringDetailsTimestamp = Nothing
  , resourceMonitoringDetailsStatus = Nothing
  }

-- ** ResourceMonitoringSmartContractEventDetails
-- | ResourceMonitoringSmartContractEventDetails
data ResourceMonitoringSmartContractEventDetails = ResourceMonitoringSmartContractEventDetails
  { resourceMonitoringSmartContractEventDetailsEventName :: !(Maybe Text) -- ^ "eventName"
  , resourceMonitoringSmartContractEventDetailsEventParameters :: !(Maybe Text) -- ^ "eventParameters"
  , resourceMonitoringSmartContractEventDetailsSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringSmartContractEventDetails
instance A.FromJSON ResourceMonitoringSmartContractEventDetails where
  parseJSON = A.withObject "ResourceMonitoringSmartContractEventDetails" $ \o ->
    ResourceMonitoringSmartContractEventDetails
      <$> (o .:? "eventName")
      <*> (o .:? "eventParameters")
      <*> (o .:? "smartContractId")

-- | ToJSON ResourceMonitoringSmartContractEventDetails
instance A.ToJSON ResourceMonitoringSmartContractEventDetails where
  toJSON ResourceMonitoringSmartContractEventDetails {..} =
   _omitNulls
      [ "eventName" .= resourceMonitoringSmartContractEventDetailsEventName
      , "eventParameters" .= resourceMonitoringSmartContractEventDetailsEventParameters
      , "smartContractId" .= resourceMonitoringSmartContractEventDetailsSmartContractId
      ]


-- | Construct a value of type 'ResourceMonitoringSmartContractEventDetails' (by applying it's required fields, if any)
mkResourceMonitoringSmartContractEventDetails
  :: ResourceMonitoringSmartContractEventDetails
mkResourceMonitoringSmartContractEventDetails =
  ResourceMonitoringSmartContractEventDetails
  { resourceMonitoringSmartContractEventDetailsEventName = Nothing
  , resourceMonitoringSmartContractEventDetailsEventParameters = Nothing
  , resourceMonitoringSmartContractEventDetailsSmartContractId = Nothing
  }

-- ** ResourceMonitoringSubscription
-- | ResourceMonitoringSubscription
data ResourceMonitoringSubscription = ResourceMonitoringSubscription
  { resourceMonitoringSubscriptionCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  , resourceMonitoringSubscriptionSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  , resourceMonitoringSubscriptionType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringSubscription
instance A.FromJSON ResourceMonitoringSubscription where
  parseJSON = A.withObject "ResourceMonitoringSubscription" $ \o ->
    ResourceMonitoringSubscription
      <$> (o .:? "callbackUrl")
      <*> (o .:? "subscriptionId")
      <*> (o .:? "type")

-- | ToJSON ResourceMonitoringSubscription
instance A.ToJSON ResourceMonitoringSubscription where
  toJSON ResourceMonitoringSubscription {..} =
   _omitNulls
      [ "callbackUrl" .= resourceMonitoringSubscriptionCallbackUrl
      , "subscriptionId" .= resourceMonitoringSubscriptionSubscriptionId
      , "type" .= resourceMonitoringSubscriptionType
      ]


-- | Construct a value of type 'ResourceMonitoringSubscription' (by applying it's required fields, if any)
mkResourceMonitoringSubscription
  :: ResourceMonitoringSubscription
mkResourceMonitoringSubscription =
  ResourceMonitoringSubscription
  { resourceMonitoringSubscriptionCallbackUrl = Nothing
  , resourceMonitoringSubscriptionSubscriptionId = Nothing
  , resourceMonitoringSubscriptionType = Nothing
  }

-- ** ResourceMonitoringSubscriptionDetails
-- | ResourceMonitoringSubscriptionDetails
data ResourceMonitoringSubscriptionDetails = ResourceMonitoringSubscriptionDetails
  { resourceMonitoringSubscriptionDetailsIds :: !(Maybe [Text]) -- ^ "ids"
  , resourceMonitoringSubscriptionDetailsStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringSubscriptionDetails
instance A.FromJSON ResourceMonitoringSubscriptionDetails where
  parseJSON = A.withObject "ResourceMonitoringSubscriptionDetails" $ \o ->
    ResourceMonitoringSubscriptionDetails
      <$> (o .:? "ids")
      <*> (o .:? "status")

-- | ToJSON ResourceMonitoringSubscriptionDetails
instance A.ToJSON ResourceMonitoringSubscriptionDetails where
  toJSON ResourceMonitoringSubscriptionDetails {..} =
   _omitNulls
      [ "ids" .= resourceMonitoringSubscriptionDetailsIds
      , "status" .= resourceMonitoringSubscriptionDetailsStatus
      ]


-- | Construct a value of type 'ResourceMonitoringSubscriptionDetails' (by applying it's required fields, if any)
mkResourceMonitoringSubscriptionDetails
  :: ResourceMonitoringSubscriptionDetails
mkResourceMonitoringSubscriptionDetails =
  ResourceMonitoringSubscriptionDetails
  { resourceMonitoringSubscriptionDetailsIds = Nothing
  , resourceMonitoringSubscriptionDetailsStatus = Nothing
  }

-- ** ScriptPubKey
-- | ScriptPubKey
data ScriptPubKey = ScriptPubKey
  { scriptPubKeyAddresses :: !(Maybe [Text]) -- ^ "addresses"
  , scriptPubKeyAsm :: !(Maybe Text) -- ^ "asm"
  , scriptPubKeyHex :: !(Maybe Text) -- ^ "hex"
  , scriptPubKeyType :: !(Maybe Text) -- ^ "type"
  , scriptPubKeyReqSigs :: !(Maybe Text) -- ^ "reqSigs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScriptPubKey
instance A.FromJSON ScriptPubKey where
  parseJSON = A.withObject "ScriptPubKey" $ \o ->
    ScriptPubKey
      <$> (o .:? "addresses")
      <*> (o .:? "asm")
      <*> (o .:? "hex")
      <*> (o .:? "type")
      <*> (o .:? "reqSigs")

-- | ToJSON ScriptPubKey
instance A.ToJSON ScriptPubKey where
  toJSON ScriptPubKey {..} =
   _omitNulls
      [ "addresses" .= scriptPubKeyAddresses
      , "asm" .= scriptPubKeyAsm
      , "hex" .= scriptPubKeyHex
      , "type" .= scriptPubKeyType
      , "reqSigs" .= scriptPubKeyReqSigs
      ]


-- | Construct a value of type 'ScriptPubKey' (by applying it's required fields, if any)
mkScriptPubKey
  :: ScriptPubKey
mkScriptPubKey =
  ScriptPubKey
  { scriptPubKeyAddresses = Nothing
  , scriptPubKeyAsm = Nothing
  , scriptPubKeyHex = Nothing
  , scriptPubKeyType = Nothing
  , scriptPubKeyReqSigs = Nothing
  }

-- ** SmartContract
-- | SmartContract
-- Computer program storage in a DLT system where the outcome is recorded on the distributed ledger
data SmartContract = SmartContract
  { smartContractFunction :: !(Maybe Function) -- ^ "function"
  , smartContractDetail :: !(Maybe Text) -- ^ "detail"
  , smartContractType :: !(Maybe Text) -- ^ "type" - Information on the object type
  , smartContractSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  , smartContractExtraFields :: !(Maybe A.Value) -- ^ "extraFields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContract
instance A.FromJSON SmartContract where
  parseJSON = A.withObject "SmartContract" $ \o ->
    SmartContract
      <$> (o .:? "function")
      <*> (o .:? "detail")
      <*> (o .:? "type")
      <*> (o .:? "smartContractId")
      <*> (o .:? "extraFields")

-- | ToJSON SmartContract
instance A.ToJSON SmartContract where
  toJSON SmartContract {..} =
   _omitNulls
      [ "function" .= smartContractFunction
      , "detail" .= smartContractDetail
      , "type" .= smartContractType
      , "smartContractId" .= smartContractSmartContractId
      , "extraFields" .= smartContractExtraFields
      ]


-- | Construct a value of type 'SmartContract' (by applying it's required fields, if any)
mkSmartContract
  :: SmartContract
mkSmartContract =
  SmartContract
  { smartContractFunction = Nothing
  , smartContractDetail = Nothing
  , smartContractType = Nothing
  , smartContractSmartContractId = Nothing
  , smartContractExtraFields = Nothing
  }

-- ** SmartContractDestinationSchema
-- | SmartContractDestinationSchema
data SmartContractDestinationSchema = SmartContractDestinationSchema
  { smartContractDestinationSchemaSmartContract :: !(Maybe SmartContractSchema) -- ^ "smartContract"
  , smartContractDestinationSchemaPayment :: !(Maybe SmartContractPaymentSchema) -- ^ "payment"
  , smartContractDestinationSchemaDestinationId :: !(Maybe Text) -- ^ "destinationId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractDestinationSchema
instance A.FromJSON SmartContractDestinationSchema where
  parseJSON = A.withObject "SmartContractDestinationSchema" $ \o ->
    SmartContractDestinationSchema
      <$> (o .:? "smartContract")
      <*> (o .:? "payment")
      <*> (o .:? "destinationId")

-- | ToJSON SmartContractDestinationSchema
instance A.ToJSON SmartContractDestinationSchema where
  toJSON SmartContractDestinationSchema {..} =
   _omitNulls
      [ "smartContract" .= smartContractDestinationSchemaSmartContract
      , "payment" .= smartContractDestinationSchemaPayment
      , "destinationId" .= smartContractDestinationSchemaDestinationId
      ]


-- | Construct a value of type 'SmartContractDestinationSchema' (by applying it's required fields, if any)
mkSmartContractDestinationSchema
  :: SmartContractDestinationSchema
mkSmartContractDestinationSchema =
  SmartContractDestinationSchema
  { smartContractDestinationSchemaSmartContract = Nothing
  , smartContractDestinationSchemaPayment = Nothing
  , smartContractDestinationSchemaDestinationId = Nothing
  }

-- ** SmartContractEventHistory
-- | SmartContractEventHistory
data SmartContractEventHistory = SmartContractEventHistory
  { smartContractEventHistoryEventId :: !(Maybe Text) -- ^ "eventId"
  , smartContractEventHistoryEventName :: !(Maybe Text) -- ^ "eventName"
  , smartContractEventHistoryEventParameters :: !(Maybe Text) -- ^ "eventParameters"
  , smartContractEventHistoryTransactionId :: !(Maybe Text) -- ^ "transactionId"
  , smartContractEventHistoryTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractEventHistory
instance A.FromJSON SmartContractEventHistory where
  parseJSON = A.withObject "SmartContractEventHistory" $ \o ->
    SmartContractEventHistory
      <$> (o .:? "eventId")
      <*> (o .:? "eventName")
      <*> (o .:? "eventParameters")
      <*> (o .:? "transactionId")
      <*> (o .:? "timestamp")

-- | ToJSON SmartContractEventHistory
instance A.ToJSON SmartContractEventHistory where
  toJSON SmartContractEventHistory {..} =
   _omitNulls
      [ "eventId" .= smartContractEventHistoryEventId
      , "eventName" .= smartContractEventHistoryEventName
      , "eventParameters" .= smartContractEventHistoryEventParameters
      , "transactionId" .= smartContractEventHistoryTransactionId
      , "timestamp" .= smartContractEventHistoryTimestamp
      ]


-- | Construct a value of type 'SmartContractEventHistory' (by applying it's required fields, if any)
mkSmartContractEventHistory
  :: SmartContractEventHistory
mkSmartContractEventHistory =
  SmartContractEventHistory
  { smartContractEventHistoryEventId = Nothing
  , smartContractEventHistoryEventName = Nothing
  , smartContractEventHistoryEventParameters = Nothing
  , smartContractEventHistoryTransactionId = Nothing
  , smartContractEventHistoryTimestamp = Nothing
  }

-- ** SmartContractFunctionSchema
-- | SmartContractFunctionSchema
data SmartContractFunctionSchema = SmartContractFunctionSchema
  { smartContractFunctionSchemaName :: !(Maybe Text) -- ^ "name"
  , smartContractFunctionSchemaInputParameters :: !(Maybe [SmartContractInputParameterSchema]) -- ^ "inputParameters"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractFunctionSchema
instance A.FromJSON SmartContractFunctionSchema where
  parseJSON = A.withObject "SmartContractFunctionSchema" $ \o ->
    SmartContractFunctionSchema
      <$> (o .:? "name")
      <*> (o .:? "inputParameters")

-- | ToJSON SmartContractFunctionSchema
instance A.ToJSON SmartContractFunctionSchema where
  toJSON SmartContractFunctionSchema {..} =
   _omitNulls
      [ "name" .= smartContractFunctionSchemaName
      , "inputParameters" .= smartContractFunctionSchemaInputParameters
      ]


-- | Construct a value of type 'SmartContractFunctionSchema' (by applying it's required fields, if any)
mkSmartContractFunctionSchema
  :: SmartContractFunctionSchema
mkSmartContractFunctionSchema =
  SmartContractFunctionSchema
  { smartContractFunctionSchemaName = Nothing
  , smartContractFunctionSchemaInputParameters = Nothing
  }

-- ** SmartContractInputParameterSchema
-- | SmartContractInputParameterSchema
data SmartContractInputParameterSchema = SmartContractInputParameterSchema
  { smartContractInputParameterSchemaType :: !(Maybe Text) -- ^ "type"
  , smartContractInputParameterSchemaValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractInputParameterSchema
instance A.FromJSON SmartContractInputParameterSchema where
  parseJSON = A.withObject "SmartContractInputParameterSchema" $ \o ->
    SmartContractInputParameterSchema
      <$> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON SmartContractInputParameterSchema
instance A.ToJSON SmartContractInputParameterSchema where
  toJSON SmartContractInputParameterSchema {..} =
   _omitNulls
      [ "type" .= smartContractInputParameterSchemaType
      , "value" .= smartContractInputParameterSchemaValue
      ]


-- | Construct a value of type 'SmartContractInputParameterSchema' (by applying it's required fields, if any)
mkSmartContractInputParameterSchema
  :: SmartContractInputParameterSchema
mkSmartContractInputParameterSchema =
  SmartContractInputParameterSchema
  { smartContractInputParameterSchemaType = Nothing
  , smartContractInputParameterSchemaValue = Nothing
  }

-- ** SmartContractInvokeRequestDetailsSchema
-- | SmartContractInvokeRequestDetailsSchema
data SmartContractInvokeRequestDetailsSchema = SmartContractInvokeRequestDetailsSchema
  { smartContractInvokeRequestDetailsSchemaOrigin :: !(Maybe [SmartContractRequestDetailsOrigin]) -- ^ "origin"
  , smartContractInvokeRequestDetailsSchemaDestination :: !(Maybe [SmartContractDestinationSchema]) -- ^ "destination"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractInvokeRequestDetailsSchema
instance A.FromJSON SmartContractInvokeRequestDetailsSchema where
  parseJSON = A.withObject "SmartContractInvokeRequestDetailsSchema" $ \o ->
    SmartContractInvokeRequestDetailsSchema
      <$> (o .:? "origin")
      <*> (o .:? "destination")

-- | ToJSON SmartContractInvokeRequestDetailsSchema
instance A.ToJSON SmartContractInvokeRequestDetailsSchema where
  toJSON SmartContractInvokeRequestDetailsSchema {..} =
   _omitNulls
      [ "origin" .= smartContractInvokeRequestDetailsSchemaOrigin
      , "destination" .= smartContractInvokeRequestDetailsSchemaDestination
      ]


-- | Construct a value of type 'SmartContractInvokeRequestDetailsSchema' (by applying it's required fields, if any)
mkSmartContractInvokeRequestDetailsSchema
  :: SmartContractInvokeRequestDetailsSchema
mkSmartContractInvokeRequestDetailsSchema =
  SmartContractInvokeRequestDetailsSchema
  { smartContractInvokeRequestDetailsSchemaOrigin = Nothing
  , smartContractInvokeRequestDetailsSchemaDestination = Nothing
  }

-- ** SmartContractMonitoringDetailsSchema
-- | SmartContractMonitoringDetailsSchema
data SmartContractMonitoringDetailsSchema = SmartContractMonitoringDetailsSchema
  { smartContractMonitoringDetailsSchemaSmartContractEventHistory :: !(Maybe [SmartContractEventHistory]) -- ^ "smartContractEventHistory"
  , smartContractMonitoringDetailsSchemaSmartContractEventDetails :: !(Maybe ResourceMonitoringSmartContractEventDetails) -- ^ "smartContractEventDetails"
  , smartContractMonitoringDetailsSchemaLocation :: !(Maybe Location) -- ^ "location"
  , smartContractMonitoringDetailsSchemaType :: !(Maybe Text) -- ^ "type"
  , smartContractMonitoringDetailsSchemaStatus :: !(Maybe Status) -- ^ "status"
  , smartContractMonitoringDetailsSchemaTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractMonitoringDetailsSchema
instance A.FromJSON SmartContractMonitoringDetailsSchema where
  parseJSON = A.withObject "SmartContractMonitoringDetailsSchema" $ \o ->
    SmartContractMonitoringDetailsSchema
      <$> (o .:? "smartContractEventHistory")
      <*> (o .:? "smartContractEventDetails")
      <*> (o .:? "location")
      <*> (o .:? "type")
      <*> (o .:? "status")
      <*> (o .:? "timestamp")

-- | ToJSON SmartContractMonitoringDetailsSchema
instance A.ToJSON SmartContractMonitoringDetailsSchema where
  toJSON SmartContractMonitoringDetailsSchema {..} =
   _omitNulls
      [ "smartContractEventHistory" .= smartContractMonitoringDetailsSchemaSmartContractEventHistory
      , "smartContractEventDetails" .= smartContractMonitoringDetailsSchemaSmartContractEventDetails
      , "location" .= smartContractMonitoringDetailsSchemaLocation
      , "type" .= smartContractMonitoringDetailsSchemaType
      , "status" .= smartContractMonitoringDetailsSchemaStatus
      , "timestamp" .= smartContractMonitoringDetailsSchemaTimestamp
      ]


-- | Construct a value of type 'SmartContractMonitoringDetailsSchema' (by applying it's required fields, if any)
mkSmartContractMonitoringDetailsSchema
  :: SmartContractMonitoringDetailsSchema
mkSmartContractMonitoringDetailsSchema =
  SmartContractMonitoringDetailsSchema
  { smartContractMonitoringDetailsSchemaSmartContractEventHistory = Nothing
  , smartContractMonitoringDetailsSchemaSmartContractEventDetails = Nothing
  , smartContractMonitoringDetailsSchemaLocation = Nothing
  , smartContractMonitoringDetailsSchemaType = Nothing
  , smartContractMonitoringDetailsSchemaStatus = Nothing
  , smartContractMonitoringDetailsSchemaTimestamp = Nothing
  }

-- ** SmartContractMonitoringSchema
-- | SmartContractMonitoringSchema
data SmartContractMonitoringSchema = SmartContractMonitoringSchema
  { smartContractMonitoringSchemaSmartContractEventMonitoringDetails :: !(Maybe ResourceMonitoringSmartContractEventDetails) -- ^ "smartContractEventMonitoringDetails"
  , smartContractMonitoringSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractMonitoringSchema
instance A.FromJSON SmartContractMonitoringSchema where
  parseJSON = A.withObject "SmartContractMonitoringSchema" $ \o ->
    SmartContractMonitoringSchema
      <$> (o .:? "smartContractEventMonitoringDetails")
      <*> (o .:? "resourceMonitoring")

-- | ToJSON SmartContractMonitoringSchema
instance A.ToJSON SmartContractMonitoringSchema where
  toJSON SmartContractMonitoringSchema {..} =
   _omitNulls
      [ "smartContractEventMonitoringDetails" .= smartContractMonitoringSchemaSmartContractEventMonitoringDetails
      , "resourceMonitoring" .= smartContractMonitoringSchemaResourceMonitoring
      ]


-- | Construct a value of type 'SmartContractMonitoringSchema' (by applying it's required fields, if any)
mkSmartContractMonitoringSchema
  :: SmartContractMonitoringSchema
mkSmartContractMonitoringSchema =
  SmartContractMonitoringSchema
  { smartContractMonitoringSchemaSmartContractEventMonitoringDetails = Nothing
  , smartContractMonitoringSchemaResourceMonitoring = Nothing
  }

-- ** SmartContractOutputParameterSchema
-- | SmartContractOutputParameterSchema
data SmartContractOutputParameterSchema = SmartContractOutputParameterSchema
  { smartContractOutputParameterSchemaType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractOutputParameterSchema
instance A.FromJSON SmartContractOutputParameterSchema where
  parseJSON = A.withObject "SmartContractOutputParameterSchema" $ \o ->
    SmartContractOutputParameterSchema
      <$> (o .:? "type")

-- | ToJSON SmartContractOutputParameterSchema
instance A.ToJSON SmartContractOutputParameterSchema where
  toJSON SmartContractOutputParameterSchema {..} =
   _omitNulls
      [ "type" .= smartContractOutputParameterSchemaType
      ]


-- | Construct a value of type 'SmartContractOutputParameterSchema' (by applying it's required fields, if any)
mkSmartContractOutputParameterSchema
  :: SmartContractOutputParameterSchema
mkSmartContractOutputParameterSchema =
  SmartContractOutputParameterSchema
  { smartContractOutputParameterSchemaType = Nothing
  }

-- ** SmartContractPaymentSchema
-- | SmartContractPaymentSchema
data SmartContractPaymentSchema = SmartContractPaymentSchema
  { smartContractPaymentSchemaAmount :: !(Maybe Text) -- ^ "amount"
  , smartContractPaymentSchemaUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractPaymentSchema
instance A.FromJSON SmartContractPaymentSchema where
  parseJSON = A.withObject "SmartContractPaymentSchema" $ \o ->
    SmartContractPaymentSchema
      <$> (o .:? "amount")
      <*> (o .:? "unit")

-- | ToJSON SmartContractPaymentSchema
instance A.ToJSON SmartContractPaymentSchema where
  toJSON SmartContractPaymentSchema {..} =
   _omitNulls
      [ "amount" .= smartContractPaymentSchemaAmount
      , "unit" .= smartContractPaymentSchemaUnit
      ]


-- | Construct a value of type 'SmartContractPaymentSchema' (by applying it's required fields, if any)
mkSmartContractPaymentSchema
  :: SmartContractPaymentSchema
mkSmartContractPaymentSchema =
  SmartContractPaymentSchema
  { smartContractPaymentSchemaAmount = Nothing
  , smartContractPaymentSchemaUnit = Nothing
  }

-- ** SmartContractReadFunctionSchema
-- | SmartContractReadFunctionSchema
data SmartContractReadFunctionSchema = SmartContractReadFunctionSchema
  { smartContractReadFunctionSchemaFunctionId :: !(Maybe Text) -- ^ "functionId"
  , smartContractReadFunctionSchemaName :: !(Maybe Text) -- ^ "name"
  , smartContractReadFunctionSchemaInputParameters :: !(Maybe [SmartContractInputParameterSchema]) -- ^ "inputParameters"
  , smartContractReadFunctionSchemaOutputParameters :: !(Maybe [SmartContractInputParameterSchema]) -- ^ "outputParameters"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractReadFunctionSchema
instance A.FromJSON SmartContractReadFunctionSchema where
  parseJSON = A.withObject "SmartContractReadFunctionSchema" $ \o ->
    SmartContractReadFunctionSchema
      <$> (o .:? "functionId")
      <*> (o .:? "name")
      <*> (o .:? "inputParameters")
      <*> (o .:? "outputParameters")

-- | ToJSON SmartContractReadFunctionSchema
instance A.ToJSON SmartContractReadFunctionSchema where
  toJSON SmartContractReadFunctionSchema {..} =
   _omitNulls
      [ "functionId" .= smartContractReadFunctionSchemaFunctionId
      , "name" .= smartContractReadFunctionSchemaName
      , "inputParameters" .= smartContractReadFunctionSchemaInputParameters
      , "outputParameters" .= smartContractReadFunctionSchemaOutputParameters
      ]


-- | Construct a value of type 'SmartContractReadFunctionSchema' (by applying it's required fields, if any)
mkSmartContractReadFunctionSchema
  :: SmartContractReadFunctionSchema
mkSmartContractReadFunctionSchema =
  SmartContractReadFunctionSchema
  { smartContractReadFunctionSchemaFunctionId = Nothing
  , smartContractReadFunctionSchemaName = Nothing
  , smartContractReadFunctionSchemaInputParameters = Nothing
  , smartContractReadFunctionSchemaOutputParameters = Nothing
  }

-- ** SmartContractReadSchema
-- | SmartContractReadSchema
-- Computer program storage in a DLT system where the outcome is recorded on the distributed ledger
data SmartContractReadSchema = SmartContractReadSchema
  { smartContractReadSchemaFunction :: !(Maybe SmartContractReadFunctionSchema) -- ^ "function"
  , smartContractReadSchemaSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractReadSchema
instance A.FromJSON SmartContractReadSchema where
  parseJSON = A.withObject "SmartContractReadSchema" $ \o ->
    SmartContractReadSchema
      <$> (o .:? "function")
      <*> (o .:? "smartContractId")

-- | ToJSON SmartContractReadSchema
instance A.ToJSON SmartContractReadSchema where
  toJSON SmartContractReadSchema {..} =
   _omitNulls
      [ "function" .= smartContractReadSchemaFunction
      , "smartContractId" .= smartContractReadSchemaSmartContractId
      ]


-- | Construct a value of type 'SmartContractReadSchema' (by applying it's required fields, if any)
mkSmartContractReadSchema
  :: SmartContractReadSchema
mkSmartContractReadSchema =
  SmartContractReadSchema
  { smartContractReadSchemaFunction = Nothing
  , smartContractReadSchemaSmartContractId = Nothing
  }

-- ** SmartContractRequestDetailsOrigin
-- | SmartContractRequestDetailsOrigin
data SmartContractRequestDetailsOrigin = SmartContractRequestDetailsOrigin
  { smartContractRequestDetailsOriginOriginId :: !(Maybe Text) -- ^ "originId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractRequestDetailsOrigin
instance A.FromJSON SmartContractRequestDetailsOrigin where
  parseJSON = A.withObject "SmartContractRequestDetailsOrigin" $ \o ->
    SmartContractRequestDetailsOrigin
      <$> (o .:? "originId")

-- | ToJSON SmartContractRequestDetailsOrigin
instance A.ToJSON SmartContractRequestDetailsOrigin where
  toJSON SmartContractRequestDetailsOrigin {..} =
   _omitNulls
      [ "originId" .= smartContractRequestDetailsOriginOriginId
      ]


-- | Construct a value of type 'SmartContractRequestDetailsOrigin' (by applying it's required fields, if any)
mkSmartContractRequestDetailsOrigin
  :: SmartContractRequestDetailsOrigin
mkSmartContractRequestDetailsOrigin =
  SmartContractRequestDetailsOrigin
  { smartContractRequestDetailsOriginOriginId = Nothing
  }

-- ** SmartContractSchema
-- | SmartContractSchema
data SmartContractSchema = SmartContractSchema
  { smartContractSchemaFunction :: !(Maybe SmartContractFunctionSchema) -- ^ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSchema
instance A.FromJSON SmartContractSchema where
  parseJSON = A.withObject "SmartContractSchema" $ \o ->
    SmartContractSchema
      <$> (o .:? "function")

-- | ToJSON SmartContractSchema
instance A.ToJSON SmartContractSchema where
  toJSON SmartContractSchema {..} =
   _omitNulls
      [ "function" .= smartContractSchemaFunction
      ]


-- | Construct a value of type 'SmartContractSchema' (by applying it's required fields, if any)
mkSmartContractSchema
  :: SmartContractSchema
mkSmartContractSchema =
  SmartContractSchema
  { smartContractSchemaFunction = Nothing
  }

-- ** SmartContractSearchDestinationSchema
-- | SmartContractSearchDestinationSchema
data SmartContractSearchDestinationSchema = SmartContractSearchDestinationSchema
  { smartContractSearchDestinationSchemaSmartContract :: !(Maybe SmartContractSearchSchema) -- ^ "smartContract"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSearchDestinationSchema
instance A.FromJSON SmartContractSearchDestinationSchema where
  parseJSON = A.withObject "SmartContractSearchDestinationSchema" $ \o ->
    SmartContractSearchDestinationSchema
      <$> (o .:? "smartContract")

-- | ToJSON SmartContractSearchDestinationSchema
instance A.ToJSON SmartContractSearchDestinationSchema where
  toJSON SmartContractSearchDestinationSchema {..} =
   _omitNulls
      [ "smartContract" .= smartContractSearchDestinationSchemaSmartContract
      ]


-- | Construct a value of type 'SmartContractSearchDestinationSchema' (by applying it's required fields, if any)
mkSmartContractSearchDestinationSchema
  :: SmartContractSearchDestinationSchema
mkSmartContractSearchDestinationSchema =
  SmartContractSearchDestinationSchema
  { smartContractSearchDestinationSchemaSmartContract = Nothing
  }

-- ** SmartContractSearchFunctionSchema
-- | SmartContractSearchFunctionSchema
data SmartContractSearchFunctionSchema = SmartContractSearchFunctionSchema
  { smartContractSearchFunctionSchemaName :: !(Maybe Text) -- ^ "name"
  , smartContractSearchFunctionSchemaInputParameters :: !(Maybe [SmartContractInputParameterSchema]) -- ^ "inputParameters"
  , smartContractSearchFunctionSchemaOutputParameters :: !(Maybe [SmartContractOutputParameterSchema]) -- ^ "outputParameters"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSearchFunctionSchema
instance A.FromJSON SmartContractSearchFunctionSchema where
  parseJSON = A.withObject "SmartContractSearchFunctionSchema" $ \o ->
    SmartContractSearchFunctionSchema
      <$> (o .:? "name")
      <*> (o .:? "inputParameters")
      <*> (o .:? "outputParameters")

-- | ToJSON SmartContractSearchFunctionSchema
instance A.ToJSON SmartContractSearchFunctionSchema where
  toJSON SmartContractSearchFunctionSchema {..} =
   _omitNulls
      [ "name" .= smartContractSearchFunctionSchemaName
      , "inputParameters" .= smartContractSearchFunctionSchemaInputParameters
      , "outputParameters" .= smartContractSearchFunctionSchemaOutputParameters
      ]


-- | Construct a value of type 'SmartContractSearchFunctionSchema' (by applying it's required fields, if any)
mkSmartContractSearchFunctionSchema
  :: SmartContractSearchFunctionSchema
mkSmartContractSearchFunctionSchema =
  SmartContractSearchFunctionSchema
  { smartContractSearchFunctionSchemaName = Nothing
  , smartContractSearchFunctionSchemaInputParameters = Nothing
  , smartContractSearchFunctionSchemaOutputParameters = Nothing
  }

-- ** SmartContractSearchRequestDetails
-- | SmartContractSearchRequestDetails
data SmartContractSearchRequestDetails = SmartContractSearchRequestDetails
  { smartContractSearchRequestDetailsDestination :: !(Maybe [SmartContractSearchDestinationSchema]) -- ^ "destination"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSearchRequestDetails
instance A.FromJSON SmartContractSearchRequestDetails where
  parseJSON = A.withObject "SmartContractSearchRequestDetails" $ \o ->
    SmartContractSearchRequestDetails
      <$> (o .:? "destination")

-- | ToJSON SmartContractSearchRequestDetails
instance A.ToJSON SmartContractSearchRequestDetails where
  toJSON SmartContractSearchRequestDetails {..} =
   _omitNulls
      [ "destination" .= smartContractSearchRequestDetailsDestination
      ]


-- | Construct a value of type 'SmartContractSearchRequestDetails' (by applying it's required fields, if any)
mkSmartContractSearchRequestDetails
  :: SmartContractSearchRequestDetails
mkSmartContractSearchRequestDetails =
  SmartContractSearchRequestDetails
  { smartContractSearchRequestDetailsDestination = Nothing
  }

-- ** SmartContractSearchSchema
-- | SmartContractSearchSchema
data SmartContractSearchSchema = SmartContractSearchSchema
  { smartContractSearchSchemaFunction :: !(Maybe SmartContractSearchFunctionSchema) -- ^ "function"
  , smartContractSearchSchemaSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSearchSchema
instance A.FromJSON SmartContractSearchSchema where
  parseJSON = A.withObject "SmartContractSearchSchema" $ \o ->
    SmartContractSearchSchema
      <$> (o .:? "function")
      <*> (o .:? "smartContractId")

-- | ToJSON SmartContractSearchSchema
instance A.ToJSON SmartContractSearchSchema where
  toJSON SmartContractSearchSchema {..} =
   _omitNulls
      [ "function" .= smartContractSearchSchemaFunction
      , "smartContractId" .= smartContractSearchSchemaSmartContractId
      ]


-- | Construct a value of type 'SmartContractSearchSchema' (by applying it's required fields, if any)
mkSmartContractSearchSchema
  :: SmartContractSearchSchema
mkSmartContractSearchSchema =
  SmartContractSearchSchema
  { smartContractSearchSchemaFunction = Nothing
  , smartContractSearchSchemaSmartContractId = Nothing
  }

-- ** Status
-- | Status
data Status = Status
  { statusCode :: !(Maybe Text) -- ^ "code" - The code of an object
  , statusDescription :: !(Maybe Text) -- ^ "description" - The description of an object
  , statusMessage :: !(Maybe Text) -- ^ "message" - The message of an object
  , statusValue :: !(Maybe Text) -- ^ "value" - The value of an object
  , statusTimestamp :: !(Maybe Text) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Status
instance A.FromJSON Status where
  parseJSON = A.withObject "Status" $ \o ->
    Status
      <$> (o .:? "code")
      <*> (o .:? "description")
      <*> (o .:? "message")
      <*> (o .:? "value")
      <*> (o .:? "timestamp")

-- | ToJSON Status
instance A.ToJSON Status where
  toJSON Status {..} =
   _omitNulls
      [ "code" .= statusCode
      , "description" .= statusDescription
      , "message" .= statusMessage
      , "value" .= statusValue
      , "timestamp" .= statusTimestamp
      ]


-- | Construct a value of type 'Status' (by applying it's required fields, if any)
mkStatus
  :: Status
mkStatus =
  Status
  { statusCode = Nothing
  , statusDescription = Nothing
  , statusMessage = Nothing
  , statusValue = Nothing
  , statusTimestamp = Nothing
  }

-- ** StatusUpdateMonitoringRequestSchema
-- | StatusUpdateMonitoringRequestSchema
data StatusUpdateMonitoringRequestSchema = StatusUpdateMonitoringRequestSchema
  { statusUpdateMonitoringRequestSchemaStatusUpdate :: !(Maybe StatusUpdateSchema) -- ^ "statusUpdate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StatusUpdateMonitoringRequestSchema
instance A.FromJSON StatusUpdateMonitoringRequestSchema where
  parseJSON = A.withObject "StatusUpdateMonitoringRequestSchema" $ \o ->
    StatusUpdateMonitoringRequestSchema
      <$> (o .:? "statusUpdate")

-- | ToJSON StatusUpdateMonitoringRequestSchema
instance A.ToJSON StatusUpdateMonitoringRequestSchema where
  toJSON StatusUpdateMonitoringRequestSchema {..} =
   _omitNulls
      [ "statusUpdate" .= statusUpdateMonitoringRequestSchemaStatusUpdate
      ]


-- | Construct a value of type 'StatusUpdateMonitoringRequestSchema' (by applying it's required fields, if any)
mkStatusUpdateMonitoringRequestSchema
  :: StatusUpdateMonitoringRequestSchema
mkStatusUpdateMonitoringRequestSchema =
  StatusUpdateMonitoringRequestSchema
  { statusUpdateMonitoringRequestSchemaStatusUpdate = Nothing
  }

-- ** StatusUpdateSchema
-- | StatusUpdateSchema
data StatusUpdateSchema = StatusUpdateSchema
  { statusUpdateSchemaValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StatusUpdateSchema
instance A.FromJSON StatusUpdateSchema where
  parseJSON = A.withObject "StatusUpdateSchema" $ \o ->
    StatusUpdateSchema
      <$> (o .:? "value")

-- | ToJSON StatusUpdateSchema
instance A.ToJSON StatusUpdateSchema where
  toJSON StatusUpdateSchema {..} =
   _omitNulls
      [ "value" .= statusUpdateSchemaValue
      ]


-- | Construct a value of type 'StatusUpdateSchema' (by applying it's required fields, if any)
mkStatusUpdateSchema
  :: StatusUpdateSchema
mkStatusUpdateSchema =
  StatusUpdateSchema
  { statusUpdateSchemaValue = Nothing
  }

-- ** SubscriptionDeletionResponse
-- | SubscriptionDeletionResponse
data SubscriptionDeletionResponse = SubscriptionDeletionResponse
  { subscriptionDeletionResponseSubscriptionDetails :: !(Maybe SubscriptionDetails) -- ^ "subscriptionDetails"
  , subscriptionDeletionResponseCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  , subscriptionDeletionResponseSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  , subscriptionDeletionResponseType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubscriptionDeletionResponse
instance A.FromJSON SubscriptionDeletionResponse where
  parseJSON = A.withObject "SubscriptionDeletionResponse" $ \o ->
    SubscriptionDeletionResponse
      <$> (o .:? "subscriptionDetails")
      <*> (o .:? "callbackUrl")
      <*> (o .:? "subscriptionId")
      <*> (o .:? "type")

-- | ToJSON SubscriptionDeletionResponse
instance A.ToJSON SubscriptionDeletionResponse where
  toJSON SubscriptionDeletionResponse {..} =
   _omitNulls
      [ "subscriptionDetails" .= subscriptionDeletionResponseSubscriptionDetails
      , "callbackUrl" .= subscriptionDeletionResponseCallbackUrl
      , "subscriptionId" .= subscriptionDeletionResponseSubscriptionId
      , "type" .= subscriptionDeletionResponseType
      ]


-- | Construct a value of type 'SubscriptionDeletionResponse' (by applying it's required fields, if any)
mkSubscriptionDeletionResponse
  :: SubscriptionDeletionResponse
mkSubscriptionDeletionResponse =
  SubscriptionDeletionResponse
  { subscriptionDeletionResponseSubscriptionDetails = Nothing
  , subscriptionDeletionResponseCallbackUrl = Nothing
  , subscriptionDeletionResponseSubscriptionId = Nothing
  , subscriptionDeletionResponseType = Nothing
  }

-- ** SubscriptionDetails
-- | SubscriptionDetails
data SubscriptionDetails = SubscriptionDetails
  { subscriptionDetailsIds :: !(Maybe [Text]) -- ^ "ids"
  , subscriptionDetailsStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubscriptionDetails
instance A.FromJSON SubscriptionDetails where
  parseJSON = A.withObject "SubscriptionDetails" $ \o ->
    SubscriptionDetails
      <$> (o .:? "ids")
      <*> (o .:? "status")

-- | ToJSON SubscriptionDetails
instance A.ToJSON SubscriptionDetails where
  toJSON SubscriptionDetails {..} =
   _omitNulls
      [ "ids" .= subscriptionDetailsIds
      , "status" .= subscriptionDetailsStatus
      ]


-- | Construct a value of type 'SubscriptionDetails' (by applying it's required fields, if any)
mkSubscriptionDetails
  :: SubscriptionDetails
mkSubscriptionDetails =
  SubscriptionDetails
  { subscriptionDetailsIds = Nothing
  , subscriptionDetailsStatus = Nothing
  }

-- ** SubscriptionDetailsSchema
-- | SubscriptionDetailsSchema
data SubscriptionDetailsSchema = SubscriptionDetailsSchema
  { subscriptionDetailsSchemaIds :: !(Maybe [Text]) -- ^ "ids"
  , subscriptionDetailsSchemaStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubscriptionDetailsSchema
instance A.FromJSON SubscriptionDetailsSchema where
  parseJSON = A.withObject "SubscriptionDetailsSchema" $ \o ->
    SubscriptionDetailsSchema
      <$> (o .:? "ids")
      <*> (o .:? "status")

-- | ToJSON SubscriptionDetailsSchema
instance A.ToJSON SubscriptionDetailsSchema where
  toJSON SubscriptionDetailsSchema {..} =
   _omitNulls
      [ "ids" .= subscriptionDetailsSchemaIds
      , "status" .= subscriptionDetailsSchemaStatus
      ]


-- | Construct a value of type 'SubscriptionDetailsSchema' (by applying it's required fields, if any)
mkSubscriptionDetailsSchema
  :: SubscriptionDetailsSchema
mkSubscriptionDetailsSchema =
  SubscriptionDetailsSchema
  { subscriptionDetailsSchemaIds = Nothing
  , subscriptionDetailsSchemaStatus = Nothing
  }

-- ** SubscriptionUpdateResponse
-- | SubscriptionUpdateResponse
data SubscriptionUpdateResponse = SubscriptionUpdateResponse
  { subscriptionUpdateResponseSubscriptionDetails :: !(Maybe SubscriptionDetails) -- ^ "subscriptionDetails"
  , subscriptionUpdateResponseCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  , subscriptionUpdateResponseSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  , subscriptionUpdateResponseType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubscriptionUpdateResponse
instance A.FromJSON SubscriptionUpdateResponse where
  parseJSON = A.withObject "SubscriptionUpdateResponse" $ \o ->
    SubscriptionUpdateResponse
      <$> (o .:? "subscriptionDetails")
      <*> (o .:? "callbackUrl")
      <*> (o .:? "subscriptionId")
      <*> (o .:? "type")

-- | ToJSON SubscriptionUpdateResponse
instance A.ToJSON SubscriptionUpdateResponse where
  toJSON SubscriptionUpdateResponse {..} =
   _omitNulls
      [ "subscriptionDetails" .= subscriptionUpdateResponseSubscriptionDetails
      , "callbackUrl" .= subscriptionUpdateResponseCallbackUrl
      , "subscriptionId" .= subscriptionUpdateResponseSubscriptionId
      , "type" .= subscriptionUpdateResponseType
      ]


-- | Construct a value of type 'SubscriptionUpdateResponse' (by applying it's required fields, if any)
mkSubscriptionUpdateResponse
  :: SubscriptionUpdateResponse
mkSubscriptionUpdateResponse =
  SubscriptionUpdateResponse
  { subscriptionUpdateResponseSubscriptionDetails = Nothing
  , subscriptionUpdateResponseCallbackUrl = Nothing
  , subscriptionUpdateResponseSubscriptionId = Nothing
  , subscriptionUpdateResponseType = Nothing
  }

-- ** Transaction
-- | Transaction
-- Smallest unit of a work process related to interactions with distributed ledgers
data Transaction = Transaction
  { transactionSignature :: !(Maybe [Text]) -- ^ "signature" - The signatures of this transaction
  , transactionOrigin :: !(Maybe [Origin]) -- ^ "origin"
  , transactionFee :: !(Maybe Fee) -- ^ "fee"
  , transactionDestination :: !(Maybe [Destination]) -- ^ "destination"
  , transactionSigned :: !(Maybe Text) -- ^ "signed"
  , transactionTotalPaymentAmount :: !(Maybe [Payment]) -- ^ "totalPaymentAmount"
  , transactionMessage :: !(Maybe Text) -- ^ "message" - Any text-based element of the data payload
  , transactionTransactionId :: !(Maybe Text) -- ^ "transactionId" - The unique identifier of the transaction on this DLN
  , transactionEncoded :: !(Maybe [Text]) -- ^ "encoded"
  , transactionNativeData :: !(Maybe A.Value) -- ^ "nativeData"
  , transactionExtraFields :: !(Maybe A.Value) -- ^ "extraFields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Transaction
instance A.FromJSON Transaction where
  parseJSON = A.withObject "Transaction" $ \o ->
    Transaction
      <$> (o .:? "signature")
      <*> (o .:? "origin")
      <*> (o .:? "fee")
      <*> (o .:? "destination")
      <*> (o .:? "signed")
      <*> (o .:? "totalPaymentAmount")
      <*> (o .:? "message")
      <*> (o .:? "transactionId")
      <*> (o .:? "encoded")
      <*> (o .:? "nativeData")
      <*> (o .:? "extraFields")

-- | ToJSON Transaction
instance A.ToJSON Transaction where
  toJSON Transaction {..} =
   _omitNulls
      [ "signature" .= transactionSignature
      , "origin" .= transactionOrigin
      , "fee" .= transactionFee
      , "destination" .= transactionDestination
      , "signed" .= transactionSigned
      , "totalPaymentAmount" .= transactionTotalPaymentAmount
      , "message" .= transactionMessage
      , "transactionId" .= transactionTransactionId
      , "encoded" .= transactionEncoded
      , "nativeData" .= transactionNativeData
      , "extraFields" .= transactionExtraFields
      ]


-- | Construct a value of type 'Transaction' (by applying it's required fields, if any)
mkTransaction
  :: Transaction
mkTransaction =
  Transaction
  { transactionSignature = Nothing
  , transactionOrigin = Nothing
  , transactionFee = Nothing
  , transactionDestination = Nothing
  , transactionSigned = Nothing
  , transactionTotalPaymentAmount = Nothing
  , transactionMessage = Nothing
  , transactionTransactionId = Nothing
  , transactionEncoded = Nothing
  , transactionNativeData = Nothing
  , transactionExtraFields = Nothing
  }

-- ** Transfer
-- | Transfer
data Transfer = Transfer
  { transferTokenId :: !(Maybe Text) -- ^ "tokenId"
  , transferTokenName :: !(Maybe Text) -- ^ "tokenName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Transfer
instance A.FromJSON Transfer where
  parseJSON = A.withObject "Transfer" $ \o ->
    Transfer
      <$> (o .:? "tokenId")
      <*> (o .:? "tokenName")

-- | ToJSON Transfer
instance A.ToJSON Transfer where
  toJSON Transfer {..} =
   _omitNulls
      [ "tokenId" .= transferTokenId
      , "tokenName" .= transferTokenName
      ]


-- | Construct a value of type 'Transfer' (by applying it's required fields, if any)
mkTransfer
  :: Transfer
mkTransfer =
  Transfer
  { transferTokenId = Nothing
  , transferTokenName = Nothing
  }

-- ** TransferRequestDetailsSchema
-- | TransferRequestDetailsSchema
data TransferRequestDetailsSchema = TransferRequestDetailsSchema
  { transferRequestDetailsSchemaOverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  , transferRequestDetailsSchemaOrigin :: !(Maybe [OriginTransferSchema]) -- ^ "origin"
  , transferRequestDetailsSchemaDestination :: !(Maybe [DestinationTransferSchema]) -- ^ "destination"
  , transferRequestDetailsSchemaMessage :: !(Maybe Text) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransferRequestDetailsSchema
instance A.FromJSON TransferRequestDetailsSchema where
  parseJSON = A.withObject "TransferRequestDetailsSchema" $ \o ->
    TransferRequestDetailsSchema
      <$> (o .:? "overledgerSigningType")
      <*> (o .:? "origin")
      <*> (o .:? "destination")
      <*> (o .:? "message")

-- | ToJSON TransferRequestDetailsSchema
instance A.ToJSON TransferRequestDetailsSchema where
  toJSON TransferRequestDetailsSchema {..} =
   _omitNulls
      [ "overledgerSigningType" .= transferRequestDetailsSchemaOverledgerSigningType
      , "origin" .= transferRequestDetailsSchemaOrigin
      , "destination" .= transferRequestDetailsSchemaDestination
      , "message" .= transferRequestDetailsSchemaMessage
      ]


-- | Construct a value of type 'TransferRequestDetailsSchema' (by applying it's required fields, if any)
mkTransferRequestDetailsSchema
  :: TransferRequestDetailsSchema
mkTransferRequestDetailsSchema =
  TransferRequestDetailsSchema
  { transferRequestDetailsSchemaOverledgerSigningType = Nothing
  , transferRequestDetailsSchemaOrigin = Nothing
  , transferRequestDetailsSchemaDestination = Nothing
  , transferRequestDetailsSchemaMessage = Nothing
  }

-- ** TransferSchema
-- | TransferSchema
data TransferSchema = TransferSchema
  { transferSchemaTokenId :: !(Maybe Text) -- ^ "tokenId"
  , transferSchemaTokenName :: !(Maybe Text) -- ^ "tokenName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransferSchema
instance A.FromJSON TransferSchema where
  parseJSON = A.withObject "TransferSchema" $ \o ->
    TransferSchema
      <$> (o .:? "tokenId")
      <*> (o .:? "tokenName")

-- | ToJSON TransferSchema
instance A.ToJSON TransferSchema where
  toJSON TransferSchema {..} =
   _omitNulls
      [ "tokenId" .= transferSchemaTokenId
      , "tokenName" .= transferSchemaTokenName
      ]


-- | Construct a value of type 'TransferSchema' (by applying it's required fields, if any)
mkTransferSchema
  :: TransferSchema
mkTransferSchema =
  TransferSchema
  { transferSchemaTokenId = Nothing
  , transferSchemaTokenName = Nothing
  }

-- ** UTXODestination
-- | UTXODestination
data UTXODestination = UTXODestination
  { uTXODestinationSmartContract :: !(Maybe UTXOSmartContract) -- ^ "smartContract"
  , uTXODestinationPayment :: !(Maybe Payment) -- ^ "payment"
  , uTXODestinationDestinationId :: !(Maybe Text) -- ^ "destinationId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UTXODestination
instance A.FromJSON UTXODestination where
  parseJSON = A.withObject "UTXODestination" $ \o ->
    UTXODestination
      <$> (o .:? "smartContract")
      <*> (o .:? "payment")
      <*> (o .:? "destinationId")

-- | ToJSON UTXODestination
instance A.ToJSON UTXODestination where
  toJSON UTXODestination {..} =
   _omitNulls
      [ "smartContract" .= uTXODestinationSmartContract
      , "payment" .= uTXODestinationPayment
      , "destinationId" .= uTXODestinationDestinationId
      ]


-- | Construct a value of type 'UTXODestination' (by applying it's required fields, if any)
mkUTXODestination
  :: UTXODestination
mkUTXODestination =
  UTXODestination
  { uTXODestinationSmartContract = Nothing
  , uTXODestinationPayment = Nothing
  , uTXODestinationDestinationId = Nothing
  }

-- ** UTXONativeData
-- | UTXONativeData
data UTXONativeData = UTXONativeData
  { uTXONativeDataVout :: !(Maybe [Vout]) -- ^ "vout"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UTXONativeData
instance A.FromJSON UTXONativeData where
  parseJSON = A.withObject "UTXONativeData" $ \o ->
    UTXONativeData
      <$> (o .:? "vout")

-- | ToJSON UTXONativeData
instance A.ToJSON UTXONativeData where
  toJSON UTXONativeData {..} =
   _omitNulls
      [ "vout" .= uTXONativeDataVout
      ]


-- | Construct a value of type 'UTXONativeData' (by applying it's required fields, if any)
mkUTXONativeData
  :: UTXONativeData
mkUTXONativeData =
  UTXONativeData
  { uTXONativeDataVout = Nothing
  }

-- ** UTXOSmartContract
-- | UTXOSmartContract
data UTXOSmartContract = UTXOSmartContract
  { uTXOSmartContractDetail :: !(Maybe Text) -- ^ "detail"
  , uTXOSmartContractType :: !(Maybe Text) -- ^ "type"
  , uTXOSmartContractExtraFields :: !(Maybe ExtraFields) -- ^ "extraFields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UTXOSmartContract
instance A.FromJSON UTXOSmartContract where
  parseJSON = A.withObject "UTXOSmartContract" $ \o ->
    UTXOSmartContract
      <$> (o .:? "detail")
      <*> (o .:? "type")
      <*> (o .:? "extraFields")

-- | ToJSON UTXOSmartContract
instance A.ToJSON UTXOSmartContract where
  toJSON UTXOSmartContract {..} =
   _omitNulls
      [ "detail" .= uTXOSmartContractDetail
      , "type" .= uTXOSmartContractType
      , "extraFields" .= uTXOSmartContractExtraFields
      ]


-- | Construct a value of type 'UTXOSmartContract' (by applying it's required fields, if any)
mkUTXOSmartContract
  :: UTXOSmartContract
mkUTXOSmartContract =
  UTXOSmartContract
  { uTXOSmartContractDetail = Nothing
  , uTXOSmartContractType = Nothing
  , uTXOSmartContractExtraFields = Nothing
  }

-- ** UTXOTimestampSchema
-- | UTXOTimestampSchema
data UTXOTimestampSchema = UTXOTimestampSchema
  { uTXOTimestampSchemaNano :: !(Maybe Text) -- ^ "nano"
  , uTXOTimestampSchemaEpochSecond :: !(Maybe Text) -- ^ "epochSecond"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UTXOTimestampSchema
instance A.FromJSON UTXOTimestampSchema where
  parseJSON = A.withObject "UTXOTimestampSchema" $ \o ->
    UTXOTimestampSchema
      <$> (o .:? "nano")
      <*> (o .:? "epochSecond")

-- | ToJSON UTXOTimestampSchema
instance A.ToJSON UTXOTimestampSchema where
  toJSON UTXOTimestampSchema {..} =
   _omitNulls
      [ "nano" .= uTXOTimestampSchemaNano
      , "epochSecond" .= uTXOTimestampSchemaEpochSecond
      ]


-- | Construct a value of type 'UTXOTimestampSchema' (by applying it's required fields, if any)
mkUTXOTimestampSchema
  :: UTXOTimestampSchema
mkUTXOTimestampSchema =
  UTXOTimestampSchema
  { uTXOTimestampSchemaNano = Nothing
  , uTXOTimestampSchemaEpochSecond = Nothing
  }

-- ** UpdateAddressMonitoringSchema
-- | UpdateAddressMonitoringSchema
data UpdateAddressMonitoringSchema = UpdateAddressMonitoringSchema
  { updateAddressMonitoringSchemaAddressMonitoringDetails :: !(Maybe ResourceMonitoringAddressDetails) -- ^ "addressMonitoringDetails"
  , updateAddressMonitoringSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateAddressMonitoringSchema
instance A.FromJSON UpdateAddressMonitoringSchema where
  parseJSON = A.withObject "UpdateAddressMonitoringSchema" $ \o ->
    UpdateAddressMonitoringSchema
      <$> (o .:? "addressMonitoringDetails")
      <*> (o .:? "resourceMonitoring")

-- | ToJSON UpdateAddressMonitoringSchema
instance A.ToJSON UpdateAddressMonitoringSchema where
  toJSON UpdateAddressMonitoringSchema {..} =
   _omitNulls
      [ "addressMonitoringDetails" .= updateAddressMonitoringSchemaAddressMonitoringDetails
      , "resourceMonitoring" .= updateAddressMonitoringSchemaResourceMonitoring
      ]


-- | Construct a value of type 'UpdateAddressMonitoringSchema' (by applying it's required fields, if any)
mkUpdateAddressMonitoringSchema
  :: UpdateAddressMonitoringSchema
mkUpdateAddressMonitoringSchema =
  UpdateAddressMonitoringSchema
  { updateAddressMonitoringSchemaAddressMonitoringDetails = Nothing
  , updateAddressMonitoringSchemaResourceMonitoring = Nothing
  }

-- ** UpdateSubscriptionRequestSchema
-- | UpdateSubscriptionRequestSchema
data UpdateSubscriptionRequestSchema = UpdateSubscriptionRequestSchema
  { updateSubscriptionRequestSchemaStatusUpdate :: !(Maybe StatusUpdateSchema) -- ^ "statusUpdate"
  , updateSubscriptionRequestSchemaCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateSubscriptionRequestSchema
instance A.FromJSON UpdateSubscriptionRequestSchema where
  parseJSON = A.withObject "UpdateSubscriptionRequestSchema" $ \o ->
    UpdateSubscriptionRequestSchema
      <$> (o .:? "statusUpdate")
      <*> (o .:? "callbackUrl")

-- | ToJSON UpdateSubscriptionRequestSchema
instance A.ToJSON UpdateSubscriptionRequestSchema where
  toJSON UpdateSubscriptionRequestSchema {..} =
   _omitNulls
      [ "statusUpdate" .= updateSubscriptionRequestSchemaStatusUpdate
      , "callbackUrl" .= updateSubscriptionRequestSchemaCallbackUrl
      ]


-- | Construct a value of type 'UpdateSubscriptionRequestSchema' (by applying it's required fields, if any)
mkUpdateSubscriptionRequestSchema
  :: UpdateSubscriptionRequestSchema
mkUpdateSubscriptionRequestSchema =
  UpdateSubscriptionRequestSchema
  { updateSubscriptionRequestSchemaStatusUpdate = Nothing
  , updateSubscriptionRequestSchemaCallbackUrl = Nothing
  }

-- ** Vout
-- | Vout
data Vout = Vout
  { voutScriptPubKey :: !(Maybe ScriptPubKey) -- ^ "scriptPubKey"
  , voutValue :: !(Maybe Double) -- ^ "value"
  , voutN :: !(Maybe Double) -- ^ "n"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Vout
instance A.FromJSON Vout where
  parseJSON = A.withObject "Vout" $ \o ->
    Vout
      <$> (o .:? "scriptPubKey")
      <*> (o .:? "value")
      <*> (o .:? "n")

-- | ToJSON Vout
instance A.ToJSON Vout where
  toJSON Vout {..} =
   _omitNulls
      [ "scriptPubKey" .= voutScriptPubKey
      , "value" .= voutValue
      , "n" .= voutN
      ]


-- | Construct a value of type 'Vout' (by applying it's required fields, if any)
mkVout
  :: Vout
mkVout =
  Vout
  { voutScriptPubKey = Nothing
  , voutValue = Nothing
  , voutN = Nothing
  }




-- * Auth Methods

-- ** AuthOAuthOAuth2SecurityScheme
data AuthOAuthOAuth2SecurityScheme =
  AuthOAuthOAuth2SecurityScheme Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthOAuthOAuth2SecurityScheme where
  applyAuthMethod _ a@(AuthOAuthOAuth2SecurityScheme secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", "Bearer " <> secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req



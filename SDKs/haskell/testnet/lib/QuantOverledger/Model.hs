{-
   Quant Overledger API

   Quant’s Overledger API allows developers to create applications for multiple DLT’s using a single standard set of operations and data structures.In order to maintain the security of private keys, most operations have two steps – prepare and execute. The prepare step is the point at which all arguments are specified and standardised payloads are sent. Overledger converts this standard payload into a DLT-specific transaction object. In the execute step, the SDK signs the transaction object that Overledger created and submits it to Overledger to perform the operation

   OpenAPI Version: 3.0.1
   Quant Overledger API API version: 2.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : QuantOverledger.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module QuantOverledger.Model where

import QuantOverledger.Core
import QuantOverledger.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AddressId
newtype AddressId = AddressId { unAddressId :: Text } deriving (P.Eq, P.Show)

-- ** Authorization
newtype Authorization = Authorization { unAuthorization :: Text } deriving (P.Eq, P.Show)

-- ** BlockId
newtype BlockId = BlockId { unBlockId :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: A.Value } deriving (P.Eq, P.Show, A.ToJSON)

-- ** ContractType
newtype ContractType = ContractType { unContractType :: Text } deriving (P.Eq, P.Show)

-- ** FlowType
newtype FlowType = FlowType { unFlowType :: Text } deriving (P.Eq, P.Show)

-- ** Flowtype
newtype Flowtype = Flowtype { unFlowtype :: Text } deriving (P.Eq, P.Show)

-- ** Length
newtype Length = Length { unLength :: Int } deriving (P.Eq, P.Show)

-- ** Location2
newtype Location2 = Location2 { unLocation2 :: Location } deriving (P.Eq, P.Show)

-- ** Network
newtype Network = Network { unNetwork :: Text } deriving (P.Eq, P.Show)

-- ** Offset
newtype Offset = Offset { unOffset :: Int } deriving (P.Eq, P.Show)

-- ** Overledgertransactionid
newtype Overledgertransactionid = Overledgertransactionid { unOverledgertransactionid :: Text } deriving (P.Eq, P.Show)

-- ** RequestId
newtype RequestId = RequestId { unRequestId :: Text } deriving (P.Eq, P.Show)

-- ** ResourceMonitoringId
newtype ResourceMonitoringId = ResourceMonitoringId { unResourceMonitoringId :: Text } deriving (P.Eq, P.Show)

-- ** SubscriptionId
newtype SubscriptionId = SubscriptionId { unSubscriptionId :: Text } deriving (P.Eq, P.Show)

-- ** Technology
newtype Technology = Technology { unTechnology :: Text } deriving (P.Eq, P.Show)

-- ** TokenName
newtype TokenName = TokenName { unTokenName :: Text } deriving (P.Eq, P.Show)

-- ** TransactionId
newtype TransactionId = TransactionId { unTransactionId :: Text } deriving (P.Eq, P.Show)

-- ** Unit
newtype Unit = Unit { unUnit :: Text } deriving (P.Eq, P.Show)

-- ** UtxoId
newtype UtxoId = UtxoId { unUtxoId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AccountDetails
-- | AccountDetails
-- Account Details of the tokens
data AccountDetails = AccountDetails
  { accountDetailsParentAccountId :: !(Maybe Text) -- ^ "parentAccountId"
  , accountDetailsAccountId :: !(Maybe Text) -- ^ "accountId"
  , accountDetailsUnit :: !(Maybe Text) -- ^ "unit"
  , accountDetailsOwningInstitutionId :: !(Maybe Text) -- ^ "owningInstitutionId"
  , accountDetailsAccountType :: !(Maybe Text) -- ^ "accountType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AccountDetails
instance A.FromJSON AccountDetails where
  parseJSON = A.withObject "AccountDetails" $ \o ->
    AccountDetails
      <$> (o .:? "parentAccountId")
      <*> (o .:? "accountId")
      <*> (o .:? "unit")
      <*> (o .:? "owningInstitutionId")
      <*> (o .:? "accountType")

-- | ToJSON AccountDetails
instance A.ToJSON AccountDetails where
  toJSON AccountDetails {..} =
   _omitNulls
      [ "parentAccountId" .= accountDetailsParentAccountId
      , "accountId" .= accountDetailsAccountId
      , "unit" .= accountDetailsUnit
      , "owningInstitutionId" .= accountDetailsOwningInstitutionId
      , "accountType" .= accountDetailsAccountType
      ]


-- | Construct a value of type 'AccountDetails' (by applying it's required fields, if any)
mkAccountDetails
  :: AccountDetails
mkAccountDetails =
  AccountDetails
  { accountDetailsParentAccountId = Nothing
  , accountDetailsAccountId = Nothing
  , accountDetailsUnit = Nothing
  , accountDetailsOwningInstitutionId = Nothing
  , accountDetailsAccountType = Nothing
  }

-- ** AddSecondaryAccountRequestDetailsSchema
-- | AddSecondaryAccountRequestDetailsSchema
data AddSecondaryAccountRequestDetailsSchema = AddSecondaryAccountRequestDetailsSchema
  { addSecondaryAccountRequestDetailsSchemaOwner :: !(Maybe SecondaryAccountOwnerSchema) -- ^ "owner"
  , addSecondaryAccountRequestDetailsSchemaAdditionalOwner :: !(Maybe SecondaryAccountAdditionalOwnerSchema) -- ^ "additionalOwner"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddSecondaryAccountRequestDetailsSchema
instance A.FromJSON AddSecondaryAccountRequestDetailsSchema where
  parseJSON = A.withObject "AddSecondaryAccountRequestDetailsSchema" $ \o ->
    AddSecondaryAccountRequestDetailsSchema
      <$> (o .:? "owner")
      <*> (o .:? "additionalOwner")

-- | ToJSON AddSecondaryAccountRequestDetailsSchema
instance A.ToJSON AddSecondaryAccountRequestDetailsSchema where
  toJSON AddSecondaryAccountRequestDetailsSchema {..} =
   _omitNulls
      [ "owner" .= addSecondaryAccountRequestDetailsSchemaOwner
      , "additionalOwner" .= addSecondaryAccountRequestDetailsSchemaAdditionalOwner
      ]


-- | Construct a value of type 'AddSecondaryAccountRequestDetailsSchema' (by applying it's required fields, if any)
mkAddSecondaryAccountRequestDetailsSchema
  :: AddSecondaryAccountRequestDetailsSchema
mkAddSecondaryAccountRequestDetailsSchema =
  AddSecondaryAccountRequestDetailsSchema
  { addSecondaryAccountRequestDetailsSchemaOwner = Nothing
  , addSecondaryAccountRequestDetailsSchemaAdditionalOwner = Nothing
  }

-- ** AdditionalOwner
-- | AdditionalOwner
-- Who is authorized as an operator on behalf of the Owner.
data AdditionalOwner = AdditionalOwner
  { additionalOwnerAccountId :: !(Maybe Text) -- ^ "accountId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdditionalOwner
instance A.FromJSON AdditionalOwner where
  parseJSON = A.withObject "AdditionalOwner" $ \o ->
    AdditionalOwner
      <$> (o .:? "accountId")

-- | ToJSON AdditionalOwner
instance A.ToJSON AdditionalOwner where
  toJSON AdditionalOwner {..} =
   _omitNulls
      [ "accountId" .= additionalOwnerAccountId
      ]


-- | Construct a value of type 'AdditionalOwner' (by applying it's required fields, if any)
mkAdditionalOwner
  :: AdditionalOwner
mkAdditionalOwner =
  AdditionalOwner
  { additionalOwnerAccountId = Nothing
  }

-- ** AdditionalOwnerRemoveSecondarySchema
-- | AdditionalOwnerRemoveSecondarySchema
-- Who are the additional owner of this transaction
data AdditionalOwnerRemoveSecondarySchema = AdditionalOwnerRemoveSecondarySchema
  { additionalOwnerRemoveSecondarySchemaAccountId :: !(Maybe Text) -- ^ "accountId" - Unique Identifier of the owner
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AdditionalOwnerRemoveSecondarySchema
instance A.FromJSON AdditionalOwnerRemoveSecondarySchema where
  parseJSON = A.withObject "AdditionalOwnerRemoveSecondarySchema" $ \o ->
    AdditionalOwnerRemoveSecondarySchema
      <$> (o .:? "accountId")

-- | ToJSON AdditionalOwnerRemoveSecondarySchema
instance A.ToJSON AdditionalOwnerRemoveSecondarySchema where
  toJSON AdditionalOwnerRemoveSecondarySchema {..} =
   _omitNulls
      [ "accountId" .= additionalOwnerRemoveSecondarySchemaAccountId
      ]


-- | Construct a value of type 'AdditionalOwnerRemoveSecondarySchema' (by applying it's required fields, if any)
mkAdditionalOwnerRemoveSecondarySchema
  :: AdditionalOwnerRemoveSecondarySchema
mkAdditionalOwnerRemoveSecondarySchema =
  AdditionalOwnerRemoveSecondarySchema
  { additionalOwnerRemoveSecondarySchemaAccountId = Nothing
  }

-- ** AddressBalanceResponse
-- | AddressBalanceResponse
data AddressBalanceResponse = AddressBalanceResponse
  { addressBalanceResponseUnit :: !(Maybe Text) -- ^ "unit"
  , addressBalanceResponseAmount :: !(Maybe Text) -- ^ "amount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressBalanceResponse
instance A.FromJSON AddressBalanceResponse where
  parseJSON = A.withObject "AddressBalanceResponse" $ \o ->
    AddressBalanceResponse
      <$> (o .:? "unit")
      <*> (o .:? "amount")

-- | ToJSON AddressBalanceResponse
instance A.ToJSON AddressBalanceResponse where
  toJSON AddressBalanceResponse {..} =
   _omitNulls
      [ "unit" .= addressBalanceResponseUnit
      , "amount" .= addressBalanceResponseAmount
      ]


-- | Construct a value of type 'AddressBalanceResponse' (by applying it's required fields, if any)
mkAddressBalanceResponse
  :: AddressBalanceResponse
mkAddressBalanceResponse =
  AddressBalanceResponse
  { addressBalanceResponseUnit = Nothing
  , addressBalanceResponseAmount = Nothing
  }

-- ** AddressMonitoringDetailsSchema
-- | AddressMonitoringDetailsSchema
data AddressMonitoringDetailsSchema = AddressMonitoringDetailsSchema
  { addressMonitoringDetailsSchemaLocation :: !(Maybe Location) -- ^ "location"
  , addressMonitoringDetailsSchemaAddressDetails :: !(Maybe ResourceMonitoredAddressDetails) -- ^ "addressDetails"
  , addressMonitoringDetailsSchemaType :: !(Maybe Text) -- ^ "type"
  , addressMonitoringDetailsSchemaTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressMonitoringDetailsSchema
instance A.FromJSON AddressMonitoringDetailsSchema where
  parseJSON = A.withObject "AddressMonitoringDetailsSchema" $ \o ->
    AddressMonitoringDetailsSchema
      <$> (o .:? "location")
      <*> (o .:? "addressDetails")
      <*> (o .:? "type")
      <*> (o .:? "timestamp")

-- | ToJSON AddressMonitoringDetailsSchema
instance A.ToJSON AddressMonitoringDetailsSchema where
  toJSON AddressMonitoringDetailsSchema {..} =
   _omitNulls
      [ "location" .= addressMonitoringDetailsSchemaLocation
      , "addressDetails" .= addressMonitoringDetailsSchemaAddressDetails
      , "type" .= addressMonitoringDetailsSchemaType
      , "timestamp" .= addressMonitoringDetailsSchemaTimestamp
      ]


-- | Construct a value of type 'AddressMonitoringDetailsSchema' (by applying it's required fields, if any)
mkAddressMonitoringDetailsSchema
  :: AddressMonitoringDetailsSchema
mkAddressMonitoringDetailsSchema =
  AddressMonitoringDetailsSchema
  { addressMonitoringDetailsSchemaLocation = Nothing
  , addressMonitoringDetailsSchemaAddressDetails = Nothing
  , addressMonitoringDetailsSchemaType = Nothing
  , addressMonitoringDetailsSchemaTimestamp = Nothing
  }

-- ** AddressMonitoringRequestSchema
-- | AddressMonitoringRequestSchema
data AddressMonitoringRequestSchema = AddressMonitoringRequestSchema
  { addressMonitoringRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  , addressMonitoringRequestSchemaCallBackUrl :: !(Maybe Text) -- ^ "callBackURL"
  , addressMonitoringRequestSchemaAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressMonitoringRequestSchema
instance A.FromJSON AddressMonitoringRequestSchema where
  parseJSON = A.withObject "AddressMonitoringRequestSchema" $ \o ->
    AddressMonitoringRequestSchema
      <$> (o .:? "location")
      <*> (o .:? "callBackURL")
      <*> (o .:? "addressId")

-- | ToJSON AddressMonitoringRequestSchema
instance A.ToJSON AddressMonitoringRequestSchema where
  toJSON AddressMonitoringRequestSchema {..} =
   _omitNulls
      [ "location" .= addressMonitoringRequestSchemaLocation
      , "callBackURL" .= addressMonitoringRequestSchemaCallBackUrl
      , "addressId" .= addressMonitoringRequestSchemaAddressId
      ]


-- | Construct a value of type 'AddressMonitoringRequestSchema' (by applying it's required fields, if any)
mkAddressMonitoringRequestSchema
  :: AddressMonitoringRequestSchema
mkAddressMonitoringRequestSchema =
  AddressMonitoringRequestSchema
  { addressMonitoringRequestSchemaLocation = Nothing
  , addressMonitoringRequestSchemaCallBackUrl = Nothing
  , addressMonitoringRequestSchemaAddressId = Nothing
  }

-- ** AddressMonitoringResponseSchema
-- | AddressMonitoringResponseSchema
data AddressMonitoringResponseSchema = AddressMonitoringResponseSchema
  { addressMonitoringResponseSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  , addressMonitoringResponseSchemaSubscriptionDetails :: !(Maybe ResourceMonitoringSubscriptionDetails) -- ^ "subscriptionDetails"
  , addressMonitoringResponseSchemaSubscription :: !(Maybe ResourceMonitoringSubscription) -- ^ "subscription"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AddressMonitoringResponseSchema
instance A.FromJSON AddressMonitoringResponseSchema where
  parseJSON = A.withObject "AddressMonitoringResponseSchema" $ \o ->
    AddressMonitoringResponseSchema
      <$> (o .:? "resourceMonitoring")
      <*> (o .:? "subscriptionDetails")
      <*> (o .:? "subscription")

-- | ToJSON AddressMonitoringResponseSchema
instance A.ToJSON AddressMonitoringResponseSchema where
  toJSON AddressMonitoringResponseSchema {..} =
   _omitNulls
      [ "resourceMonitoring" .= addressMonitoringResponseSchemaResourceMonitoring
      , "subscriptionDetails" .= addressMonitoringResponseSchemaSubscriptionDetails
      , "subscription" .= addressMonitoringResponseSchemaSubscription
      ]


-- | Construct a value of type 'AddressMonitoringResponseSchema' (by applying it's required fields, if any)
mkAddressMonitoringResponseSchema
  :: AddressMonitoringResponseSchema
mkAddressMonitoringResponseSchema =
  AddressMonitoringResponseSchema
  { addressMonitoringResponseSchemaResourceMonitoring = Nothing
  , addressMonitoringResponseSchemaSubscriptionDetails = Nothing
  , addressMonitoringResponseSchemaSubscription = Nothing
  }

-- ** AliasDetails
-- | AliasDetails
-- Alias Details of an account
data AliasDetails = AliasDetails
  { aliasDetailsAccountId :: !(Maybe Text) -- ^ "accountId"
  , aliasDetailsUnit :: !(Maybe Text) -- ^ "unit"
  , aliasDetailsDisposableAlias :: !(Maybe Bool) -- ^ "disposableAlias"
  , aliasDetailsAliasHash :: !(Maybe Text) -- ^ "aliasHash"
  , aliasDetailsAliasType :: !(Maybe Text) -- ^ "aliasType"
  , aliasDetailsEsipId :: !(Maybe Text) -- ^ "esipId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AliasDetails
instance A.FromJSON AliasDetails where
  parseJSON = A.withObject "AliasDetails" $ \o ->
    AliasDetails
      <$> (o .:? "accountId")
      <*> (o .:? "unit")
      <*> (o .:? "disposableAlias")
      <*> (o .:? "aliasHash")
      <*> (o .:? "aliasType")
      <*> (o .:? "esipId")

-- | ToJSON AliasDetails
instance A.ToJSON AliasDetails where
  toJSON AliasDetails {..} =
   _omitNulls
      [ "accountId" .= aliasDetailsAccountId
      , "unit" .= aliasDetailsUnit
      , "disposableAlias" .= aliasDetailsDisposableAlias
      , "aliasHash" .= aliasDetailsAliasHash
      , "aliasType" .= aliasDetailsAliasType
      , "esipId" .= aliasDetailsEsipId
      ]


-- | Construct a value of type 'AliasDetails' (by applying it's required fields, if any)
mkAliasDetails
  :: AliasDetails
mkAliasDetails =
  AliasDetails
  { aliasDetailsAccountId = Nothing
  , aliasDetailsUnit = Nothing
  , aliasDetailsDisposableAlias = Nothing
  , aliasDetailsAliasHash = Nothing
  , aliasDetailsAliasType = Nothing
  , aliasDetailsEsipId = Nothing
  }

-- ** ApproveRequestDetailsSchema
-- | ApproveRequestDetailsSchema
data ApproveRequestDetailsSchema = ApproveRequestDetailsSchema
  { approveRequestDetailsSchemaPayer :: !(Maybe [PayerCreditSchema]) -- ^ "payer" - Who are the payers of this transaction
  , approveRequestDetailsSchemaMandate :: !(Maybe [PayeeCreditSchema]) -- ^ "mandate" - Who are the payees of this transaction
  , approveRequestDetailsSchemaOverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ApproveRequestDetailsSchema
instance A.FromJSON ApproveRequestDetailsSchema where
  parseJSON = A.withObject "ApproveRequestDetailsSchema" $ \o ->
    ApproveRequestDetailsSchema
      <$> (o .:? "payer")
      <*> (o .:? "mandate")
      <*> (o .:? "overledgerSigningType")

-- | ToJSON ApproveRequestDetailsSchema
instance A.ToJSON ApproveRequestDetailsSchema where
  toJSON ApproveRequestDetailsSchema {..} =
   _omitNulls
      [ "payer" .= approveRequestDetailsSchemaPayer
      , "mandate" .= approveRequestDetailsSchemaMandate
      , "overledgerSigningType" .= approveRequestDetailsSchemaOverledgerSigningType
      ]


-- | Construct a value of type 'ApproveRequestDetailsSchema' (by applying it's required fields, if any)
mkApproveRequestDetailsSchema
  :: ApproveRequestDetailsSchema
mkApproveRequestDetailsSchema =
  ApproveRequestDetailsSchema
  { approveRequestDetailsSchemaPayer = Nothing
  , approveRequestDetailsSchemaMandate = Nothing
  , approveRequestDetailsSchemaOverledgerSigningType = Nothing
  }

-- ** AutoExecSearchAddressSequenceResponseSchema
-- | AutoExecSearchAddressSequenceResponseSchema
data AutoExecSearchAddressSequenceResponseSchema = AutoExecSearchAddressSequenceResponseSchema
  { autoExecSearchAddressSequenceResponseSchemaPrepareAndExecuteOverledgerErrorResponse :: !(Maybe PrepareAndExecuteOverledgerErrorResponse) -- ^ "prepareAndExecuteOverledgerErrorResponse"
  , autoExecSearchAddressSequenceResponseSchemaExecutionAddressSequenceSearchResponse :: !(Maybe ExecuteSearchSequenceResponse) -- ^ "executionAddressSequenceSearchResponse"
  , autoExecSearchAddressSequenceResponseSchemaPreparationAddressSequenceSearchResponse :: !(Maybe PrepareSearchResponseSchema) -- ^ "preparationAddressSequenceSearchResponse"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoExecSearchAddressSequenceResponseSchema
instance A.FromJSON AutoExecSearchAddressSequenceResponseSchema where
  parseJSON = A.withObject "AutoExecSearchAddressSequenceResponseSchema" $ \o ->
    AutoExecSearchAddressSequenceResponseSchema
      <$> (o .:? "prepareAndExecuteOverledgerErrorResponse")
      <*> (o .:? "executionAddressSequenceSearchResponse")
      <*> (o .:? "preparationAddressSequenceSearchResponse")

-- | ToJSON AutoExecSearchAddressSequenceResponseSchema
instance A.ToJSON AutoExecSearchAddressSequenceResponseSchema where
  toJSON AutoExecSearchAddressSequenceResponseSchema {..} =
   _omitNulls
      [ "prepareAndExecuteOverledgerErrorResponse" .= autoExecSearchAddressSequenceResponseSchemaPrepareAndExecuteOverledgerErrorResponse
      , "executionAddressSequenceSearchResponse" .= autoExecSearchAddressSequenceResponseSchemaExecutionAddressSequenceSearchResponse
      , "preparationAddressSequenceSearchResponse" .= autoExecSearchAddressSequenceResponseSchemaPreparationAddressSequenceSearchResponse
      ]


-- | Construct a value of type 'AutoExecSearchAddressSequenceResponseSchema' (by applying it's required fields, if any)
mkAutoExecSearchAddressSequenceResponseSchema
  :: AutoExecSearchAddressSequenceResponseSchema
mkAutoExecSearchAddressSequenceResponseSchema =
  AutoExecSearchAddressSequenceResponseSchema
  { autoExecSearchAddressSequenceResponseSchemaPrepareAndExecuteOverledgerErrorResponse = Nothing
  , autoExecSearchAddressSequenceResponseSchemaExecutionAddressSequenceSearchResponse = Nothing
  , autoExecSearchAddressSequenceResponseSchemaPreparationAddressSequenceSearchResponse = Nothing
  }

-- ** AutoExecuteSearchAddressBalanceResponseSchema
-- | AutoExecuteSearchAddressBalanceResponseSchema
data AutoExecuteSearchAddressBalanceResponseSchema = AutoExecuteSearchAddressBalanceResponseSchema
  { autoExecuteSearchAddressBalanceResponseSchemaPrepareAndExecuteOverledgerErrorResponse :: !(Maybe PrepareAndExecuteOverledgerErrorResponse) -- ^ "prepareAndExecuteOverledgerErrorResponse"
  , autoExecuteSearchAddressBalanceResponseSchemaExecutionAddressBalanceSearchResponse :: !(Maybe PrepareAndExecuteSearchAddressBalanceResponse) -- ^ "executionAddressBalanceSearchResponse"
  , autoExecuteSearchAddressBalanceResponseSchemaPreparationAddressBalanceSearchResponse :: !(Maybe PrepareSearchResponseSchema) -- ^ "preparationAddressBalanceSearchResponse"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoExecuteSearchAddressBalanceResponseSchema
instance A.FromJSON AutoExecuteSearchAddressBalanceResponseSchema where
  parseJSON = A.withObject "AutoExecuteSearchAddressBalanceResponseSchema" $ \o ->
    AutoExecuteSearchAddressBalanceResponseSchema
      <$> (o .:? "prepareAndExecuteOverledgerErrorResponse")
      <*> (o .:? "executionAddressBalanceSearchResponse")
      <*> (o .:? "preparationAddressBalanceSearchResponse")

-- | ToJSON AutoExecuteSearchAddressBalanceResponseSchema
instance A.ToJSON AutoExecuteSearchAddressBalanceResponseSchema where
  toJSON AutoExecuteSearchAddressBalanceResponseSchema {..} =
   _omitNulls
      [ "prepareAndExecuteOverledgerErrorResponse" .= autoExecuteSearchAddressBalanceResponseSchemaPrepareAndExecuteOverledgerErrorResponse
      , "executionAddressBalanceSearchResponse" .= autoExecuteSearchAddressBalanceResponseSchemaExecutionAddressBalanceSearchResponse
      , "preparationAddressBalanceSearchResponse" .= autoExecuteSearchAddressBalanceResponseSchemaPreparationAddressBalanceSearchResponse
      ]


-- | Construct a value of type 'AutoExecuteSearchAddressBalanceResponseSchema' (by applying it's required fields, if any)
mkAutoExecuteSearchAddressBalanceResponseSchema
  :: AutoExecuteSearchAddressBalanceResponseSchema
mkAutoExecuteSearchAddressBalanceResponseSchema =
  AutoExecuteSearchAddressBalanceResponseSchema
  { autoExecuteSearchAddressBalanceResponseSchemaPrepareAndExecuteOverledgerErrorResponse = Nothing
  , autoExecuteSearchAddressBalanceResponseSchemaExecutionAddressBalanceSearchResponse = Nothing
  , autoExecuteSearchAddressBalanceResponseSchemaPreparationAddressBalanceSearchResponse = Nothing
  }

-- ** AutoExecuteSearchBlockResponseSchema
-- | AutoExecuteSearchBlockResponseSchema
data AutoExecuteSearchBlockResponseSchema = AutoExecuteSearchBlockResponseSchema
  { autoExecuteSearchBlockResponseSchemaPrepareAndExecuteOverledgerErrorResponse :: !(Maybe PrepareAndExecuteOverledgerErrorResponse) -- ^ "prepareAndExecuteOverledgerErrorResponse"
  , autoExecuteSearchBlockResponseSchemaExecutionBlockSearchResponse :: !(Maybe ExecuteSearchBlockResponse) -- ^ "executionBlockSearchResponse"
  , autoExecuteSearchBlockResponseSchemaPreparationBlockSearchResponse :: !(Maybe PrepareSearchResponseSchema) -- ^ "preparationBlockSearchResponse"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoExecuteSearchBlockResponseSchema
instance A.FromJSON AutoExecuteSearchBlockResponseSchema where
  parseJSON = A.withObject "AutoExecuteSearchBlockResponseSchema" $ \o ->
    AutoExecuteSearchBlockResponseSchema
      <$> (o .:? "prepareAndExecuteOverledgerErrorResponse")
      <*> (o .:? "executionBlockSearchResponse")
      <*> (o .:? "preparationBlockSearchResponse")

-- | ToJSON AutoExecuteSearchBlockResponseSchema
instance A.ToJSON AutoExecuteSearchBlockResponseSchema where
  toJSON AutoExecuteSearchBlockResponseSchema {..} =
   _omitNulls
      [ "prepareAndExecuteOverledgerErrorResponse" .= autoExecuteSearchBlockResponseSchemaPrepareAndExecuteOverledgerErrorResponse
      , "executionBlockSearchResponse" .= autoExecuteSearchBlockResponseSchemaExecutionBlockSearchResponse
      , "preparationBlockSearchResponse" .= autoExecuteSearchBlockResponseSchemaPreparationBlockSearchResponse
      ]


-- | Construct a value of type 'AutoExecuteSearchBlockResponseSchema' (by applying it's required fields, if any)
mkAutoExecuteSearchBlockResponseSchema
  :: AutoExecuteSearchBlockResponseSchema
mkAutoExecuteSearchBlockResponseSchema =
  AutoExecuteSearchBlockResponseSchema
  { autoExecuteSearchBlockResponseSchemaPrepareAndExecuteOverledgerErrorResponse = Nothing
  , autoExecuteSearchBlockResponseSchemaExecutionBlockSearchResponse = Nothing
  , autoExecuteSearchBlockResponseSchemaPreparationBlockSearchResponse = Nothing
  }

-- ** AutoExecuteSearchUTXOResponseSchema
-- | AutoExecuteSearchUTXOResponseSchema
data AutoExecuteSearchUTXOResponseSchema = AutoExecuteSearchUTXOResponseSchema
  { autoExecuteSearchUTXOResponseSchemaExecutionUtxoSearchResponse :: !(Maybe ExecuteSearchUTXOResponse) -- ^ "executionUtxoSearchResponse"
  , autoExecuteSearchUTXOResponseSchemaPrepareAndExecuteOverledgerErrorResponse :: !(Maybe PrepareAndExecuteOverledgerErrorResponse) -- ^ "prepareAndExecuteOverledgerErrorResponse"
  , autoExecuteSearchUTXOResponseSchemaPreparationUtxoSearchResponse :: !(Maybe PrepareTransactionResponse) -- ^ "preparationUtxoSearchResponse"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AutoExecuteSearchUTXOResponseSchema
instance A.FromJSON AutoExecuteSearchUTXOResponseSchema where
  parseJSON = A.withObject "AutoExecuteSearchUTXOResponseSchema" $ \o ->
    AutoExecuteSearchUTXOResponseSchema
      <$> (o .:? "executionUtxoSearchResponse")
      <*> (o .:? "prepareAndExecuteOverledgerErrorResponse")
      <*> (o .:? "preparationUtxoSearchResponse")

-- | ToJSON AutoExecuteSearchUTXOResponseSchema
instance A.ToJSON AutoExecuteSearchUTXOResponseSchema where
  toJSON AutoExecuteSearchUTXOResponseSchema {..} =
   _omitNulls
      [ "executionUtxoSearchResponse" .= autoExecuteSearchUTXOResponseSchemaExecutionUtxoSearchResponse
      , "prepareAndExecuteOverledgerErrorResponse" .= autoExecuteSearchUTXOResponseSchemaPrepareAndExecuteOverledgerErrorResponse
      , "preparationUtxoSearchResponse" .= autoExecuteSearchUTXOResponseSchemaPreparationUtxoSearchResponse
      ]


-- | Construct a value of type 'AutoExecuteSearchUTXOResponseSchema' (by applying it's required fields, if any)
mkAutoExecuteSearchUTXOResponseSchema
  :: AutoExecuteSearchUTXOResponseSchema
mkAutoExecuteSearchUTXOResponseSchema =
  AutoExecuteSearchUTXOResponseSchema
  { autoExecuteSearchUTXOResponseSchemaExecutionUtxoSearchResponse = Nothing
  , autoExecuteSearchUTXOResponseSchemaPrepareAndExecuteOverledgerErrorResponse = Nothing
  , autoExecuteSearchUTXOResponseSchemaPreparationUtxoSearchResponse = Nothing
  }

-- ** Beneficiary
-- | Beneficiary
-- The Destination of this transaction
data Beneficiary = Beneficiary
  { beneficiaryAccountId :: !(Maybe Text) -- ^ "accountId" - The unique identifiers of the account
  , beneficiaryMint :: !(Maybe Mint) -- ^ "mint"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Beneficiary
instance A.FromJSON Beneficiary where
  parseJSON = A.withObject "Beneficiary" $ \o ->
    Beneficiary
      <$> (o .:? "accountId")
      <*> (o .:? "mint")

-- | ToJSON Beneficiary
instance A.ToJSON Beneficiary where
  toJSON Beneficiary {..} =
   _omitNulls
      [ "accountId" .= beneficiaryAccountId
      , "mint" .= beneficiaryMint
      ]


-- | Construct a value of type 'Beneficiary' (by applying it's required fields, if any)
mkBeneficiary
  :: Beneficiary
mkBeneficiary =
  Beneficiary
  { beneficiaryAccountId = Nothing
  , beneficiaryMint = Nothing
  }

-- ** BeneficiaryMintSchemaQrc20
-- | BeneficiaryMintSchemaQrc20
-- Who is the beneficiary of this transaction
data BeneficiaryMintSchemaQrc20 = BeneficiaryMintSchemaQrc20
  { beneficiaryMintSchemaQrc20AccountId :: !(Maybe Text) -- ^ "accountId" - The unique identifiers of the beneficiaries
  , beneficiaryMintSchemaQrc20Mint :: !(Maybe MintSchemaQrc20) -- ^ "mint"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BeneficiaryMintSchemaQrc20
instance A.FromJSON BeneficiaryMintSchemaQrc20 where
  parseJSON = A.withObject "BeneficiaryMintSchemaQrc20" $ \o ->
    BeneficiaryMintSchemaQrc20
      <$> (o .:? "accountId")
      <*> (o .:? "mint")

-- | ToJSON BeneficiaryMintSchemaQrc20
instance A.ToJSON BeneficiaryMintSchemaQrc20 where
  toJSON BeneficiaryMintSchemaQrc20 {..} =
   _omitNulls
      [ "accountId" .= beneficiaryMintSchemaQrc20AccountId
      , "mint" .= beneficiaryMintSchemaQrc20Mint
      ]


-- | Construct a value of type 'BeneficiaryMintSchemaQrc20' (by applying it's required fields, if any)
mkBeneficiaryMintSchemaQrc20
  :: BeneficiaryMintSchemaQrc20
mkBeneficiaryMintSchemaQrc20 =
  BeneficiaryMintSchemaQrc20
  { beneficiaryMintSchemaQrc20AccountId = Nothing
  , beneficiaryMintSchemaQrc20Mint = Nothing
  }

-- ** BeneficiaryMintSchemaQrc721
-- | BeneficiaryMintSchemaQrc721
-- Who is the beneficiary of this transaction
data BeneficiaryMintSchemaQrc721 = BeneficiaryMintSchemaQrc721
  { beneficiaryMintSchemaQrc721AccountId :: !(Maybe Text) -- ^ "accountId" - The unique identifiers of the beneficiaries
  , beneficiaryMintSchemaQrc721Mint :: !(Maybe MintSchemaQrc721) -- ^ "mint"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BeneficiaryMintSchemaQrc721
instance A.FromJSON BeneficiaryMintSchemaQrc721 where
  parseJSON = A.withObject "BeneficiaryMintSchemaQrc721" $ \o ->
    BeneficiaryMintSchemaQrc721
      <$> (o .:? "accountId")
      <*> (o .:? "mint")

-- | ToJSON BeneficiaryMintSchemaQrc721
instance A.ToJSON BeneficiaryMintSchemaQrc721 where
  toJSON BeneficiaryMintSchemaQrc721 {..} =
   _omitNulls
      [ "accountId" .= beneficiaryMintSchemaQrc721AccountId
      , "mint" .= beneficiaryMintSchemaQrc721Mint
      ]


-- | Construct a value of type 'BeneficiaryMintSchemaQrc721' (by applying it's required fields, if any)
mkBeneficiaryMintSchemaQrc721
  :: BeneficiaryMintSchemaQrc721
mkBeneficiaryMintSchemaQrc721 =
  BeneficiaryMintSchemaQrc721
  { beneficiaryMintSchemaQrc721AccountId = Nothing
  , beneficiaryMintSchemaQrc721Mint = Nothing
  }

-- ** Block
-- | Block
data Block = Block
  { blockBlockId :: !(Maybe Text) -- ^ "blockId"
  , blockNumber :: !(Maybe Int) -- ^ "number"
  , blockTransactionIds :: !(Maybe [Text]) -- ^ "transactionIds"
  , blockSize :: !(Maybe [BlockSize]) -- ^ "size"
  , blockHashes :: !(Maybe [BlockHash]) -- ^ "hashes"
  , blockLinkedBlocks :: !(Maybe LinkedBlocks) -- ^ "linkedBlocks"
  , blockNumberOfTransactions :: !(Maybe Int) -- ^ "numberOfTransactions"
  , blockMessage :: !(Maybe Text) -- ^ "message"
  , blockTimestamp :: !(Maybe Text) -- ^ "timestamp"
  , blockNativeData :: !(Maybe A.Value) -- ^ "nativeData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Block
instance A.FromJSON Block where
  parseJSON = A.withObject "Block" $ \o ->
    Block
      <$> (o .:? "blockId")
      <*> (o .:? "number")
      <*> (o .:? "transactionIds")
      <*> (o .:? "size")
      <*> (o .:? "hashes")
      <*> (o .:? "linkedBlocks")
      <*> (o .:? "numberOfTransactions")
      <*> (o .:? "message")
      <*> (o .:? "timestamp")
      <*> (o .:? "nativeData")

-- | ToJSON Block
instance A.ToJSON Block where
  toJSON Block {..} =
   _omitNulls
      [ "blockId" .= blockBlockId
      , "number" .= blockNumber
      , "transactionIds" .= blockTransactionIds
      , "size" .= blockSize
      , "hashes" .= blockHashes
      , "linkedBlocks" .= blockLinkedBlocks
      , "numberOfTransactions" .= blockNumberOfTransactions
      , "message" .= blockMessage
      , "timestamp" .= blockTimestamp
      , "nativeData" .= blockNativeData
      ]


-- | Construct a value of type 'Block' (by applying it's required fields, if any)
mkBlock
  :: Block
mkBlock =
  Block
  { blockBlockId = Nothing
  , blockNumber = Nothing
  , blockTransactionIds = Nothing
  , blockSize = Nothing
  , blockHashes = Nothing
  , blockLinkedBlocks = Nothing
  , blockNumberOfTransactions = Nothing
  , blockMessage = Nothing
  , blockTimestamp = Nothing
  , blockNativeData = Nothing
  }

-- ** BlockHash
-- | BlockHash
data BlockHash = BlockHash
  { blockHashType :: !(Maybe Text) -- ^ "type"
  , blockHashValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BlockHash
instance A.FromJSON BlockHash where
  parseJSON = A.withObject "BlockHash" $ \o ->
    BlockHash
      <$> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON BlockHash
instance A.ToJSON BlockHash where
  toJSON BlockHash {..} =
   _omitNulls
      [ "type" .= blockHashType
      , "value" .= blockHashValue
      ]


-- | Construct a value of type 'BlockHash' (by applying it's required fields, if any)
mkBlockHash
  :: BlockHash
mkBlockHash =
  BlockHash
  { blockHashType = Nothing
  , blockHashValue = Nothing
  }

-- ** BlockSize
-- | BlockSize
data BlockSize = BlockSize
  { blockSizeType :: !(Maybe Text) -- ^ "type"
  , blockSizeValue :: !(Maybe Text) -- ^ "value"
  , blockSizeKey :: !(Maybe Text) -- ^ "key"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BlockSize
instance A.FromJSON BlockSize where
  parseJSON = A.withObject "BlockSize" $ \o ->
    BlockSize
      <$> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "key")

-- | ToJSON BlockSize
instance A.ToJSON BlockSize where
  toJSON BlockSize {..} =
   _omitNulls
      [ "type" .= blockSizeType
      , "value" .= blockSizeValue
      , "key" .= blockSizeKey
      ]


-- | Construct a value of type 'BlockSize' (by applying it's required fields, if any)
mkBlockSize
  :: BlockSize
mkBlockSize =
  BlockSize
  { blockSizeType = Nothing
  , blockSizeValue = Nothing
  , blockSizeKey = Nothing
  }

-- ** Burn
-- | Burn
data Burn = Burn
  { burnTokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  , burnAmount :: !(Maybe Text) -- ^ "amount" - The amount of a currency
  , burnUnit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  , burnMetadata :: !(Maybe Text) -- ^ "metadata" - (Optional) String of metadata
  , burnTokenId :: !(Maybe Text) -- ^ "tokenId" - Unique identifier for the specific token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Burn
instance A.FromJSON Burn where
  parseJSON = A.withObject "Burn" $ \o ->
    Burn
      <$> (o .:? "tokenName")
      <*> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "metadata")
      <*> (o .:? "tokenId")

-- | ToJSON Burn
instance A.ToJSON Burn where
  toJSON Burn {..} =
   _omitNulls
      [ "tokenName" .= burnTokenName
      , "amount" .= burnAmount
      , "unit" .= burnUnit
      , "metadata" .= burnMetadata
      , "tokenId" .= burnTokenId
      ]


-- | Construct a value of type 'Burn' (by applying it's required fields, if any)
mkBurn
  :: Burn
mkBurn =
  Burn
  { burnTokenName = Nothing
  , burnAmount = Nothing
  , burnUnit = Nothing
  , burnMetadata = Nothing
  , burnTokenId = Nothing
  }

-- ** BurnRequestDetailsSchema
-- | BurnRequestDetailsSchema
data BurnRequestDetailsSchema = BurnRequestDetailsSchema
  { burnRequestDetailsSchemaOwner :: !(Maybe [OwnerBurnSchema]) -- ^ "owner" - Who is the owner of the tokens
  , burnRequestDetailsSchemaMessage :: !(Maybe Text) -- ^ "message" - Any text-based element of the data payload
  , burnRequestDetailsSchemaOverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BurnRequestDetailsSchema
instance A.FromJSON BurnRequestDetailsSchema where
  parseJSON = A.withObject "BurnRequestDetailsSchema" $ \o ->
    BurnRequestDetailsSchema
      <$> (o .:? "owner")
      <*> (o .:? "message")
      <*> (o .:? "overledgerSigningType")

-- | ToJSON BurnRequestDetailsSchema
instance A.ToJSON BurnRequestDetailsSchema where
  toJSON BurnRequestDetailsSchema {..} =
   _omitNulls
      [ "owner" .= burnRequestDetailsSchemaOwner
      , "message" .= burnRequestDetailsSchemaMessage
      , "overledgerSigningType" .= burnRequestDetailsSchemaOverledgerSigningType
      ]


-- | Construct a value of type 'BurnRequestDetailsSchema' (by applying it's required fields, if any)
mkBurnRequestDetailsSchema
  :: BurnRequestDetailsSchema
mkBurnRequestDetailsSchema =
  BurnRequestDetailsSchema
  { burnRequestDetailsSchemaOwner = Nothing
  , burnRequestDetailsSchemaMessage = Nothing
  , burnRequestDetailsSchemaOverledgerSigningType = Nothing
  }

-- ** BurnRequestDetailsSchemaQrc721
-- | BurnRequestDetailsSchemaQrc721
data BurnRequestDetailsSchemaQrc721 = BurnRequestDetailsSchemaQrc721
  { burnRequestDetailsSchemaQrc721Owner :: !(Maybe OwnerBurnSchema) -- ^ "owner"
  , burnRequestDetailsSchemaQrc721OverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BurnRequestDetailsSchemaQrc721
instance A.FromJSON BurnRequestDetailsSchemaQrc721 where
  parseJSON = A.withObject "BurnRequestDetailsSchemaQrc721" $ \o ->
    BurnRequestDetailsSchemaQrc721
      <$> (o .:? "owner")
      <*> (o .:? "overledgerSigningType")

-- | ToJSON BurnRequestDetailsSchemaQrc721
instance A.ToJSON BurnRequestDetailsSchemaQrc721 where
  toJSON BurnRequestDetailsSchemaQrc721 {..} =
   _omitNulls
      [ "owner" .= burnRequestDetailsSchemaQrc721Owner
      , "overledgerSigningType" .= burnRequestDetailsSchemaQrc721OverledgerSigningType
      ]


-- | Construct a value of type 'BurnRequestDetailsSchemaQrc721' (by applying it's required fields, if any)
mkBurnRequestDetailsSchemaQrc721
  :: BurnRequestDetailsSchemaQrc721
mkBurnRequestDetailsSchemaQrc721 =
  BurnRequestDetailsSchemaQrc721
  { burnRequestDetailsSchemaQrc721Owner = Nothing
  , burnRequestDetailsSchemaQrc721OverledgerSigningType = Nothing
  }

-- ** BurnSchema
-- | BurnSchema
data BurnSchema = BurnSchema
  { burnSchemaAmount :: !(Text) -- ^ /Required/ "amount" - The amount of a currency
  , burnSchemaUnit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BurnSchema
instance A.FromJSON BurnSchema where
  parseJSON = A.withObject "BurnSchema" $ \o ->
    BurnSchema
      <$> (o .:  "amount")
      <*> (o .:? "unit")

-- | ToJSON BurnSchema
instance A.ToJSON BurnSchema where
  toJSON BurnSchema {..} =
   _omitNulls
      [ "amount" .= burnSchemaAmount
      , "unit" .= burnSchemaUnit
      ]


-- | Construct a value of type 'BurnSchema' (by applying it's required fields, if any)
mkBurnSchema
  :: Text -- ^ 'burnSchemaAmount': The amount of a currency
  -> BurnSchema
mkBurnSchema burnSchemaAmount =
  BurnSchema
  { burnSchemaAmount
  , burnSchemaUnit = Nothing
  }

-- ** Collector
-- | Collector
-- Who is the collector of the tokens.
data Collector = Collector
  { collectorAccountId :: !(Maybe Text) -- ^ "accountId"
  , collectorTransfer :: !(Maybe Transfer) -- ^ "transfer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Collector
instance A.FromJSON Collector where
  parseJSON = A.withObject "Collector" $ \o ->
    Collector
      <$> (o .:? "accountId")
      <*> (o .:? "transfer")

-- | ToJSON Collector
instance A.ToJSON Collector where
  toJSON Collector {..} =
   _omitNulls
      [ "accountId" .= collectorAccountId
      , "transfer" .= collectorTransfer
      ]


-- | Construct a value of type 'Collector' (by applying it's required fields, if any)
mkCollector
  :: Collector
mkCollector =
  Collector
  { collectorAccountId = Nothing
  , collectorTransfer = Nothing
  }

-- ** CreateSmartContractMonitoringSchema
-- | CreateSmartContractMonitoringSchema
data CreateSmartContractMonitoringSchema = CreateSmartContractMonitoringSchema
  { createSmartContractMonitoringSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  , createSmartContractMonitoringSchemaSubscriptionDetails :: !(Maybe ResourceMonitoringSubscriptionDetails) -- ^ "subscriptionDetails"
  , createSmartContractMonitoringSchemaSubscription :: !(Maybe ResourceMonitoringSubscription) -- ^ "subscription"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSmartContractMonitoringSchema
instance A.FromJSON CreateSmartContractMonitoringSchema where
  parseJSON = A.withObject "CreateSmartContractMonitoringSchema" $ \o ->
    CreateSmartContractMonitoringSchema
      <$> (o .:? "resourceMonitoring")
      <*> (o .:? "subscriptionDetails")
      <*> (o .:? "subscription")

-- | ToJSON CreateSmartContractMonitoringSchema
instance A.ToJSON CreateSmartContractMonitoringSchema where
  toJSON CreateSmartContractMonitoringSchema {..} =
   _omitNulls
      [ "resourceMonitoring" .= createSmartContractMonitoringSchemaResourceMonitoring
      , "subscriptionDetails" .= createSmartContractMonitoringSchemaSubscriptionDetails
      , "subscription" .= createSmartContractMonitoringSchemaSubscription
      ]


-- | Construct a value of type 'CreateSmartContractMonitoringSchema' (by applying it's required fields, if any)
mkCreateSmartContractMonitoringSchema
  :: CreateSmartContractMonitoringSchema
mkCreateSmartContractMonitoringSchema =
  CreateSmartContractMonitoringSchema
  { createSmartContractMonitoringSchemaResourceMonitoring = Nothing
  , createSmartContractMonitoringSchemaSubscriptionDetails = Nothing
  , createSmartContractMonitoringSchemaSubscription = Nothing
  }

-- ** CreateWebhookSubscriptionRequestSchema
-- | CreateWebhookSubscriptionRequestSchema
data CreateWebhookSubscriptionRequestSchema = CreateWebhookSubscriptionRequestSchema
  { createWebhookSubscriptionRequestSchemaType :: !(Maybe Text) -- ^ "type"
  , createWebhookSubscriptionRequestSchemaIds :: !(Maybe [Text]) -- ^ "ids"
  , createWebhookSubscriptionRequestSchemaCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateWebhookSubscriptionRequestSchema
instance A.FromJSON CreateWebhookSubscriptionRequestSchema where
  parseJSON = A.withObject "CreateWebhookSubscriptionRequestSchema" $ \o ->
    CreateWebhookSubscriptionRequestSchema
      <$> (o .:? "type")
      <*> (o .:? "ids")
      <*> (o .:? "callbackUrl")

-- | ToJSON CreateWebhookSubscriptionRequestSchema
instance A.ToJSON CreateWebhookSubscriptionRequestSchema where
  toJSON CreateWebhookSubscriptionRequestSchema {..} =
   _omitNulls
      [ "type" .= createWebhookSubscriptionRequestSchemaType
      , "ids" .= createWebhookSubscriptionRequestSchemaIds
      , "callbackUrl" .= createWebhookSubscriptionRequestSchemaCallbackUrl
      ]


-- | Construct a value of type 'CreateWebhookSubscriptionRequestSchema' (by applying it's required fields, if any)
mkCreateWebhookSubscriptionRequestSchema
  :: CreateWebhookSubscriptionRequestSchema
mkCreateWebhookSubscriptionRequestSchema =
  CreateWebhookSubscriptionRequestSchema
  { createWebhookSubscriptionRequestSchemaType = Nothing
  , createWebhookSubscriptionRequestSchemaIds = Nothing
  , createWebhookSubscriptionRequestSchemaCallbackUrl = Nothing
  }

-- ** CreateWebhookSubscriptionResponseSchema
-- | CreateWebhookSubscriptionResponseSchema
data CreateWebhookSubscriptionResponseSchema = CreateWebhookSubscriptionResponseSchema
  { createWebhookSubscriptionResponseSchemaSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  , createWebhookSubscriptionResponseSchemaScubscriptionDetails :: !(Maybe WebhookSubscriptionDetailsSchema) -- ^ "scubscriptionDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateWebhookSubscriptionResponseSchema
instance A.FromJSON CreateWebhookSubscriptionResponseSchema where
  parseJSON = A.withObject "CreateWebhookSubscriptionResponseSchema" $ \o ->
    CreateWebhookSubscriptionResponseSchema
      <$> (o .:? "subscriptionId")
      <*> (o .:? "scubscriptionDetails")

-- | ToJSON CreateWebhookSubscriptionResponseSchema
instance A.ToJSON CreateWebhookSubscriptionResponseSchema where
  toJSON CreateWebhookSubscriptionResponseSchema {..} =
   _omitNulls
      [ "subscriptionId" .= createWebhookSubscriptionResponseSchemaSubscriptionId
      , "scubscriptionDetails" .= createWebhookSubscriptionResponseSchemaScubscriptionDetails
      ]


-- | Construct a value of type 'CreateWebhookSubscriptionResponseSchema' (by applying it's required fields, if any)
mkCreateWebhookSubscriptionResponseSchema
  :: CreateWebhookSubscriptionResponseSchema
mkCreateWebhookSubscriptionResponseSchema =
  CreateWebhookSubscriptionResponseSchema
  { createWebhookSubscriptionResponseSchemaSubscriptionId = Nothing
  , createWebhookSubscriptionResponseSchemaScubscriptionDetails = Nothing
  }

-- ** Creator
-- | Creator
-- Where is this transaction coming from
data Creator = Creator
  { creatorAccountId :: !(Maybe Text) -- ^ "accountId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Creator
instance A.FromJSON Creator where
  parseJSON = A.withObject "Creator" $ \o ->
    Creator
      <$> (o .:? "accountId")

-- | ToJSON Creator
instance A.ToJSON Creator where
  toJSON Creator {..} =
   _omitNulls
      [ "accountId" .= creatorAccountId
      ]


-- | Construct a value of type 'Creator' (by applying it's required fields, if any)
mkCreator
  :: Creator
mkCreator =
  Creator
  { creatorAccountId = Nothing
  }

-- ** CreatorMintSchema
-- | CreatorMintSchema
-- Who is the creator of this transaction
data CreatorMintSchema = CreatorMintSchema
  { creatorMintSchemaAccountId :: !(Maybe Text) -- ^ "accountId" - Unique Identifier of the creator
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreatorMintSchema
instance A.FromJSON CreatorMintSchema where
  parseJSON = A.withObject "CreatorMintSchema" $ \o ->
    CreatorMintSchema
      <$> (o .:? "accountId")

-- | ToJSON CreatorMintSchema
instance A.ToJSON CreatorMintSchema where
  toJSON CreatorMintSchema {..} =
   _omitNulls
      [ "accountId" .= creatorMintSchemaAccountId
      ]


-- | Construct a value of type 'CreatorMintSchema' (by applying it's required fields, if any)
mkCreatorMintSchema
  :: CreatorMintSchema
mkCreatorMintSchema =
  CreatorMintSchema
  { creatorMintSchemaAccountId = Nothing
  }

-- ** CreditRequestDetailsSchema
-- | CreditRequestDetailsSchema
data CreditRequestDetailsSchema = CreditRequestDetailsSchema
  { creditRequestDetailsSchemaPayee :: !(Maybe [PayeeCreditSchema]) -- ^ "payee" - Who are the payees of this transaction
  , creditRequestDetailsSchemaMessage :: !(Maybe Text) -- ^ "message" - Any text-based element of the data payload
  , creditRequestDetailsSchemaPayer :: !(Maybe [PayerCreditSchema]) -- ^ "payer" - Who are the payers of this transaction
  , creditRequestDetailsSchemaOverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreditRequestDetailsSchema
instance A.FromJSON CreditRequestDetailsSchema where
  parseJSON = A.withObject "CreditRequestDetailsSchema" $ \o ->
    CreditRequestDetailsSchema
      <$> (o .:? "payee")
      <*> (o .:? "message")
      <*> (o .:? "payer")
      <*> (o .:? "overledgerSigningType")

-- | ToJSON CreditRequestDetailsSchema
instance A.ToJSON CreditRequestDetailsSchema where
  toJSON CreditRequestDetailsSchema {..} =
   _omitNulls
      [ "payee" .= creditRequestDetailsSchemaPayee
      , "message" .= creditRequestDetailsSchemaMessage
      , "payer" .= creditRequestDetailsSchemaPayer
      , "overledgerSigningType" .= creditRequestDetailsSchemaOverledgerSigningType
      ]


-- | Construct a value of type 'CreditRequestDetailsSchema' (by applying it's required fields, if any)
mkCreditRequestDetailsSchema
  :: CreditRequestDetailsSchema
mkCreditRequestDetailsSchema =
  CreditRequestDetailsSchema
  { creditRequestDetailsSchemaPayee = Nothing
  , creditRequestDetailsSchemaMessage = Nothing
  , creditRequestDetailsSchemaPayer = Nothing
  , creditRequestDetailsSchemaOverledgerSigningType = Nothing
  }

-- ** DeleteResourceMonitoringAddressSchema
-- | DeleteResourceMonitoringAddressSchema
data DeleteResourceMonitoringAddressSchema = DeleteResourceMonitoringAddressSchema
  { deleteResourceMonitoringAddressSchemaAddressMonitoringDetails :: !(Maybe ResourceMonitoringAddressDetails) -- ^ "addressMonitoringDetails"
  , deleteResourceMonitoringAddressSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteResourceMonitoringAddressSchema
instance A.FromJSON DeleteResourceMonitoringAddressSchema where
  parseJSON = A.withObject "DeleteResourceMonitoringAddressSchema" $ \o ->
    DeleteResourceMonitoringAddressSchema
      <$> (o .:? "addressMonitoringDetails")
      <*> (o .:? "resourceMonitoring")

-- | ToJSON DeleteResourceMonitoringAddressSchema
instance A.ToJSON DeleteResourceMonitoringAddressSchema where
  toJSON DeleteResourceMonitoringAddressSchema {..} =
   _omitNulls
      [ "addressMonitoringDetails" .= deleteResourceMonitoringAddressSchemaAddressMonitoringDetails
      , "resourceMonitoring" .= deleteResourceMonitoringAddressSchemaResourceMonitoring
      ]


-- | Construct a value of type 'DeleteResourceMonitoringAddressSchema' (by applying it's required fields, if any)
mkDeleteResourceMonitoringAddressSchema
  :: DeleteResourceMonitoringAddressSchema
mkDeleteResourceMonitoringAddressSchema =
  DeleteResourceMonitoringAddressSchema
  { deleteResourceMonitoringAddressSchemaAddressMonitoringDetails = Nothing
  , deleteResourceMonitoringAddressSchemaResourceMonitoring = Nothing
  }

-- ** Destination
-- | Destination
-- The Destination of this transaction
data Destination = Destination
  { destinationPayment :: !(Maybe Payment) -- ^ "payment"
  , destinationTransfer :: !(Maybe Transfer) -- ^ "transfer"
  , destinationDestinationId :: !(Maybe Text) -- ^ "destinationId" - The unique identifier of the destination
  , destinationSmartContract :: !(Maybe SmartContract) -- ^ "smartContract"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Destination
instance A.FromJSON Destination where
  parseJSON = A.withObject "Destination" $ \o ->
    Destination
      <$> (o .:? "payment")
      <*> (o .:? "transfer")
      <*> (o .:? "destinationId")
      <*> (o .:? "smartContract")

-- | ToJSON Destination
instance A.ToJSON Destination where
  toJSON Destination {..} =
   _omitNulls
      [ "payment" .= destinationPayment
      , "transfer" .= destinationTransfer
      , "destinationId" .= destinationDestinationId
      , "smartContract" .= destinationSmartContract
      ]


-- | Construct a value of type 'Destination' (by applying it's required fields, if any)
mkDestination
  :: Destination
mkDestination =
  Destination
  { destinationPayment = Nothing
  , destinationTransfer = Nothing
  , destinationDestinationId = Nothing
  , destinationSmartContract = Nothing
  }

-- ** DestinationPaymentSchema
-- | DestinationPaymentSchema
-- List of the recipients of this transaction.  **Warning:** Bitcoin transaction fees will be deducted from the last destination provided in the transaction payment request. If the last destination payment value is not enough to cover the fees, your Bitcoin payment transaction will fail
data DestinationPaymentSchema = DestinationPaymentSchema
  { destinationPaymentSchemaDestinationId :: !(Text) -- ^ /Required/ "destinationId" - Unique identifier of the destination/recipient
  , destinationPaymentSchemaPayment :: !(PaymentSchema) -- ^ /Required/ "payment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DestinationPaymentSchema
instance A.FromJSON DestinationPaymentSchema where
  parseJSON = A.withObject "DestinationPaymentSchema" $ \o ->
    DestinationPaymentSchema
      <$> (o .:  "destinationId")
      <*> (o .:  "payment")

-- | ToJSON DestinationPaymentSchema
instance A.ToJSON DestinationPaymentSchema where
  toJSON DestinationPaymentSchema {..} =
   _omitNulls
      [ "destinationId" .= destinationPaymentSchemaDestinationId
      , "payment" .= destinationPaymentSchemaPayment
      ]


-- | Construct a value of type 'DestinationPaymentSchema' (by applying it's required fields, if any)
mkDestinationPaymentSchema
  :: Text -- ^ 'destinationPaymentSchemaDestinationId': Unique identifier of the destination/recipient
  -> PaymentSchema -- ^ 'destinationPaymentSchemaPayment' 
  -> DestinationPaymentSchema
mkDestinationPaymentSchema destinationPaymentSchemaDestinationId destinationPaymentSchemaPayment =
  DestinationPaymentSchema
  { destinationPaymentSchemaDestinationId
  , destinationPaymentSchemaPayment
  }

-- ** DestinationTransferSchema
-- | DestinationTransferSchema
data DestinationTransferSchema = DestinationTransferSchema
  { destinationTransferSchemaDestinationId :: !(Maybe Text) -- ^ "destinationId"
  , destinationTransferSchemaTransfer :: !(Maybe TransferSchema) -- ^ "transfer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DestinationTransferSchema
instance A.FromJSON DestinationTransferSchema where
  parseJSON = A.withObject "DestinationTransferSchema" $ \o ->
    DestinationTransferSchema
      <$> (o .:? "destinationId")
      <*> (o .:? "transfer")

-- | ToJSON DestinationTransferSchema
instance A.ToJSON DestinationTransferSchema where
  toJSON DestinationTransferSchema {..} =
   _omitNulls
      [ "destinationId" .= destinationTransferSchemaDestinationId
      , "transfer" .= destinationTransferSchemaTransfer
      ]


-- | Construct a value of type 'DestinationTransferSchema' (by applying it's required fields, if any)
mkDestinationTransferSchema
  :: DestinationTransferSchema
mkDestinationTransferSchema =
  DestinationTransferSchema
  { destinationTransferSchemaDestinationId = Nothing
  , destinationTransferSchemaTransfer = Nothing
  }

-- ** Erc20DTO
-- | Erc20DTO
data Erc20DTO = Erc20DTO
  { erc20DTOIsQrc20 :: !(Maybe Bool) -- ^ "isQrc20"
  , erc20DTOTokenUnit :: !(Maybe Text) -- ^ "tokenUnit"
  , erc20DTODecimalPlaces :: !(Maybe Int) -- ^ "decimalPlaces"
  , erc20DTOFunctions :: !(Maybe [TierFunctionDTO]) -- ^ "functions"
  , erc20DTOTokenName :: !(Maybe Text) -- ^ "tokenName"
  , erc20DTOSmartContractAddress :: !(Maybe Text) -- ^ "smartContractAddress"
  , erc20DTOLocation :: !(Maybe LocationDTO) -- ^ "location"
  , erc20DTOVersion :: !(Maybe Text) -- ^ "version"
  , erc20DTOUrl :: !(Maybe Text) -- ^ "url"
  , erc20DTOAuditDate :: !(Maybe Date) -- ^ "auditDate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Erc20DTO
instance A.FromJSON Erc20DTO where
  parseJSON = A.withObject "Erc20DTO" $ \o ->
    Erc20DTO
      <$> (o .:? "isQrc20")
      <*> (o .:? "tokenUnit")
      <*> (o .:? "decimalPlaces")
      <*> (o .:? "functions")
      <*> (o .:? "tokenName")
      <*> (o .:? "smartContractAddress")
      <*> (o .:? "location")
      <*> (o .:? "version")
      <*> (o .:? "url")
      <*> (o .:? "auditDate")

-- | ToJSON Erc20DTO
instance A.ToJSON Erc20DTO where
  toJSON Erc20DTO {..} =
   _omitNulls
      [ "isQrc20" .= erc20DTOIsQrc20
      , "tokenUnit" .= erc20DTOTokenUnit
      , "decimalPlaces" .= erc20DTODecimalPlaces
      , "functions" .= erc20DTOFunctions
      , "tokenName" .= erc20DTOTokenName
      , "smartContractAddress" .= erc20DTOSmartContractAddress
      , "location" .= erc20DTOLocation
      , "version" .= erc20DTOVersion
      , "url" .= erc20DTOUrl
      , "auditDate" .= erc20DTOAuditDate
      ]


-- | Construct a value of type 'Erc20DTO' (by applying it's required fields, if any)
mkErc20DTO
  :: Erc20DTO
mkErc20DTO =
  Erc20DTO
  { erc20DTOIsQrc20 = Nothing
  , erc20DTOTokenUnit = Nothing
  , erc20DTODecimalPlaces = Nothing
  , erc20DTOFunctions = Nothing
  , erc20DTOTokenName = Nothing
  , erc20DTOSmartContractAddress = Nothing
  , erc20DTOLocation = Nothing
  , erc20DTOVersion = Nothing
  , erc20DTOUrl = Nothing
  , erc20DTOAuditDate = Nothing
  }

-- ** Error
-- | Error
data Error = Error
  { errorCode :: !(Maybe Int) -- ^ "code"
  , errorMessage :: !(Maybe Text) -- ^ "message"
  , errorService :: !(Maybe Text) -- ^ "service"
  , errorTimestamp :: !(Maybe Integer) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:? "code")
      <*> (o .:? "message")
      <*> (o .:? "service")
      <*> (o .:? "timestamp")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "code" .= errorCode
      , "message" .= errorMessage
      , "service" .= errorService
      , "timestamp" .= errorTimestamp
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Error
mkError =
  Error
  { errorCode = Nothing
  , errorMessage = Nothing
  , errorService = Nothing
  , errorTimestamp = Nothing
  }

-- ** ErrorDetails
-- | ErrorDetails
data ErrorDetails = ErrorDetails
  { errorDetailsCategory :: !(Maybe Text) -- ^ "category"
  , errorDetailsDescription :: !(Maybe Text) -- ^ "description"
  , errorDetailsCode :: !(Maybe Text) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorDetails
instance A.FromJSON ErrorDetails where
  parseJSON = A.withObject "ErrorDetails" $ \o ->
    ErrorDetails
      <$> (o .:? "category")
      <*> (o .:? "description")
      <*> (o .:? "code")

-- | ToJSON ErrorDetails
instance A.ToJSON ErrorDetails where
  toJSON ErrorDetails {..} =
   _omitNulls
      [ "category" .= errorDetailsCategory
      , "description" .= errorDetailsDescription
      , "code" .= errorDetailsCode
      ]


-- | Construct a value of type 'ErrorDetails' (by applying it's required fields, if any)
mkErrorDetails
  :: ErrorDetails
mkErrorDetails =
  ErrorDetails
  { errorDetailsCategory = Nothing
  , errorDetailsDescription = Nothing
  , errorDetailsCode = Nothing
  }

-- ** ErrorList
-- | ErrorList
data ErrorList = ErrorList
  { errorListErrors :: !(Maybe [Error]) -- ^ "errors"
  , errorListErrorCount :: !(Maybe Int) -- ^ "errorCount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorList
instance A.FromJSON ErrorList where
  parseJSON = A.withObject "ErrorList" $ \o ->
    ErrorList
      <$> (o .:? "errors")
      <*> (o .:? "errorCount")

-- | ToJSON ErrorList
instance A.ToJSON ErrorList where
  toJSON ErrorList {..} =
   _omitNulls
      [ "errors" .= errorListErrors
      , "errorCount" .= errorListErrorCount
      ]


-- | Construct a value of type 'ErrorList' (by applying it's required fields, if any)
mkErrorList
  :: ErrorList
mkErrorList =
  ErrorList
  { errorListErrors = Nothing
  , errorListErrorCount = Nothing
  }

-- ** ErrorResponseMessage
-- | ErrorResponseMessage
data ErrorResponseMessage = ErrorResponseMessage
  { errorResponseMessageCode :: !(Maybe Int) -- ^ "code"
  , errorResponseMessageErrorMessageExtraDetails :: !(Maybe A.Value) -- ^ "errorMessageExtraDetails"
  , errorResponseMessageSubCode :: !(Maybe Int) -- ^ "subCode"
  , errorResponseMessageLogTraceId :: !(Maybe Text) -- ^ "logTraceId"
  , errorResponseMessageType :: !(Maybe Text) -- ^ "type"
  , errorResponseMessageTitle :: !(Maybe Text) -- ^ "title"
  , errorResponseMessageMessage :: !(Maybe Text) -- ^ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponseMessage
instance A.FromJSON ErrorResponseMessage where
  parseJSON = A.withObject "ErrorResponseMessage" $ \o ->
    ErrorResponseMessage
      <$> (o .:? "code")
      <*> (o .:? "errorMessageExtraDetails")
      <*> (o .:? "subCode")
      <*> (o .:? "logTraceId")
      <*> (o .:? "type")
      <*> (o .:? "title")
      <*> (o .:? "message")

-- | ToJSON ErrorResponseMessage
instance A.ToJSON ErrorResponseMessage where
  toJSON ErrorResponseMessage {..} =
   _omitNulls
      [ "code" .= errorResponseMessageCode
      , "errorMessageExtraDetails" .= errorResponseMessageErrorMessageExtraDetails
      , "subCode" .= errorResponseMessageSubCode
      , "logTraceId" .= errorResponseMessageLogTraceId
      , "type" .= errorResponseMessageType
      , "title" .= errorResponseMessageTitle
      , "message" .= errorResponseMessageMessage
      ]


-- | Construct a value of type 'ErrorResponseMessage' (by applying it's required fields, if any)
mkErrorResponseMessage
  :: ErrorResponseMessage
mkErrorResponseMessage =
  ErrorResponseMessage
  { errorResponseMessageCode = Nothing
  , errorResponseMessageErrorMessageExtraDetails = Nothing
  , errorResponseMessageSubCode = Nothing
  , errorResponseMessageLogTraceId = Nothing
  , errorResponseMessageType = Nothing
  , errorResponseMessageTitle = Nothing
  , errorResponseMessageMessage = Nothing
  }

-- ** EventSubscriptionResponse
-- | EventSubscriptionResponse
data EventSubscriptionResponse = EventSubscriptionResponse
  { eventSubscriptionResponseTokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  , eventSubscriptionResponseSubscriptionDetails :: !(Maybe EventSubscriptionResponseDetails) -- ^ "subscriptionDetails"
  , eventSubscriptionResponseLocation :: !(Maybe Location) -- ^ "location"
  , eventSubscriptionResponseType :: !(Maybe Text) -- ^ "type" - Type of event
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventSubscriptionResponse
instance A.FromJSON EventSubscriptionResponse where
  parseJSON = A.withObject "EventSubscriptionResponse" $ \o ->
    EventSubscriptionResponse
      <$> (o .:? "tokenName")
      <*> (o .:? "subscriptionDetails")
      <*> (o .:? "location")
      <*> (o .:? "type")

-- | ToJSON EventSubscriptionResponse
instance A.ToJSON EventSubscriptionResponse where
  toJSON EventSubscriptionResponse {..} =
   _omitNulls
      [ "tokenName" .= eventSubscriptionResponseTokenName
      , "subscriptionDetails" .= eventSubscriptionResponseSubscriptionDetails
      , "location" .= eventSubscriptionResponseLocation
      , "type" .= eventSubscriptionResponseType
      ]


-- | Construct a value of type 'EventSubscriptionResponse' (by applying it's required fields, if any)
mkEventSubscriptionResponse
  :: EventSubscriptionResponse
mkEventSubscriptionResponse =
  EventSubscriptionResponse
  { eventSubscriptionResponseTokenName = Nothing
  , eventSubscriptionResponseSubscriptionDetails = Nothing
  , eventSubscriptionResponseLocation = Nothing
  , eventSubscriptionResponseType = Nothing
  }

-- ** EventSubscriptionResponseDetails
-- | EventSubscriptionResponseDetails
data EventSubscriptionResponseDetails = EventSubscriptionResponseDetails
  { eventSubscriptionResponseDetailsSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  , eventSubscriptionResponseDetailsCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  , eventSubscriptionResponseDetailsCreatedDate :: !(Maybe Text) -- ^ "createdDate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON EventSubscriptionResponseDetails
instance A.FromJSON EventSubscriptionResponseDetails where
  parseJSON = A.withObject "EventSubscriptionResponseDetails" $ \o ->
    EventSubscriptionResponseDetails
      <$> (o .:? "subscriptionId")
      <*> (o .:? "callbackUrl")
      <*> (o .:? "createdDate")

-- | ToJSON EventSubscriptionResponseDetails
instance A.ToJSON EventSubscriptionResponseDetails where
  toJSON EventSubscriptionResponseDetails {..} =
   _omitNulls
      [ "subscriptionId" .= eventSubscriptionResponseDetailsSubscriptionId
      , "callbackUrl" .= eventSubscriptionResponseDetailsCallbackUrl
      , "createdDate" .= eventSubscriptionResponseDetailsCreatedDate
      ]


-- | Construct a value of type 'EventSubscriptionResponseDetails' (by applying it's required fields, if any)
mkEventSubscriptionResponseDetails
  :: EventSubscriptionResponseDetails
mkEventSubscriptionResponseDetails =
  EventSubscriptionResponseDetails
  { eventSubscriptionResponseDetailsSubscriptionId = Nothing
  , eventSubscriptionResponseDetailsCallbackUrl = Nothing
  , eventSubscriptionResponseDetailsCreatedDate = Nothing
  }

-- ** ExecuteSearchBalanceResponse
-- | ExecuteSearchBalanceResponse
data ExecuteSearchBalanceResponse = ExecuteSearchBalanceResponse
  { executeSearchBalanceResponseBalances :: !(Maybe [AddressBalanceResponse]) -- ^ "balances"
  , executeSearchBalanceResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchBalanceResponseTimestamp :: !(Maybe Text) -- ^ "timestamp"
  , executeSearchBalanceResponseAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchBalanceResponse
instance A.FromJSON ExecuteSearchBalanceResponse where
  parseJSON = A.withObject "ExecuteSearchBalanceResponse" $ \o ->
    ExecuteSearchBalanceResponse
      <$> (o .:? "balances")
      <*> (o .:? "location")
      <*> (o .:? "timestamp")
      <*> (o .:? "addressId")

-- | ToJSON ExecuteSearchBalanceResponse
instance A.ToJSON ExecuteSearchBalanceResponse where
  toJSON ExecuteSearchBalanceResponse {..} =
   _omitNulls
      [ "balances" .= executeSearchBalanceResponseBalances
      , "location" .= executeSearchBalanceResponseLocation
      , "timestamp" .= executeSearchBalanceResponseTimestamp
      , "addressId" .= executeSearchBalanceResponseAddressId
      ]


-- | Construct a value of type 'ExecuteSearchBalanceResponse' (by applying it's required fields, if any)
mkExecuteSearchBalanceResponse
  :: ExecuteSearchBalanceResponse
mkExecuteSearchBalanceResponse =
  ExecuteSearchBalanceResponse
  { executeSearchBalanceResponseBalances = Nothing
  , executeSearchBalanceResponseLocation = Nothing
  , executeSearchBalanceResponseTimestamp = Nothing
  , executeSearchBalanceResponseAddressId = Nothing
  }

-- ** ExecuteSearchBlockResponse
-- | ExecuteSearchBlockResponse
data ExecuteSearchBlockResponse = ExecuteSearchBlockResponse
  { executeSearchBlockResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchBlockResponseBlock :: !(Maybe Block) -- ^ "block"
  , executeSearchBlockResponseStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchBlockResponse
instance A.FromJSON ExecuteSearchBlockResponse where
  parseJSON = A.withObject "ExecuteSearchBlockResponse" $ \o ->
    ExecuteSearchBlockResponse
      <$> (o .:? "location")
      <*> (o .:? "block")
      <*> (o .:? "status")

-- | ToJSON ExecuteSearchBlockResponse
instance A.ToJSON ExecuteSearchBlockResponse where
  toJSON ExecuteSearchBlockResponse {..} =
   _omitNulls
      [ "location" .= executeSearchBlockResponseLocation
      , "block" .= executeSearchBlockResponseBlock
      , "status" .= executeSearchBlockResponseStatus
      ]


-- | Construct a value of type 'ExecuteSearchBlockResponse' (by applying it's required fields, if any)
mkExecuteSearchBlockResponse
  :: ExecuteSearchBlockResponse
mkExecuteSearchBlockResponse =
  ExecuteSearchBlockResponse
  { executeSearchBlockResponseLocation = Nothing
  , executeSearchBlockResponseBlock = Nothing
  , executeSearchBlockResponseStatus = Nothing
  }

-- ** ExecuteSearchSequenceResponse
-- | ExecuteSearchSequenceResponse
data ExecuteSearchSequenceResponse = ExecuteSearchSequenceResponse
  { executeSearchSequenceResponseSequence :: !(Maybe Text) -- ^ "sequence"
  , executeSearchSequenceResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchSequenceResponseTimestamp :: !(Maybe Text) -- ^ "timestamp"
  , executeSearchSequenceResponseAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchSequenceResponse
instance A.FromJSON ExecuteSearchSequenceResponse where
  parseJSON = A.withObject "ExecuteSearchSequenceResponse" $ \o ->
    ExecuteSearchSequenceResponse
      <$> (o .:? "sequence")
      <*> (o .:? "location")
      <*> (o .:? "timestamp")
      <*> (o .:? "addressId")

-- | ToJSON ExecuteSearchSequenceResponse
instance A.ToJSON ExecuteSearchSequenceResponse where
  toJSON ExecuteSearchSequenceResponse {..} =
   _omitNulls
      [ "sequence" .= executeSearchSequenceResponseSequence
      , "location" .= executeSearchSequenceResponseLocation
      , "timestamp" .= executeSearchSequenceResponseTimestamp
      , "addressId" .= executeSearchSequenceResponseAddressId
      ]


-- | Construct a value of type 'ExecuteSearchSequenceResponse' (by applying it's required fields, if any)
mkExecuteSearchSequenceResponse
  :: ExecuteSearchSequenceResponse
mkExecuteSearchSequenceResponse =
  ExecuteSearchSequenceResponse
  { executeSearchSequenceResponseSequence = Nothing
  , executeSearchSequenceResponseLocation = Nothing
  , executeSearchSequenceResponseTimestamp = Nothing
  , executeSearchSequenceResponseAddressId = Nothing
  }

-- ** ExecuteSearchTransactionResponse
-- | ExecuteSearchTransactionResponse
data ExecuteSearchTransactionResponse = ExecuteSearchTransactionResponse
  { executeSearchTransactionResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchTransactionResponseType :: !(Maybe Text) -- ^ "type" - The type of the transaction object returned
  , executeSearchTransactionResponseTransaction :: !(Maybe Transaction) -- ^ "transaction"
  , executeSearchTransactionResponseTimestamp :: !(Maybe Text) -- ^ "timestamp" - The unix time to read the object from
  , executeSearchTransactionResponseStatus :: !(Maybe Status) -- ^ "status"
  , executeSearchTransactionResponseExtraFields :: !(Maybe A.Value) -- ^ "extraFields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchTransactionResponse
instance A.FromJSON ExecuteSearchTransactionResponse where
  parseJSON = A.withObject "ExecuteSearchTransactionResponse" $ \o ->
    ExecuteSearchTransactionResponse
      <$> (o .:? "location")
      <*> (o .:? "type")
      <*> (o .:? "transaction")
      <*> (o .:? "timestamp")
      <*> (o .:? "status")
      <*> (o .:? "extraFields")

-- | ToJSON ExecuteSearchTransactionResponse
instance A.ToJSON ExecuteSearchTransactionResponse where
  toJSON ExecuteSearchTransactionResponse {..} =
   _omitNulls
      [ "location" .= executeSearchTransactionResponseLocation
      , "type" .= executeSearchTransactionResponseType
      , "transaction" .= executeSearchTransactionResponseTransaction
      , "timestamp" .= executeSearchTransactionResponseTimestamp
      , "status" .= executeSearchTransactionResponseStatus
      , "extraFields" .= executeSearchTransactionResponseExtraFields
      ]


-- | Construct a value of type 'ExecuteSearchTransactionResponse' (by applying it's required fields, if any)
mkExecuteSearchTransactionResponse
  :: ExecuteSearchTransactionResponse
mkExecuteSearchTransactionResponse =
  ExecuteSearchTransactionResponse
  { executeSearchTransactionResponseLocation = Nothing
  , executeSearchTransactionResponseType = Nothing
  , executeSearchTransactionResponseTransaction = Nothing
  , executeSearchTransactionResponseTimestamp = Nothing
  , executeSearchTransactionResponseStatus = Nothing
  , executeSearchTransactionResponseExtraFields = Nothing
  }

-- ** ExecuteSearchUTXOResponse
-- | ExecuteSearchUTXOResponse
data ExecuteSearchUTXOResponse = ExecuteSearchUTXOResponse
  { executeSearchUTXOResponseUtxoId :: !(Maybe Text) -- ^ "utxoId"
  , executeSearchUTXOResponseDestination :: !(Maybe [Destination]) -- ^ "destination"
  , executeSearchUTXOResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchUTXOResponseTimestamp :: !(Maybe Text) -- ^ "timestamp"
  , executeSearchUTXOResponseStatus :: !(Maybe Status) -- ^ "status"
  , executeSearchUTXOResponseNativeData :: !(Maybe A.Value) -- ^ "nativeData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchUTXOResponse
instance A.FromJSON ExecuteSearchUTXOResponse where
  parseJSON = A.withObject "ExecuteSearchUTXOResponse" $ \o ->
    ExecuteSearchUTXOResponse
      <$> (o .:? "utxoId")
      <*> (o .:? "destination")
      <*> (o .:? "location")
      <*> (o .:? "timestamp")
      <*> (o .:? "status")
      <*> (o .:? "nativeData")

-- | ToJSON ExecuteSearchUTXOResponse
instance A.ToJSON ExecuteSearchUTXOResponse where
  toJSON ExecuteSearchUTXOResponse {..} =
   _omitNulls
      [ "utxoId" .= executeSearchUTXOResponseUtxoId
      , "destination" .= executeSearchUTXOResponseDestination
      , "location" .= executeSearchUTXOResponseLocation
      , "timestamp" .= executeSearchUTXOResponseTimestamp
      , "status" .= executeSearchUTXOResponseStatus
      , "nativeData" .= executeSearchUTXOResponseNativeData
      ]


-- | Construct a value of type 'ExecuteSearchUTXOResponse' (by applying it's required fields, if any)
mkExecuteSearchUTXOResponse
  :: ExecuteSearchUTXOResponse
mkExecuteSearchUTXOResponse =
  ExecuteSearchUTXOResponse
  { executeSearchUTXOResponseUtxoId = Nothing
  , executeSearchUTXOResponseDestination = Nothing
  , executeSearchUTXOResponseLocation = Nothing
  , executeSearchUTXOResponseTimestamp = Nothing
  , executeSearchUTXOResponseStatus = Nothing
  , executeSearchUTXOResponseNativeData = Nothing
  }

-- ** ExecuteSearchUTXOResponseSchema
-- | ExecuteSearchUTXOResponseSchema
data ExecuteSearchUTXOResponseSchema = ExecuteSearchUTXOResponseSchema
  { executeSearchUTXOResponseSchemaUtxoId :: !(Maybe Text) -- ^ "utxoId"
  , executeSearchUTXOResponseSchemaDestination :: !(Maybe [UTXODestination]) -- ^ "destination"
  , executeSearchUTXOResponseSchemaLocation :: !(Maybe Location) -- ^ "location"
  , executeSearchUTXOResponseSchemaTimestamp :: !(Maybe Text) -- ^ "timestamp"
  , executeSearchUTXOResponseSchemaStatus :: !(Maybe Status) -- ^ "status"
  , executeSearchUTXOResponseSchemaNativeData :: !(Maybe UTXONativeData) -- ^ "nativeData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSearchUTXOResponseSchema
instance A.FromJSON ExecuteSearchUTXOResponseSchema where
  parseJSON = A.withObject "ExecuteSearchUTXOResponseSchema" $ \o ->
    ExecuteSearchUTXOResponseSchema
      <$> (o .:? "utxoId")
      <*> (o .:? "destination")
      <*> (o .:? "location")
      <*> (o .:? "timestamp")
      <*> (o .:? "status")
      <*> (o .:? "nativeData")

-- | ToJSON ExecuteSearchUTXOResponseSchema
instance A.ToJSON ExecuteSearchUTXOResponseSchema where
  toJSON ExecuteSearchUTXOResponseSchema {..} =
   _omitNulls
      [ "utxoId" .= executeSearchUTXOResponseSchemaUtxoId
      , "destination" .= executeSearchUTXOResponseSchemaDestination
      , "location" .= executeSearchUTXOResponseSchemaLocation
      , "timestamp" .= executeSearchUTXOResponseSchemaTimestamp
      , "status" .= executeSearchUTXOResponseSchemaStatus
      , "nativeData" .= executeSearchUTXOResponseSchemaNativeData
      ]


-- | Construct a value of type 'ExecuteSearchUTXOResponseSchema' (by applying it's required fields, if any)
mkExecuteSearchUTXOResponseSchema
  :: ExecuteSearchUTXOResponseSchema
mkExecuteSearchUTXOResponseSchema =
  ExecuteSearchUTXOResponseSchema
  { executeSearchUTXOResponseSchemaUtxoId = Nothing
  , executeSearchUTXOResponseSchemaDestination = Nothing
  , executeSearchUTXOResponseSchemaLocation = Nothing
  , executeSearchUTXOResponseSchemaTimestamp = Nothing
  , executeSearchUTXOResponseSchemaStatus = Nothing
  , executeSearchUTXOResponseSchemaNativeData = Nothing
  }

-- ** ExecuteSmartContractReadResponseSchema
-- | ExecuteSmartContractReadResponseSchema
data ExecuteSmartContractReadResponseSchema = ExecuteSmartContractReadResponseSchema
  { executeSmartContractReadResponseSchemaSmartContract :: !(Maybe SmartContractReadSchema) -- ^ "smartContract"
  , executeSmartContractReadResponseSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteSmartContractReadResponseSchema
instance A.FromJSON ExecuteSmartContractReadResponseSchema where
  parseJSON = A.withObject "ExecuteSmartContractReadResponseSchema" $ \o ->
    ExecuteSmartContractReadResponseSchema
      <$> (o .:? "smartContract")
      <*> (o .:? "location")

-- | ToJSON ExecuteSmartContractReadResponseSchema
instance A.ToJSON ExecuteSmartContractReadResponseSchema where
  toJSON ExecuteSmartContractReadResponseSchema {..} =
   _omitNulls
      [ "smartContract" .= executeSmartContractReadResponseSchemaSmartContract
      , "location" .= executeSmartContractReadResponseSchemaLocation
      ]


-- | Construct a value of type 'ExecuteSmartContractReadResponseSchema' (by applying it's required fields, if any)
mkExecuteSmartContractReadResponseSchema
  :: ExecuteSmartContractReadResponseSchema
mkExecuteSmartContractReadResponseSchema =
  ExecuteSmartContractReadResponseSchema
  { executeSmartContractReadResponseSchemaSmartContract = Nothing
  , executeSmartContractReadResponseSchemaLocation = Nothing
  }

-- ** ExecuteTransactionRequest
-- | ExecuteTransactionRequest
data ExecuteTransactionRequest = ExecuteTransactionRequest
  { executeTransactionRequestSigned :: !(Maybe Text) -- ^ "signed" - The raw data after transaction signing
  , executeTransactionRequestRequestId :: !(Text) -- ^ /Required/ "requestId" - The ID assigned to a preparation request in Overledger
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteTransactionRequest
instance A.FromJSON ExecuteTransactionRequest where
  parseJSON = A.withObject "ExecuteTransactionRequest" $ \o ->
    ExecuteTransactionRequest
      <$> (o .:? "signed")
      <*> (o .:  "requestId")

-- | ToJSON ExecuteTransactionRequest
instance A.ToJSON ExecuteTransactionRequest where
  toJSON ExecuteTransactionRequest {..} =
   _omitNulls
      [ "signed" .= executeTransactionRequestSigned
      , "requestId" .= executeTransactionRequestRequestId
      ]


-- | Construct a value of type 'ExecuteTransactionRequest' (by applying it's required fields, if any)
mkExecuteTransactionRequest
  :: Text -- ^ 'executeTransactionRequestRequestId': The ID assigned to a preparation request in Overledger
  -> ExecuteTransactionRequest
mkExecuteTransactionRequest executeTransactionRequestRequestId =
  ExecuteTransactionRequest
  { executeTransactionRequestSigned = Nothing
  , executeTransactionRequestRequestId
  }

-- ** ExecuteTransactionResponse
-- | ExecuteTransactionResponse
data ExecuteTransactionResponse = ExecuteTransactionResponse
  { executeTransactionResponseUrgency :: !(Maybe Text) -- ^ "urgency"
  , executeTransactionResponseRequestId :: !(Maybe Text) -- ^ "requestId" - The ID assigned to a preparation request in Overledger
  , executeTransactionResponseOverledgerTransactionId :: !(Maybe Text) -- ^ "overledgerTransactionId"
  , executeTransactionResponseLocation :: !(Maybe Location) -- ^ "location"
  , executeTransactionResponseType :: !(Maybe Text) -- ^ "type" - The type of the transaction executed
  , executeTransactionResponseTransactionId :: !(Maybe Text) -- ^ "transactionId" - The ID assigned by Overledger to a transaction submitted to a DLT via Overledger
  , executeTransactionResponseStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExecuteTransactionResponse
instance A.FromJSON ExecuteTransactionResponse where
  parseJSON = A.withObject "ExecuteTransactionResponse" $ \o ->
    ExecuteTransactionResponse
      <$> (o .:? "urgency")
      <*> (o .:? "requestId")
      <*> (o .:? "overledgerTransactionId")
      <*> (o .:? "location")
      <*> (o .:? "type")
      <*> (o .:? "transactionId")
      <*> (o .:? "status")

-- | ToJSON ExecuteTransactionResponse
instance A.ToJSON ExecuteTransactionResponse where
  toJSON ExecuteTransactionResponse {..} =
   _omitNulls
      [ "urgency" .= executeTransactionResponseUrgency
      , "requestId" .= executeTransactionResponseRequestId
      , "overledgerTransactionId" .= executeTransactionResponseOverledgerTransactionId
      , "location" .= executeTransactionResponseLocation
      , "type" .= executeTransactionResponseType
      , "transactionId" .= executeTransactionResponseTransactionId
      , "status" .= executeTransactionResponseStatus
      ]


-- | Construct a value of type 'ExecuteTransactionResponse' (by applying it's required fields, if any)
mkExecuteTransactionResponse
  :: ExecuteTransactionResponse
mkExecuteTransactionResponse =
  ExecuteTransactionResponse
  { executeTransactionResponseUrgency = Nothing
  , executeTransactionResponseRequestId = Nothing
  , executeTransactionResponseOverledgerTransactionId = Nothing
  , executeTransactionResponseLocation = Nothing
  , executeTransactionResponseType = Nothing
  , executeTransactionResponseTransactionId = Nothing
  , executeTransactionResponseStatus = Nothing
  }

-- ** ExtraFields
-- | ExtraFields
data ExtraFields = ExtraFields
  { extraFieldsRequiredSignatures :: !(Maybe Double) -- ^ "requiredSignatures"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ExtraFields
instance A.FromJSON ExtraFields where
  parseJSON = A.withObject "ExtraFields" $ \o ->
    ExtraFields
      <$> (o .:? "requiredSignatures")

-- | ToJSON ExtraFields
instance A.ToJSON ExtraFields where
  toJSON ExtraFields {..} =
   _omitNulls
      [ "requiredSignatures" .= extraFieldsRequiredSignatures
      ]


-- | Construct a value of type 'ExtraFields' (by applying it's required fields, if any)
mkExtraFields
  :: ExtraFields
mkExtraFields =
  ExtraFields
  { extraFieldsRequiredSignatures = Nothing
  }

-- ** Fee
-- | Fee
data Fee = Fee
  { feeAmount :: !(Text) -- ^ /Required/ "amount" - The amount of a currency
  , feeUnit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Fee
instance A.FromJSON Fee where
  parseJSON = A.withObject "Fee" $ \o ->
    Fee
      <$> (o .:  "amount")
      <*> (o .:? "unit")

-- | ToJSON Fee
instance A.ToJSON Fee where
  toJSON Fee {..} =
   _omitNulls
      [ "amount" .= feeAmount
      , "unit" .= feeUnit
      ]


-- | Construct a value of type 'Fee' (by applying it's required fields, if any)
mkFee
  :: Text -- ^ 'feeAmount': The amount of a currency
  -> Fee
mkFee feeAmount =
  Fee
  { feeAmount
  , feeUnit = Nothing
  }

-- ** Function
-- | Function
data Function = Function
  { functionType :: !(Maybe Text) -- ^ "type"
  , functionApi :: !(Maybe Text) -- ^ "api"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Function
instance A.FromJSON Function where
  parseJSON = A.withObject "Function" $ \o ->
    Function
      <$> (o .:? "type")
      <*> (o .:? "api")

-- | ToJSON Function
instance A.ToJSON Function where
  toJSON Function {..} =
   _omitNulls
      [ "type" .= functionType
      , "api" .= functionApi
      ]


-- | Construct a value of type 'Function' (by applying it's required fields, if any)
mkFunction
  :: Function
mkFunction =
  Function
  { functionType = Nothing
  , functionApi = Nothing
  }

-- ** FunctionDTO
-- | FunctionDTO
data FunctionDTO = FunctionDTO
  { functionDTOType :: !(Maybe Text) -- ^ "type"
  , functionDTOApi :: !(Maybe Text) -- ^ "api"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FunctionDTO
instance A.FromJSON FunctionDTO where
  parseJSON = A.withObject "FunctionDTO" $ \o ->
    FunctionDTO
      <$> (o .:? "type")
      <*> (o .:? "api")

-- | ToJSON FunctionDTO
instance A.ToJSON FunctionDTO where
  toJSON FunctionDTO {..} =
   _omitNulls
      [ "type" .= functionDTOType
      , "api" .= functionDTOApi
      ]


-- | Construct a value of type 'FunctionDTO' (by applying it's required fields, if any)
mkFunctionDTO
  :: FunctionDTO
mkFunctionDTO =
  FunctionDTO
  { functionDTOType = Nothing
  , functionDTOApi = Nothing
  }

-- ** FungibleTokenResponseDTO
-- | FungibleTokenResponseDTO
data FungibleTokenResponseDTO = FungibleTokenResponseDTO
  { fungibleTokenResponseDTODocumentationUrl :: !(Maybe Text) -- ^ "documentationUrl"
  , fungibleTokenResponseDTOUnit :: !(Maybe Text) -- ^ "unit"
  , fungibleTokenResponseDTODecimalPlaces :: !(Maybe Int) -- ^ "decimalPlaces"
  , fungibleTokenResponseDTOFunctions :: !(Maybe [FunctionDTO]) -- ^ "functions"
  , fungibleTokenResponseDTOContractType :: !(Maybe E'ContractType) -- ^ "contractType"
  , fungibleTokenResponseDTOLocation :: !(Maybe LocationDTO) -- ^ "location"
  , fungibleTokenResponseDTOSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FungibleTokenResponseDTO
instance A.FromJSON FungibleTokenResponseDTO where
  parseJSON = A.withObject "FungibleTokenResponseDTO" $ \o ->
    FungibleTokenResponseDTO
      <$> (o .:? "documentationUrl")
      <*> (o .:? "unit")
      <*> (o .:? "decimalPlaces")
      <*> (o .:? "functions")
      <*> (o .:? "contractType")
      <*> (o .:? "location")
      <*> (o .:? "smartContractId")

-- | ToJSON FungibleTokenResponseDTO
instance A.ToJSON FungibleTokenResponseDTO where
  toJSON FungibleTokenResponseDTO {..} =
   _omitNulls
      [ "documentationUrl" .= fungibleTokenResponseDTODocumentationUrl
      , "unit" .= fungibleTokenResponseDTOUnit
      , "decimalPlaces" .= fungibleTokenResponseDTODecimalPlaces
      , "functions" .= fungibleTokenResponseDTOFunctions
      , "contractType" .= fungibleTokenResponseDTOContractType
      , "location" .= fungibleTokenResponseDTOLocation
      , "smartContractId" .= fungibleTokenResponseDTOSmartContractId
      ]


-- | Construct a value of type 'FungibleTokenResponseDTO' (by applying it's required fields, if any)
mkFungibleTokenResponseDTO
  :: FungibleTokenResponseDTO
mkFungibleTokenResponseDTO =
  FungibleTokenResponseDTO
  { fungibleTokenResponseDTODocumentationUrl = Nothing
  , fungibleTokenResponseDTOUnit = Nothing
  , fungibleTokenResponseDTODecimalPlaces = Nothing
  , fungibleTokenResponseDTOFunctions = Nothing
  , fungibleTokenResponseDTOContractType = Nothing
  , fungibleTokenResponseDTOLocation = Nothing
  , fungibleTokenResponseDTOSmartContractId = Nothing
  }

-- ** InternalServerErrorSchema
-- | InternalServerErrorSchema
data InternalServerErrorSchema = InternalServerErrorSchema
  { internalServerErrorSchemaPath :: !(Maybe Text) -- ^ "path"
  , internalServerErrorSchemaError :: !(Maybe Text) -- ^ "error"
  , internalServerErrorSchemaMessage :: !(Maybe Text) -- ^ "message"
  , internalServerErrorSchemaTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  , internalServerErrorSchemaStatus :: !(Maybe Int) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON InternalServerErrorSchema
instance A.FromJSON InternalServerErrorSchema where
  parseJSON = A.withObject "InternalServerErrorSchema" $ \o ->
    InternalServerErrorSchema
      <$> (o .:? "path")
      <*> (o .:? "error")
      <*> (o .:? "message")
      <*> (o .:? "timestamp")
      <*> (o .:? "status")

-- | ToJSON InternalServerErrorSchema
instance A.ToJSON InternalServerErrorSchema where
  toJSON InternalServerErrorSchema {..} =
   _omitNulls
      [ "path" .= internalServerErrorSchemaPath
      , "error" .= internalServerErrorSchemaError
      , "message" .= internalServerErrorSchemaMessage
      , "timestamp" .= internalServerErrorSchemaTimestamp
      , "status" .= internalServerErrorSchemaStatus
      ]


-- | Construct a value of type 'InternalServerErrorSchema' (by applying it's required fields, if any)
mkInternalServerErrorSchema
  :: InternalServerErrorSchema
mkInternalServerErrorSchema =
  InternalServerErrorSchema
  { internalServerErrorSchemaPath = Nothing
  , internalServerErrorSchemaError = Nothing
  , internalServerErrorSchemaMessage = Nothing
  , internalServerErrorSchemaTimestamp = Nothing
  , internalServerErrorSchemaStatus = Nothing
  }

-- ** LinkedBlocks
-- | LinkedBlocks
data LinkedBlocks = LinkedBlocks
  { linkedBlocksParent :: !(Maybe Text) -- ^ "parent"
  , linkedBlocksChild :: !(Maybe Text) -- ^ "child"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LinkedBlocks
instance A.FromJSON LinkedBlocks where
  parseJSON = A.withObject "LinkedBlocks" $ \o ->
    LinkedBlocks
      <$> (o .:? "parent")
      <*> (o .:? "child")

-- | ToJSON LinkedBlocks
instance A.ToJSON LinkedBlocks where
  toJSON LinkedBlocks {..} =
   _omitNulls
      [ "parent" .= linkedBlocksParent
      , "child" .= linkedBlocksChild
      ]


-- | Construct a value of type 'LinkedBlocks' (by applying it's required fields, if any)
mkLinkedBlocks
  :: LinkedBlocks
mkLinkedBlocks =
  LinkedBlocks
  { linkedBlocksParent = Nothing
  , linkedBlocksChild = Nothing
  }

-- ** ListWebhookSubscriptionResponseSchema
-- | ListWebhookSubscriptionResponseSchema
data ListWebhookSubscriptionResponseSchema = ListWebhookSubscriptionResponseSchema
  { listWebhookSubscriptionResponseSchemaSubscriptionDetails :: !(Maybe WebhookSubscriptionDetailsSchema) -- ^ "subscriptionDetails"
  , listWebhookSubscriptionResponseSchemaLastUpdatedTime :: !(Maybe DateTime) -- ^ "lastUpdatedTime"
  , listWebhookSubscriptionResponseSchemaCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  , listWebhookSubscriptionResponseSchemaSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  , listWebhookSubscriptionResponseSchemaType :: !(Maybe Text) -- ^ "type"
  , listWebhookSubscriptionResponseSchemaSubscribedTime :: !(Maybe DateTime) -- ^ "subscribedTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListWebhookSubscriptionResponseSchema
instance A.FromJSON ListWebhookSubscriptionResponseSchema where
  parseJSON = A.withObject "ListWebhookSubscriptionResponseSchema" $ \o ->
    ListWebhookSubscriptionResponseSchema
      <$> (o .:? "subscriptionDetails")
      <*> (o .:? "lastUpdatedTime")
      <*> (o .:? "callbackUrl")
      <*> (o .:? "subscriptionId")
      <*> (o .:? "type")
      <*> (o .:? "subscribedTime")

-- | ToJSON ListWebhookSubscriptionResponseSchema
instance A.ToJSON ListWebhookSubscriptionResponseSchema where
  toJSON ListWebhookSubscriptionResponseSchema {..} =
   _omitNulls
      [ "subscriptionDetails" .= listWebhookSubscriptionResponseSchemaSubscriptionDetails
      , "lastUpdatedTime" .= listWebhookSubscriptionResponseSchemaLastUpdatedTime
      , "callbackUrl" .= listWebhookSubscriptionResponseSchemaCallbackUrl
      , "subscriptionId" .= listWebhookSubscriptionResponseSchemaSubscriptionId
      , "type" .= listWebhookSubscriptionResponseSchemaType
      , "subscribedTime" .= listWebhookSubscriptionResponseSchemaSubscribedTime
      ]


-- | Construct a value of type 'ListWebhookSubscriptionResponseSchema' (by applying it's required fields, if any)
mkListWebhookSubscriptionResponseSchema
  :: ListWebhookSubscriptionResponseSchema
mkListWebhookSubscriptionResponseSchema =
  ListWebhookSubscriptionResponseSchema
  { listWebhookSubscriptionResponseSchemaSubscriptionDetails = Nothing
  , listWebhookSubscriptionResponseSchemaLastUpdatedTime = Nothing
  , listWebhookSubscriptionResponseSchemaCallbackUrl = Nothing
  , listWebhookSubscriptionResponseSchemaSubscriptionId = Nothing
  , listWebhookSubscriptionResponseSchemaType = Nothing
  , listWebhookSubscriptionResponseSchemaSubscribedTime = Nothing
  }

-- ** Location
-- | Location
-- Unique reference to the ledger on a particular ledger network (optionally accessed from a particular node)
data Location = Location
  { locationTechnology :: !(Text) -- ^ /Required/ "technology" - The technology used by the desired network
  , locationNetwork :: !(Text) -- ^ /Required/ "network" - The network that the ledger resides on
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Location
instance A.FromJSON Location where
  parseJSON = A.withObject "Location" $ \o ->
    Location
      <$> (o .:  "technology")
      <*> (o .:  "network")

-- | ToJSON Location
instance A.ToJSON Location where
  toJSON Location {..} =
   _omitNulls
      [ "technology" .= locationTechnology
      , "network" .= locationNetwork
      ]


-- | Construct a value of type 'Location' (by applying it's required fields, if any)
mkLocation
  :: Text -- ^ 'locationTechnology': The technology used by the desired network
  -> Text -- ^ 'locationNetwork': The network that the ledger resides on
  -> Location
mkLocation locationTechnology locationNetwork =
  Location
  { locationTechnology
  , locationNetwork
  }

-- ** LocationDTO
-- | LocationDTO
data LocationDTO = LocationDTO
  { locationDTOTechnology :: !(Maybe Text) -- ^ "technology"
  , locationDTONetwork :: !(Maybe Text) -- ^ "network"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LocationDTO
instance A.FromJSON LocationDTO where
  parseJSON = A.withObject "LocationDTO" $ \o ->
    LocationDTO
      <$> (o .:? "technology")
      <*> (o .:? "network")

-- | ToJSON LocationDTO
instance A.ToJSON LocationDTO where
  toJSON LocationDTO {..} =
   _omitNulls
      [ "technology" .= locationDTOTechnology
      , "network" .= locationDTONetwork
      ]


-- | Construct a value of type 'LocationDTO' (by applying it's required fields, if any)
mkLocationDTO
  :: LocationDTO
mkLocationDTO =
  LocationDTO
  { locationDTOTechnology = Nothing
  , locationDTONetwork = Nothing
  }

-- ** LockDetails
-- | LockDetails
-- Lock Details of the tokens
data LockDetails = LockDetails
  { lockDetailsExpiryDate :: !(Maybe Text) -- ^ "expiryDate"
  , lockDetailsLockId :: !(Maybe Text) -- ^ "lockId"
  , lockDetailsAccountId :: !(Maybe Text) -- ^ "accountId"
  , lockDetailsAmount :: !(Maybe Text) -- ^ "amount"
  , lockDetailsUnit :: !(Maybe Text) -- ^ "unit"
  , lockDetailsAccountOwningInstitutionId :: !(Maybe Text) -- ^ "accountOwningInstitutionId"
  , lockDetailsLockDescription :: !(Maybe Text) -- ^ "lockDescription"
  , lockDetailsPayeeId :: !(Maybe Text) -- ^ "payeeId"
  , lockDetailsSecret :: !(Maybe Text) -- ^ "secret"
  , lockDetailsHash :: !(Maybe Text) -- ^ "hash"
  , lockDetailsPayeeOwningInstitutionId :: !(Maybe Text) -- ^ "payeeOwningInstitutionId"
  , lockDetailsLockOwningInstitutionId :: !(Maybe Text) -- ^ "lockOwningInstitutionId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON LockDetails
instance A.FromJSON LockDetails where
  parseJSON = A.withObject "LockDetails" $ \o ->
    LockDetails
      <$> (o .:? "expiryDate")
      <*> (o .:? "lockId")
      <*> (o .:? "accountId")
      <*> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "accountOwningInstitutionId")
      <*> (o .:? "lockDescription")
      <*> (o .:? "payeeId")
      <*> (o .:? "secret")
      <*> (o .:? "hash")
      <*> (o .:? "payeeOwningInstitutionId")
      <*> (o .:? "lockOwningInstitutionId")

-- | ToJSON LockDetails
instance A.ToJSON LockDetails where
  toJSON LockDetails {..} =
   _omitNulls
      [ "expiryDate" .= lockDetailsExpiryDate
      , "lockId" .= lockDetailsLockId
      , "accountId" .= lockDetailsAccountId
      , "amount" .= lockDetailsAmount
      , "unit" .= lockDetailsUnit
      , "accountOwningInstitutionId" .= lockDetailsAccountOwningInstitutionId
      , "lockDescription" .= lockDetailsLockDescription
      , "payeeId" .= lockDetailsPayeeId
      , "secret" .= lockDetailsSecret
      , "hash" .= lockDetailsHash
      , "payeeOwningInstitutionId" .= lockDetailsPayeeOwningInstitutionId
      , "lockOwningInstitutionId" .= lockDetailsLockOwningInstitutionId
      ]


-- | Construct a value of type 'LockDetails' (by applying it's required fields, if any)
mkLockDetails
  :: LockDetails
mkLockDetails =
  LockDetails
  { lockDetailsExpiryDate = Nothing
  , lockDetailsLockId = Nothing
  , lockDetailsAccountId = Nothing
  , lockDetailsAmount = Nothing
  , lockDetailsUnit = Nothing
  , lockDetailsAccountOwningInstitutionId = Nothing
  , lockDetailsLockDescription = Nothing
  , lockDetailsPayeeId = Nothing
  , lockDetailsSecret = Nothing
  , lockDetailsHash = Nothing
  , lockDetailsPayeeOwningInstitutionId = Nothing
  , lockDetailsLockOwningInstitutionId = Nothing
  }

-- ** Mandate
-- | Mandate
-- The Destination of this transaction
data Mandate = Mandate
  { mandatePayment :: !(Maybe Payment) -- ^ "payment"
  , mandatePayeeId :: !(Maybe Text) -- ^ "payeeId" - The unique identifiers of the payee
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Mandate
instance A.FromJSON Mandate where
  parseJSON = A.withObject "Mandate" $ \o ->
    Mandate
      <$> (o .:? "payment")
      <*> (o .:? "payeeId")

-- | ToJSON Mandate
instance A.ToJSON Mandate where
  toJSON Mandate {..} =
   _omitNulls
      [ "payment" .= mandatePayment
      , "payeeId" .= mandatePayeeId
      ]


-- | Construct a value of type 'Mandate' (by applying it's required fields, if any)
mkMandate
  :: Mandate
mkMandate =
  Mandate
  { mandatePayment = Nothing
  , mandatePayeeId = Nothing
  }

-- ** Mint
-- | Mint
data Mint = Mint
  { mintTokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  , mintAmount :: !(Maybe Text) -- ^ "amount" - The amount of a currency
  , mintUnit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  , mintMetadata :: !(Maybe Text) -- ^ "metadata" - (Optional) String of metadata
  , mintTokenId :: !(Maybe Text) -- ^ "tokenId" - Unique identifier for the specific token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Mint
instance A.FromJSON Mint where
  parseJSON = A.withObject "Mint" $ \o ->
    Mint
      <$> (o .:? "tokenName")
      <*> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "metadata")
      <*> (o .:? "tokenId")

-- | ToJSON Mint
instance A.ToJSON Mint where
  toJSON Mint {..} =
   _omitNulls
      [ "tokenName" .= mintTokenName
      , "amount" .= mintAmount
      , "unit" .= mintUnit
      , "metadata" .= mintMetadata
      , "tokenId" .= mintTokenId
      ]


-- | Construct a value of type 'Mint' (by applying it's required fields, if any)
mkMint
  :: Mint
mkMint =
  Mint
  { mintTokenName = Nothing
  , mintAmount = Nothing
  , mintUnit = Nothing
  , mintMetadata = Nothing
  , mintTokenId = Nothing
  }

-- ** MintRequestDetailsSchemaQrc20
-- | MintRequestDetailsSchemaQrc20
data MintRequestDetailsSchemaQrc20 = MintRequestDetailsSchemaQrc20
  { mintRequestDetailsSchemaQrc20Creator :: !(Maybe CreatorMintSchema) -- ^ "creator"
  , mintRequestDetailsSchemaQrc20Beneficiary :: !(Maybe BeneficiaryMintSchemaQrc20) -- ^ "beneficiary"
  , mintRequestDetailsSchemaQrc20Message :: !(Maybe Text) -- ^ "message" - Any text-based element of the data payload
  , mintRequestDetailsSchemaQrc20OverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MintRequestDetailsSchemaQrc20
instance A.FromJSON MintRequestDetailsSchemaQrc20 where
  parseJSON = A.withObject "MintRequestDetailsSchemaQrc20" $ \o ->
    MintRequestDetailsSchemaQrc20
      <$> (o .:? "creator")
      <*> (o .:? "beneficiary")
      <*> (o .:? "message")
      <*> (o .:? "overledgerSigningType")

-- | ToJSON MintRequestDetailsSchemaQrc20
instance A.ToJSON MintRequestDetailsSchemaQrc20 where
  toJSON MintRequestDetailsSchemaQrc20 {..} =
   _omitNulls
      [ "creator" .= mintRequestDetailsSchemaQrc20Creator
      , "beneficiary" .= mintRequestDetailsSchemaQrc20Beneficiary
      , "message" .= mintRequestDetailsSchemaQrc20Message
      , "overledgerSigningType" .= mintRequestDetailsSchemaQrc20OverledgerSigningType
      ]


-- | Construct a value of type 'MintRequestDetailsSchemaQrc20' (by applying it's required fields, if any)
mkMintRequestDetailsSchemaQrc20
  :: MintRequestDetailsSchemaQrc20
mkMintRequestDetailsSchemaQrc20 =
  MintRequestDetailsSchemaQrc20
  { mintRequestDetailsSchemaQrc20Creator = Nothing
  , mintRequestDetailsSchemaQrc20Beneficiary = Nothing
  , mintRequestDetailsSchemaQrc20Message = Nothing
  , mintRequestDetailsSchemaQrc20OverledgerSigningType = Nothing
  }

-- ** MintRequestDetailsSchemaQrc721
-- | MintRequestDetailsSchemaQrc721
data MintRequestDetailsSchemaQrc721 = MintRequestDetailsSchemaQrc721
  { mintRequestDetailsSchemaQrc721Beneficiary :: !(Maybe BeneficiaryMintSchemaQrc721) -- ^ "beneficiary"
  , mintRequestDetailsSchemaQrc721Creator :: !(Maybe CreatorMintSchema) -- ^ "creator"
  , mintRequestDetailsSchemaQrc721OverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MintRequestDetailsSchemaQrc721
instance A.FromJSON MintRequestDetailsSchemaQrc721 where
  parseJSON = A.withObject "MintRequestDetailsSchemaQrc721" $ \o ->
    MintRequestDetailsSchemaQrc721
      <$> (o .:? "beneficiary")
      <*> (o .:? "creator")
      <*> (o .:? "overledgerSigningType")

-- | ToJSON MintRequestDetailsSchemaQrc721
instance A.ToJSON MintRequestDetailsSchemaQrc721 where
  toJSON MintRequestDetailsSchemaQrc721 {..} =
   _omitNulls
      [ "beneficiary" .= mintRequestDetailsSchemaQrc721Beneficiary
      , "creator" .= mintRequestDetailsSchemaQrc721Creator
      , "overledgerSigningType" .= mintRequestDetailsSchemaQrc721OverledgerSigningType
      ]


-- | Construct a value of type 'MintRequestDetailsSchemaQrc721' (by applying it's required fields, if any)
mkMintRequestDetailsSchemaQrc721
  :: MintRequestDetailsSchemaQrc721
mkMintRequestDetailsSchemaQrc721 =
  MintRequestDetailsSchemaQrc721
  { mintRequestDetailsSchemaQrc721Beneficiary = Nothing
  , mintRequestDetailsSchemaQrc721Creator = Nothing
  , mintRequestDetailsSchemaQrc721OverledgerSigningType = Nothing
  }

-- ** MintSchemaQrc20
-- | MintSchemaQrc20
data MintSchemaQrc20 = MintSchemaQrc20
  { mintSchemaQrc20Amount :: !(Text) -- ^ /Required/ "amount" - The amount of a currency
  , mintSchemaQrc20Unit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MintSchemaQrc20
instance A.FromJSON MintSchemaQrc20 where
  parseJSON = A.withObject "MintSchemaQrc20" $ \o ->
    MintSchemaQrc20
      <$> (o .:  "amount")
      <*> (o .:? "unit")

-- | ToJSON MintSchemaQrc20
instance A.ToJSON MintSchemaQrc20 where
  toJSON MintSchemaQrc20 {..} =
   _omitNulls
      [ "amount" .= mintSchemaQrc20Amount
      , "unit" .= mintSchemaQrc20Unit
      ]


-- | Construct a value of type 'MintSchemaQrc20' (by applying it's required fields, if any)
mkMintSchemaQrc20
  :: Text -- ^ 'mintSchemaQrc20Amount': The amount of a currency
  -> MintSchemaQrc20
mkMintSchemaQrc20 mintSchemaQrc20Amount =
  MintSchemaQrc20
  { mintSchemaQrc20Amount
  , mintSchemaQrc20Unit = Nothing
  }

-- ** MintSchemaQrc721
-- | MintSchemaQrc721
data MintSchemaQrc721 = MintSchemaQrc721
  { mintSchemaQrc721TokenId :: !(Maybe Text) -- ^ "tokenId" - Unique identifier for the specific token
  , mintSchemaQrc721TokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  , mintSchemaQrc721Metadata :: !(Maybe Text) -- ^ "metadata" - (Optional) String of metadata
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MintSchemaQrc721
instance A.FromJSON MintSchemaQrc721 where
  parseJSON = A.withObject "MintSchemaQrc721" $ \o ->
    MintSchemaQrc721
      <$> (o .:? "tokenId")
      <*> (o .:? "tokenName")
      <*> (o .:? "metadata")

-- | ToJSON MintSchemaQrc721
instance A.ToJSON MintSchemaQrc721 where
  toJSON MintSchemaQrc721 {..} =
   _omitNulls
      [ "tokenId" .= mintSchemaQrc721TokenId
      , "tokenName" .= mintSchemaQrc721TokenName
      , "metadata" .= mintSchemaQrc721Metadata
      ]


-- | Construct a value of type 'MintSchemaQrc721' (by applying it's required fields, if any)
mkMintSchemaQrc721
  :: MintSchemaQrc721
mkMintSchemaQrc721 =
  MintSchemaQrc721
  { mintSchemaQrc721TokenId = Nothing
  , mintSchemaQrc721TokenName = Nothing
  , mintSchemaQrc721Metadata = Nothing
  }

-- ** MonitorSmartContractEventParam
-- | MonitorSmartContractEventParam
data MonitorSmartContractEventParam = MonitorSmartContractEventParam
  { monitorSmartContractEventParamSelectedIntegerLength :: !(Maybe Text) -- ^ "selectedIntegerLength"
  , monitorSmartContractEventParamType :: !(Maybe Text) -- ^ "type"
  , monitorSmartContractEventParamValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MonitorSmartContractEventParam
instance A.FromJSON MonitorSmartContractEventParam where
  parseJSON = A.withObject "MonitorSmartContractEventParam" $ \o ->
    MonitorSmartContractEventParam
      <$> (o .:? "selectedIntegerLength")
      <*> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON MonitorSmartContractEventParam
instance A.ToJSON MonitorSmartContractEventParam where
  toJSON MonitorSmartContractEventParam {..} =
   _omitNulls
      [ "selectedIntegerLength" .= monitorSmartContractEventParamSelectedIntegerLength
      , "type" .= monitorSmartContractEventParamType
      , "value" .= monitorSmartContractEventParamValue
      ]


-- | Construct a value of type 'MonitorSmartContractEventParam' (by applying it's required fields, if any)
mkMonitorSmartContractEventParam
  :: MonitorSmartContractEventParam
mkMonitorSmartContractEventParam =
  MonitorSmartContractEventParam
  { monitorSmartContractEventParamSelectedIntegerLength = Nothing
  , monitorSmartContractEventParamType = Nothing
  , monitorSmartContractEventParamValue = Nothing
  }

-- ** MonitorSmartContractRequestSchema
-- | MonitorSmartContractRequestSchema
data MonitorSmartContractRequestSchema = MonitorSmartContractRequestSchema
  { monitorSmartContractRequestSchemaEventParams :: !(Maybe [MonitorSmartContractEventParam]) -- ^ "eventParams"
  , monitorSmartContractRequestSchemaEventName :: !(Maybe Text) -- ^ "eventName"
  , monitorSmartContractRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  , monitorSmartContractRequestSchemaCallBackUrl :: !(Maybe Text) -- ^ "callBackURL"
  , monitorSmartContractRequestSchemaSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MonitorSmartContractRequestSchema
instance A.FromJSON MonitorSmartContractRequestSchema where
  parseJSON = A.withObject "MonitorSmartContractRequestSchema" $ \o ->
    MonitorSmartContractRequestSchema
      <$> (o .:? "eventParams")
      <*> (o .:? "eventName")
      <*> (o .:? "location")
      <*> (o .:? "callBackURL")
      <*> (o .:? "smartContractId")

-- | ToJSON MonitorSmartContractRequestSchema
instance A.ToJSON MonitorSmartContractRequestSchema where
  toJSON MonitorSmartContractRequestSchema {..} =
   _omitNulls
      [ "eventParams" .= monitorSmartContractRequestSchemaEventParams
      , "eventName" .= monitorSmartContractRequestSchemaEventName
      , "location" .= monitorSmartContractRequestSchemaLocation
      , "callBackURL" .= monitorSmartContractRequestSchemaCallBackUrl
      , "smartContractId" .= monitorSmartContractRequestSchemaSmartContractId
      ]


-- | Construct a value of type 'MonitorSmartContractRequestSchema' (by applying it's required fields, if any)
mkMonitorSmartContractRequestSchema
  :: MonitorSmartContractRequestSchema
mkMonitorSmartContractRequestSchema =
  MonitorSmartContractRequestSchema
  { monitorSmartContractRequestSchemaEventParams = Nothing
  , monitorSmartContractRequestSchemaEventName = Nothing
  , monitorSmartContractRequestSchemaLocation = Nothing
  , monitorSmartContractRequestSchemaCallBackUrl = Nothing
  , monitorSmartContractRequestSchemaSmartContractId = Nothing
  }

-- ** NonFungibleTokenDTO
-- | NonFungibleTokenDTO
data NonFungibleTokenDTO = NonFungibleTokenDTO
  { nonFungibleTokenDTOFunctions :: !(Maybe [TierFunctionDTO]) -- ^ "functions"
  , nonFungibleTokenDTOTokenName :: !(Maybe Text) -- ^ "tokenName"
  , nonFungibleTokenDTOSmartContractAddress :: !(Maybe Text) -- ^ "smartContractAddress"
  , nonFungibleTokenDTOLocation :: !(Maybe LocationDTO) -- ^ "location"
  , nonFungibleTokenDTOId :: !(Maybe Text) -- ^ "id"
  , nonFungibleTokenDTOTokenType :: !(Maybe Text) -- ^ "tokenType"
  , nonFungibleTokenDTOUrl :: !(Maybe Text) -- ^ "url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NonFungibleTokenDTO
instance A.FromJSON NonFungibleTokenDTO where
  parseJSON = A.withObject "NonFungibleTokenDTO" $ \o ->
    NonFungibleTokenDTO
      <$> (o .:? "functions")
      <*> (o .:? "tokenName")
      <*> (o .:? "smartContractAddress")
      <*> (o .:? "location")
      <*> (o .:? "id")
      <*> (o .:? "tokenType")
      <*> (o .:? "url")

-- | ToJSON NonFungibleTokenDTO
instance A.ToJSON NonFungibleTokenDTO where
  toJSON NonFungibleTokenDTO {..} =
   _omitNulls
      [ "functions" .= nonFungibleTokenDTOFunctions
      , "tokenName" .= nonFungibleTokenDTOTokenName
      , "smartContractAddress" .= nonFungibleTokenDTOSmartContractAddress
      , "location" .= nonFungibleTokenDTOLocation
      , "id" .= nonFungibleTokenDTOId
      , "tokenType" .= nonFungibleTokenDTOTokenType
      , "url" .= nonFungibleTokenDTOUrl
      ]


-- | Construct a value of type 'NonFungibleTokenDTO' (by applying it's required fields, if any)
mkNonFungibleTokenDTO
  :: NonFungibleTokenDTO
mkNonFungibleTokenDTO =
  NonFungibleTokenDTO
  { nonFungibleTokenDTOFunctions = Nothing
  , nonFungibleTokenDTOTokenName = Nothing
  , nonFungibleTokenDTOSmartContractAddress = Nothing
  , nonFungibleTokenDTOLocation = Nothing
  , nonFungibleTokenDTOId = Nothing
  , nonFungibleTokenDTOTokenType = Nothing
  , nonFungibleTokenDTOUrl = Nothing
  }

-- ** NonFungibleTokenResponse
-- | NonFungibleTokenResponse
data NonFungibleTokenResponse = NonFungibleTokenResponse
  { nonFungibleTokenResponseTokenName :: !(Maybe Text) -- ^ "tokenName"
  , nonFungibleTokenResponseDocumentationUrl :: !(Maybe Text) -- ^ "documentationUrl"
  , nonFungibleTokenResponseLocation :: !(Maybe Location) -- ^ "location"
  , nonFungibleTokenResponseFunctions :: !(Maybe [Function]) -- ^ "functions"
  , nonFungibleTokenResponseContractType :: !(Maybe Text) -- ^ "contractType"
  , nonFungibleTokenResponseSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NonFungibleTokenResponse
instance A.FromJSON NonFungibleTokenResponse where
  parseJSON = A.withObject "NonFungibleTokenResponse" $ \o ->
    NonFungibleTokenResponse
      <$> (o .:? "tokenName")
      <*> (o .:? "documentationUrl")
      <*> (o .:? "location")
      <*> (o .:? "functions")
      <*> (o .:? "contractType")
      <*> (o .:? "smartContractId")

-- | ToJSON NonFungibleTokenResponse
instance A.ToJSON NonFungibleTokenResponse where
  toJSON NonFungibleTokenResponse {..} =
   _omitNulls
      [ "tokenName" .= nonFungibleTokenResponseTokenName
      , "documentationUrl" .= nonFungibleTokenResponseDocumentationUrl
      , "location" .= nonFungibleTokenResponseLocation
      , "functions" .= nonFungibleTokenResponseFunctions
      , "contractType" .= nonFungibleTokenResponseContractType
      , "smartContractId" .= nonFungibleTokenResponseSmartContractId
      ]


-- | Construct a value of type 'NonFungibleTokenResponse' (by applying it's required fields, if any)
mkNonFungibleTokenResponse
  :: NonFungibleTokenResponse
mkNonFungibleTokenResponse =
  NonFungibleTokenResponse
  { nonFungibleTokenResponseTokenName = Nothing
  , nonFungibleTokenResponseDocumentationUrl = Nothing
  , nonFungibleTokenResponseLocation = Nothing
  , nonFungibleTokenResponseFunctions = Nothing
  , nonFungibleTokenResponseContractType = Nothing
  , nonFungibleTokenResponseSmartContractId = Nothing
  }

-- ** Origin
-- | Origin
-- Where is this transaction coming from
data Origin = Origin
  { originSequence :: !(Maybe Text) -- ^ "sequence"
  , originSmartContract :: !(Maybe SmartContract) -- ^ "smartContract"
  , originOriginId :: !(Maybe Text) -- ^ "originId" - The unique identifier of the origin
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Origin
instance A.FromJSON Origin where
  parseJSON = A.withObject "Origin" $ \o ->
    Origin
      <$> (o .:? "sequence")
      <*> (o .:? "smartContract")
      <*> (o .:? "originId")

-- | ToJSON Origin
instance A.ToJSON Origin where
  toJSON Origin {..} =
   _omitNulls
      [ "sequence" .= originSequence
      , "smartContract" .= originSmartContract
      , "originId" .= originOriginId
      ]


-- | Construct a value of type 'Origin' (by applying it's required fields, if any)
mkOrigin
  :: Origin
mkOrigin =
  Origin
  { originSequence = Nothing
  , originSmartContract = Nothing
  , originOriginId = Nothing
  }

-- ** OriginPaymentSchema
-- | OriginPaymentSchema
-- List of where this transaction is coming from
data OriginPaymentSchema = OriginPaymentSchema
  { originPaymentSchemaOriginId :: !(Text) -- ^ /Required/ "originId" - Unique Identifier of the origin/sender
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OriginPaymentSchema
instance A.FromJSON OriginPaymentSchema where
  parseJSON = A.withObject "OriginPaymentSchema" $ \o ->
    OriginPaymentSchema
      <$> (o .:  "originId")

-- | ToJSON OriginPaymentSchema
instance A.ToJSON OriginPaymentSchema where
  toJSON OriginPaymentSchema {..} =
   _omitNulls
      [ "originId" .= originPaymentSchemaOriginId
      ]


-- | Construct a value of type 'OriginPaymentSchema' (by applying it's required fields, if any)
mkOriginPaymentSchema
  :: Text -- ^ 'originPaymentSchemaOriginId': Unique Identifier of the origin/sender
  -> OriginPaymentSchema
mkOriginPaymentSchema originPaymentSchemaOriginId =
  OriginPaymentSchema
  { originPaymentSchemaOriginId
  }

-- ** OriginTransferSchema
-- | OriginTransferSchema
data OriginTransferSchema = OriginTransferSchema
  { originTransferSchemaOriginId :: !(Maybe Text) -- ^ "originId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OriginTransferSchema
instance A.FromJSON OriginTransferSchema where
  parseJSON = A.withObject "OriginTransferSchema" $ \o ->
    OriginTransferSchema
      <$> (o .:? "originId")

-- | ToJSON OriginTransferSchema
instance A.ToJSON OriginTransferSchema where
  toJSON OriginTransferSchema {..} =
   _omitNulls
      [ "originId" .= originTransferSchemaOriginId
      ]


-- | Construct a value of type 'OriginTransferSchema' (by applying it's required fields, if any)
mkOriginTransferSchema
  :: OriginTransferSchema
mkOriginTransferSchema =
  OriginTransferSchema
  { originTransferSchemaOriginId = Nothing
  }

-- ** OverledgerTransactionResponseSchema
-- | OverledgerTransactionResponseSchema
data OverledgerTransactionResponseSchema = OverledgerTransactionResponseSchema
  { overledgerTransactionResponseSchemaClientId :: !(Maybe Text) -- ^ "clientId"
  , overledgerTransactionResponseSchemaRequestId :: !(Maybe Text) -- ^ "requestId"
  , overledgerTransactionResponseSchemaOverledgerTransactionId :: !(Maybe Text) -- ^ "overledgerTransactionId"
  , overledgerTransactionResponseSchemaLocation :: !(Maybe Location) -- ^ "location"
  , overledgerTransactionResponseSchemaTransactionHistory :: !(Maybe [Status]) -- ^ "transactionHistory"
  , overledgerTransactionResponseSchemaType :: !(Maybe Text) -- ^ "type"
  , overledgerTransactionResponseSchemaTransactionId :: !(Maybe Text) -- ^ "transactionId"
  , overledgerTransactionResponseSchemaStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OverledgerTransactionResponseSchema
instance A.FromJSON OverledgerTransactionResponseSchema where
  parseJSON = A.withObject "OverledgerTransactionResponseSchema" $ \o ->
    OverledgerTransactionResponseSchema
      <$> (o .:? "clientId")
      <*> (o .:? "requestId")
      <*> (o .:? "overledgerTransactionId")
      <*> (o .:? "location")
      <*> (o .:? "transactionHistory")
      <*> (o .:? "type")
      <*> (o .:? "transactionId")
      <*> (o .:? "status")

-- | ToJSON OverledgerTransactionResponseSchema
instance A.ToJSON OverledgerTransactionResponseSchema where
  toJSON OverledgerTransactionResponseSchema {..} =
   _omitNulls
      [ "clientId" .= overledgerTransactionResponseSchemaClientId
      , "requestId" .= overledgerTransactionResponseSchemaRequestId
      , "overledgerTransactionId" .= overledgerTransactionResponseSchemaOverledgerTransactionId
      , "location" .= overledgerTransactionResponseSchemaLocation
      , "transactionHistory" .= overledgerTransactionResponseSchemaTransactionHistory
      , "type" .= overledgerTransactionResponseSchemaType
      , "transactionId" .= overledgerTransactionResponseSchemaTransactionId
      , "status" .= overledgerTransactionResponseSchemaStatus
      ]


-- | Construct a value of type 'OverledgerTransactionResponseSchema' (by applying it's required fields, if any)
mkOverledgerTransactionResponseSchema
  :: OverledgerTransactionResponseSchema
mkOverledgerTransactionResponseSchema =
  OverledgerTransactionResponseSchema
  { overledgerTransactionResponseSchemaClientId = Nothing
  , overledgerTransactionResponseSchemaRequestId = Nothing
  , overledgerTransactionResponseSchemaOverledgerTransactionId = Nothing
  , overledgerTransactionResponseSchemaLocation = Nothing
  , overledgerTransactionResponseSchemaTransactionHistory = Nothing
  , overledgerTransactionResponseSchemaType = Nothing
  , overledgerTransactionResponseSchemaTransactionId = Nothing
  , overledgerTransactionResponseSchemaStatus = Nothing
  }

-- ** Owner
-- | Owner
-- Who is the owner of the tokens.
data Owner = Owner
  { ownerAccountId :: !(Maybe Text) -- ^ "accountId"
  , ownerBurn :: !(Maybe Burn) -- ^ "burn"
  , ownerUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Owner
instance A.FromJSON Owner where
  parseJSON = A.withObject "Owner" $ \o ->
    Owner
      <$> (o .:? "accountId")
      <*> (o .:? "burn")
      <*> (o .:? "unit")

-- | ToJSON Owner
instance A.ToJSON Owner where
  toJSON Owner {..} =
   _omitNulls
      [ "accountId" .= ownerAccountId
      , "burn" .= ownerBurn
      , "unit" .= ownerUnit
      ]


-- | Construct a value of type 'Owner' (by applying it's required fields, if any)
mkOwner
  :: Owner
mkOwner =
  Owner
  { ownerAccountId = Nothing
  , ownerBurn = Nothing
  , ownerUnit = Nothing
  }

-- ** OwnerBurnSchema
-- | OwnerBurnSchema
-- Who is the owner of the tokens
data OwnerBurnSchema = OwnerBurnSchema
  { ownerBurnSchemaAccountId :: !(Maybe Text) -- ^ "accountId" - Unique Identifier of the owner
  , ownerBurnSchemaBurn :: !(Maybe BurnSchema) -- ^ "burn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OwnerBurnSchema
instance A.FromJSON OwnerBurnSchema where
  parseJSON = A.withObject "OwnerBurnSchema" $ \o ->
    OwnerBurnSchema
      <$> (o .:? "accountId")
      <*> (o .:? "burn")

-- | ToJSON OwnerBurnSchema
instance A.ToJSON OwnerBurnSchema where
  toJSON OwnerBurnSchema {..} =
   _omitNulls
      [ "accountId" .= ownerBurnSchemaAccountId
      , "burn" .= ownerBurnSchemaBurn
      ]


-- | Construct a value of type 'OwnerBurnSchema' (by applying it's required fields, if any)
mkOwnerBurnSchema
  :: OwnerBurnSchema
mkOwnerBurnSchema =
  OwnerBurnSchema
  { ownerBurnSchemaAccountId = Nothing
  , ownerBurnSchemaBurn = Nothing
  }

-- ** OwnerRemoveSecondarySchema
-- | OwnerRemoveSecondarySchema
-- Who are the owner of this transaction
data OwnerRemoveSecondarySchema = OwnerRemoveSecondarySchema
  { ownerRemoveSecondarySchemaAccountId :: !(Maybe Text) -- ^ "accountId" - Unique Identifier of the owner
  , ownerRemoveSecondarySchemaUnit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OwnerRemoveSecondarySchema
instance A.FromJSON OwnerRemoveSecondarySchema where
  parseJSON = A.withObject "OwnerRemoveSecondarySchema" $ \o ->
    OwnerRemoveSecondarySchema
      <$> (o .:? "accountId")
      <*> (o .:? "unit")

-- | ToJSON OwnerRemoveSecondarySchema
instance A.ToJSON OwnerRemoveSecondarySchema where
  toJSON OwnerRemoveSecondarySchema {..} =
   _omitNulls
      [ "accountId" .= ownerRemoveSecondarySchemaAccountId
      , "unit" .= ownerRemoveSecondarySchemaUnit
      ]


-- | Construct a value of type 'OwnerRemoveSecondarySchema' (by applying it's required fields, if any)
mkOwnerRemoveSecondarySchema
  :: OwnerRemoveSecondarySchema
mkOwnerRemoveSecondarySchema =
  OwnerRemoveSecondarySchema
  { ownerRemoveSecondarySchemaAccountId = Nothing
  , ownerRemoveSecondarySchemaUnit = Nothing
  }

-- ** Pagination
-- | Pagination
data Pagination = Pagination
  { paginationSize :: !(Maybe Int) -- ^ "size"
  , paginationTotal :: !(Maybe Int) -- ^ "total"
  , paginationPage :: !(Maybe Int) -- ^ "page"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Pagination
instance A.FromJSON Pagination where
  parseJSON = A.withObject "Pagination" $ \o ->
    Pagination
      <$> (o .:? "size")
      <*> (o .:? "total")
      <*> (o .:? "page")

-- | ToJSON Pagination
instance A.ToJSON Pagination where
  toJSON Pagination {..} =
   _omitNulls
      [ "size" .= paginationSize
      , "total" .= paginationTotal
      , "page" .= paginationPage
      ]


-- | Construct a value of type 'Pagination' (by applying it's required fields, if any)
mkPagination
  :: Pagination
mkPagination =
  Pagination
  { paginationSize = Nothing
  , paginationTotal = Nothing
  , paginationPage = Nothing
  }

-- ** Parameter
-- | Parameter
data Parameter = Parameter
  { parameterType :: !(Maybe Text) -- ^ "type"
  , parameterValue :: !(Maybe A.Value) -- ^ "value"
  , parameterKey :: !(Maybe Text) -- ^ "key"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Parameter
instance A.FromJSON Parameter where
  parseJSON = A.withObject "Parameter" $ \o ->
    Parameter
      <$> (o .:? "type")
      <*> (o .:? "value")
      <*> (o .:? "key")

-- | ToJSON Parameter
instance A.ToJSON Parameter where
  toJSON Parameter {..} =
   _omitNulls
      [ "type" .= parameterType
      , "value" .= parameterValue
      , "key" .= parameterKey
      ]


-- | Construct a value of type 'Parameter' (by applying it's required fields, if any)
mkParameter
  :: Parameter
mkParameter =
  Parameter
  { parameterType = Nothing
  , parameterValue = Nothing
  , parameterKey = Nothing
  }

-- ** Payee
-- | Payee
-- The Destination of this transaction
data Payee = Payee
  { payeePayment :: !(Maybe Payment) -- ^ "payment"
  , payeePayeeId :: !(Maybe Text) -- ^ "payeeId" - The unique identifiers of the payee
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Payee
instance A.FromJSON Payee where
  parseJSON = A.withObject "Payee" $ \o ->
    Payee
      <$> (o .:? "payment")
      <*> (o .:? "payeeId")

-- | ToJSON Payee
instance A.ToJSON Payee where
  toJSON Payee {..} =
   _omitNulls
      [ "payment" .= payeePayment
      , "payeeId" .= payeePayeeId
      ]


-- | Construct a value of type 'Payee' (by applying it's required fields, if any)
mkPayee
  :: Payee
mkPayee =
  Payee
  { payeePayment = Nothing
  , payeePayeeId = Nothing
  }

-- ** PayeeCreditSchema
-- | PayeeCreditSchema
-- Who are the payees of this transaction
data PayeeCreditSchema = PayeeCreditSchema
  { payeeCreditSchemaPayment :: !(Maybe PaymentSchema) -- ^ "payment"
  , payeeCreditSchemaPayeeId :: !(Maybe Text) -- ^ "payeeId" - The unique identifiers of the payees
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayeeCreditSchema
instance A.FromJSON PayeeCreditSchema where
  parseJSON = A.withObject "PayeeCreditSchema" $ \o ->
    PayeeCreditSchema
      <$> (o .:? "payment")
      <*> (o .:? "payeeId")

-- | ToJSON PayeeCreditSchema
instance A.ToJSON PayeeCreditSchema where
  toJSON PayeeCreditSchema {..} =
   _omitNulls
      [ "payment" .= payeeCreditSchemaPayment
      , "payeeId" .= payeeCreditSchemaPayeeId
      ]


-- | Construct a value of type 'PayeeCreditSchema' (by applying it's required fields, if any)
mkPayeeCreditSchema
  :: PayeeCreditSchema
mkPayeeCreditSchema =
  PayeeCreditSchema
  { payeeCreditSchemaPayment = Nothing
  , payeeCreditSchemaPayeeId = Nothing
  }

-- ** Payer
-- | Payer
-- Where is this transaction coming from
data Payer = Payer
  { payerPayerId :: !(Maybe Text) -- ^ "payerId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Payer
instance A.FromJSON Payer where
  parseJSON = A.withObject "Payer" $ \o ->
    Payer
      <$> (o .:? "payerId")

-- | ToJSON Payer
instance A.ToJSON Payer where
  toJSON Payer {..} =
   _omitNulls
      [ "payerId" .= payerPayerId
      ]


-- | Construct a value of type 'Payer' (by applying it's required fields, if any)
mkPayer
  :: Payer
mkPayer =
  Payer
  { payerPayerId = Nothing
  }

-- ** PayerCreditSchema
-- | PayerCreditSchema
-- Who are the payers of this transaction
data PayerCreditSchema = PayerCreditSchema
  { payerCreditSchemaPayerId :: !(Maybe Text) -- ^ "payerId" - Unique Identifier of the payer
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PayerCreditSchema
instance A.FromJSON PayerCreditSchema where
  parseJSON = A.withObject "PayerCreditSchema" $ \o ->
    PayerCreditSchema
      <$> (o .:? "payerId")

-- | ToJSON PayerCreditSchema
instance A.ToJSON PayerCreditSchema where
  toJSON PayerCreditSchema {..} =
   _omitNulls
      [ "payerId" .= payerCreditSchemaPayerId
      ]


-- | Construct a value of type 'PayerCreditSchema' (by applying it's required fields, if any)
mkPayerCreditSchema
  :: PayerCreditSchema
mkPayerCreditSchema =
  PayerCreditSchema
  { payerCreditSchemaPayerId = Nothing
  }

-- ** Payment
-- | Payment
data Payment = Payment
  { paymentAmount :: !(Maybe Text) -- ^ "amount" - The amount of a currency
  , paymentUnit :: !(Maybe Text) -- ^ "unit" - The unit of this currency/token
  , paymentIssuer :: !(Maybe Text) -- ^ "issuer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Payment
instance A.FromJSON Payment where
  parseJSON = A.withObject "Payment" $ \o ->
    Payment
      <$> (o .:? "amount")
      <*> (o .:? "unit")
      <*> (o .:? "issuer")

-- | ToJSON Payment
instance A.ToJSON Payment where
  toJSON Payment {..} =
   _omitNulls
      [ "amount" .= paymentAmount
      , "unit" .= paymentUnit
      , "issuer" .= paymentIssuer
      ]


-- | Construct a value of type 'Payment' (by applying it's required fields, if any)
mkPayment
  :: Payment
mkPayment =
  Payment
  { paymentAmount = Nothing
  , paymentUnit = Nothing
  , paymentIssuer = Nothing
  }

-- ** PaymentRequestDetailsSchema
-- | PaymentRequestDetailsSchema
-- The payload request
data PaymentRequestDetailsSchema = PaymentRequestDetailsSchema
  { paymentRequestDetailsSchemaDestination :: !([DestinationPaymentSchema]) -- ^ /Required/ "destination" - List of the recipients of this transaction.  **Warning:** Bitcoin transaction fees will be deducted from the last destination provided in the transaction payment request. If the last destination payment value is not enough to cover the fees, your Bitcoin payment transaction will fail
  , paymentRequestDetailsSchemaMessage :: !(Maybe Text) -- ^ "message" - Any text-based element of the data payload
  , paymentRequestDetailsSchemaOverledgerSigningType :: !(Maybe E'OverledgerSigningType) -- ^ "overledgerSigningType" - The method of signing used to submit the transaction
  , paymentRequestDetailsSchemaOrigin :: !([OriginPaymentSchema]) -- ^ /Required/ "origin" - List of where this transaction is coming from
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentRequestDetailsSchema
instance A.FromJSON PaymentRequestDetailsSchema where
  parseJSON = A.withObject "PaymentRequestDetailsSchema" $ \o ->
    PaymentRequestDetailsSchema
      <$> (o .:  "destination")
      <*> (o .:? "message")
      <*> (o .:? "overledgerSigningType")
      <*> (o .:  "origin")

-- | ToJSON PaymentRequestDetailsSchema
instance A.ToJSON PaymentRequestDetailsSchema where
  toJSON PaymentRequestDetailsSchema {..} =
   _omitNulls
      [ "destination" .= paymentRequestDetailsSchemaDestination
      , "message" .= paymentRequestDetailsSchemaMessage
      , "overledgerSigningType" .= paymentRequestDetailsSchemaOverledgerSigningType
      , "origin" .= paymentRequestDetailsSchemaOrigin
      ]


-- | Construct a value of type 'PaymentRequestDetailsSchema' (by applying it's required fields, if any)
mkPaymentRequestDetailsSchema
  :: [DestinationPaymentSchema] -- ^ 'paymentRequestDetailsSchemaDestination': List of the recipients of this transaction.  **Warning:** Bitcoin transaction fees will be deducted from the last destination provided in the transaction payment request. If the last destination payment value is not enough to cover the fees, your Bitcoin payment transaction will fail
  -> [OriginPaymentSchema] -- ^ 'paymentRequestDetailsSchemaOrigin': List of where this transaction is coming from
  -> PaymentRequestDetailsSchema
mkPaymentRequestDetailsSchema paymentRequestDetailsSchemaDestination paymentRequestDetailsSchemaOrigin =
  PaymentRequestDetailsSchema
  { paymentRequestDetailsSchemaDestination
  , paymentRequestDetailsSchemaMessage = Nothing
  , paymentRequestDetailsSchemaOverledgerSigningType = Nothing
  , paymentRequestDetailsSchemaOrigin
  }

-- ** PaymentSchema
-- | PaymentSchema
-- The payload for each recipient
data PaymentSchema = PaymentSchema
  { paymentSchemaAmount :: !(Text) -- ^ /Required/ "amount" - The payload amount. The exact format depends on the unit of the token.
  , paymentSchemaUnit :: !(Text) -- ^ /Required/ "unit" - The currency or token code
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PaymentSchema
instance A.FromJSON PaymentSchema where
  parseJSON = A.withObject "PaymentSchema" $ \o ->
    PaymentSchema
      <$> (o .:  "amount")
      <*> (o .:  "unit")

-- | ToJSON PaymentSchema
instance A.ToJSON PaymentSchema where
  toJSON PaymentSchema {..} =
   _omitNulls
      [ "amount" .= paymentSchemaAmount
      , "unit" .= paymentSchemaUnit
      ]


-- | Construct a value of type 'PaymentSchema' (by applying it's required fields, if any)
mkPaymentSchema
  :: Text -- ^ 'paymentSchemaAmount': The payload amount. The exact format depends on the unit of the token.
  -> Text -- ^ 'paymentSchemaUnit': The currency or token code
  -> PaymentSchema
mkPaymentSchema paymentSchemaAmount paymentSchemaUnit =
  PaymentSchema
  { paymentSchemaAmount
  , paymentSchemaUnit
  }

-- ** PrepareAddSecondaryAccountRequestSchema
-- | PrepareAddSecondaryAccountRequestSchema
data PrepareAddSecondaryAccountRequestSchema = PrepareAddSecondaryAccountRequestSchema
  { prepareAddSecondaryAccountRequestSchemaLocation :: !(Location) -- ^ /Required/ "location"
  , prepareAddSecondaryAccountRequestSchemaType :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , prepareAddSecondaryAccountRequestSchemaUrgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , prepareAddSecondaryAccountRequestSchemaRequestDetails :: !(Maybe AddSecondaryAccountRequestDetailsSchema) -- ^ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareAddSecondaryAccountRequestSchema
instance A.FromJSON PrepareAddSecondaryAccountRequestSchema where
  parseJSON = A.withObject "PrepareAddSecondaryAccountRequestSchema" $ \o ->
    PrepareAddSecondaryAccountRequestSchema
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:? "requestDetails")

-- | ToJSON PrepareAddSecondaryAccountRequestSchema
instance A.ToJSON PrepareAddSecondaryAccountRequestSchema where
  toJSON PrepareAddSecondaryAccountRequestSchema {..} =
   _omitNulls
      [ "location" .= prepareAddSecondaryAccountRequestSchemaLocation
      , "type" .= prepareAddSecondaryAccountRequestSchemaType
      , "urgency" .= prepareAddSecondaryAccountRequestSchemaUrgency
      , "requestDetails" .= prepareAddSecondaryAccountRequestSchemaRequestDetails
      ]


-- | Construct a value of type 'PrepareAddSecondaryAccountRequestSchema' (by applying it's required fields, if any)
mkPrepareAddSecondaryAccountRequestSchema
  :: Location -- ^ 'prepareAddSecondaryAccountRequestSchemaLocation' 
  -> E'Type -- ^ 'prepareAddSecondaryAccountRequestSchemaType': The type of the transaction
  -> E'Urgency -- ^ 'prepareAddSecondaryAccountRequestSchemaUrgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PrepareAddSecondaryAccountRequestSchema
mkPrepareAddSecondaryAccountRequestSchema prepareAddSecondaryAccountRequestSchemaLocation prepareAddSecondaryAccountRequestSchemaType prepareAddSecondaryAccountRequestSchemaUrgency =
  PrepareAddSecondaryAccountRequestSchema
  { prepareAddSecondaryAccountRequestSchemaLocation
  , prepareAddSecondaryAccountRequestSchemaType
  , prepareAddSecondaryAccountRequestSchemaUrgency
  , prepareAddSecondaryAccountRequestSchemaRequestDetails = Nothing
  }

-- ** PrepareAndExecuteBalanceDetails
-- | PrepareAndExecuteBalanceDetails
data PrepareAndExecuteBalanceDetails = PrepareAndExecuteBalanceDetails
  { prepareAndExecuteBalanceDetailsUnit :: !(Maybe Text) -- ^ "unit"
  , prepareAndExecuteBalanceDetailsAmount :: !(Maybe Text) -- ^ "amount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareAndExecuteBalanceDetails
instance A.FromJSON PrepareAndExecuteBalanceDetails where
  parseJSON = A.withObject "PrepareAndExecuteBalanceDetails" $ \o ->
    PrepareAndExecuteBalanceDetails
      <$> (o .:? "unit")
      <*> (o .:? "amount")

-- | ToJSON PrepareAndExecuteBalanceDetails
instance A.ToJSON PrepareAndExecuteBalanceDetails where
  toJSON PrepareAndExecuteBalanceDetails {..} =
   _omitNulls
      [ "unit" .= prepareAndExecuteBalanceDetailsUnit
      , "amount" .= prepareAndExecuteBalanceDetailsAmount
      ]


-- | Construct a value of type 'PrepareAndExecuteBalanceDetails' (by applying it's required fields, if any)
mkPrepareAndExecuteBalanceDetails
  :: PrepareAndExecuteBalanceDetails
mkPrepareAndExecuteBalanceDetails =
  PrepareAndExecuteBalanceDetails
  { prepareAndExecuteBalanceDetailsUnit = Nothing
  , prepareAndExecuteBalanceDetailsAmount = Nothing
  }

-- ** PrepareAndExecuteOverledgerErrorResponse
-- | PrepareAndExecuteOverledgerErrorResponse
data PrepareAndExecuteOverledgerErrorResponse = PrepareAndExecuteOverledgerErrorResponse
  { prepareAndExecuteOverledgerErrorResponseCategory :: !(Maybe Text) -- ^ "category"
  , prepareAndExecuteOverledgerErrorResponseDescription :: !(Maybe Text) -- ^ "description"
  , prepareAndExecuteOverledgerErrorResponseCode :: !(Maybe Text) -- ^ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareAndExecuteOverledgerErrorResponse
instance A.FromJSON PrepareAndExecuteOverledgerErrorResponse where
  parseJSON = A.withObject "PrepareAndExecuteOverledgerErrorResponse" $ \o ->
    PrepareAndExecuteOverledgerErrorResponse
      <$> (o .:? "category")
      <*> (o .:? "description")
      <*> (o .:? "code")

-- | ToJSON PrepareAndExecuteOverledgerErrorResponse
instance A.ToJSON PrepareAndExecuteOverledgerErrorResponse where
  toJSON PrepareAndExecuteOverledgerErrorResponse {..} =
   _omitNulls
      [ "category" .= prepareAndExecuteOverledgerErrorResponseCategory
      , "description" .= prepareAndExecuteOverledgerErrorResponseDescription
      , "code" .= prepareAndExecuteOverledgerErrorResponseCode
      ]


-- | Construct a value of type 'PrepareAndExecuteOverledgerErrorResponse' (by applying it's required fields, if any)
mkPrepareAndExecuteOverledgerErrorResponse
  :: PrepareAndExecuteOverledgerErrorResponse
mkPrepareAndExecuteOverledgerErrorResponse =
  PrepareAndExecuteOverledgerErrorResponse
  { prepareAndExecuteOverledgerErrorResponseCategory = Nothing
  , prepareAndExecuteOverledgerErrorResponseDescription = Nothing
  , prepareAndExecuteOverledgerErrorResponseCode = Nothing
  }

-- ** PrepareAndExecuteSearchAddressBalanceResponse
-- | PrepareAndExecuteSearchAddressBalanceResponse
data PrepareAndExecuteSearchAddressBalanceResponse = PrepareAndExecuteSearchAddressBalanceResponse
  { prepareAndExecuteSearchAddressBalanceResponseBalances :: !(Maybe [PrepareAndExecuteBalanceDetails]) -- ^ "balances"
  , prepareAndExecuteSearchAddressBalanceResponseLocation :: !(Maybe Location) -- ^ "location"
  , prepareAndExecuteSearchAddressBalanceResponseTimestamp :: !(Maybe Text) -- ^ "timestamp"
  , prepareAndExecuteSearchAddressBalanceResponseAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareAndExecuteSearchAddressBalanceResponse
instance A.FromJSON PrepareAndExecuteSearchAddressBalanceResponse where
  parseJSON = A.withObject "PrepareAndExecuteSearchAddressBalanceResponse" $ \o ->
    PrepareAndExecuteSearchAddressBalanceResponse
      <$> (o .:? "balances")
      <*> (o .:? "location")
      <*> (o .:? "timestamp")
      <*> (o .:? "addressId")

-- | ToJSON PrepareAndExecuteSearchAddressBalanceResponse
instance A.ToJSON PrepareAndExecuteSearchAddressBalanceResponse where
  toJSON PrepareAndExecuteSearchAddressBalanceResponse {..} =
   _omitNulls
      [ "balances" .= prepareAndExecuteSearchAddressBalanceResponseBalances
      , "location" .= prepareAndExecuteSearchAddressBalanceResponseLocation
      , "timestamp" .= prepareAndExecuteSearchAddressBalanceResponseTimestamp
      , "addressId" .= prepareAndExecuteSearchAddressBalanceResponseAddressId
      ]


-- | Construct a value of type 'PrepareAndExecuteSearchAddressBalanceResponse' (by applying it's required fields, if any)
mkPrepareAndExecuteSearchAddressBalanceResponse
  :: PrepareAndExecuteSearchAddressBalanceResponse
mkPrepareAndExecuteSearchAddressBalanceResponse =
  PrepareAndExecuteSearchAddressBalanceResponse
  { prepareAndExecuteSearchAddressBalanceResponseBalances = Nothing
  , prepareAndExecuteSearchAddressBalanceResponseLocation = Nothing
  , prepareAndExecuteSearchAddressBalanceResponseTimestamp = Nothing
  , prepareAndExecuteSearchAddressBalanceResponseAddressId = Nothing
  }

-- ** PrepareAndExecuteTransactionResponse
-- | PrepareAndExecuteTransactionResponse
data PrepareAndExecuteTransactionResponse = PrepareAndExecuteTransactionResponse
  { prepareAndExecuteTransactionResponsePreparationTransactionSearchResponse :: !(Maybe PrepareTransactionResponse) -- ^ "preparationTransactionSearchResponse"
  , prepareAndExecuteTransactionResponseExecutionTransactionSearchResponse :: !(Maybe ExecuteSearchTransactionResponse) -- ^ "executionTransactionSearchResponse"
  , prepareAndExecuteTransactionResponseExecutionTransactionSearchOverledgerErrorResponse :: !(Maybe PrepareAndExecuteOverledgerErrorResponse) -- ^ "executionTransactionSearchOverledgerErrorResponse"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareAndExecuteTransactionResponse
instance A.FromJSON PrepareAndExecuteTransactionResponse where
  parseJSON = A.withObject "PrepareAndExecuteTransactionResponse" $ \o ->
    PrepareAndExecuteTransactionResponse
      <$> (o .:? "preparationTransactionSearchResponse")
      <*> (o .:? "executionTransactionSearchResponse")
      <*> (o .:? "executionTransactionSearchOverledgerErrorResponse")

-- | ToJSON PrepareAndExecuteTransactionResponse
instance A.ToJSON PrepareAndExecuteTransactionResponse where
  toJSON PrepareAndExecuteTransactionResponse {..} =
   _omitNulls
      [ "preparationTransactionSearchResponse" .= prepareAndExecuteTransactionResponsePreparationTransactionSearchResponse
      , "executionTransactionSearchResponse" .= prepareAndExecuteTransactionResponseExecutionTransactionSearchResponse
      , "executionTransactionSearchOverledgerErrorResponse" .= prepareAndExecuteTransactionResponseExecutionTransactionSearchOverledgerErrorResponse
      ]


-- | Construct a value of type 'PrepareAndExecuteTransactionResponse' (by applying it's required fields, if any)
mkPrepareAndExecuteTransactionResponse
  :: PrepareAndExecuteTransactionResponse
mkPrepareAndExecuteTransactionResponse =
  PrepareAndExecuteTransactionResponse
  { prepareAndExecuteTransactionResponsePreparationTransactionSearchResponse = Nothing
  , prepareAndExecuteTransactionResponseExecutionTransactionSearchResponse = Nothing
  , prepareAndExecuteTransactionResponseExecutionTransactionSearchOverledgerErrorResponse = Nothing
  }

-- ** PrepareApproveDebitTransactionRequestSchema
-- | PrepareApproveDebitTransactionRequestSchema
data PrepareApproveDebitTransactionRequestSchema = PrepareApproveDebitTransactionRequestSchema
  { prepareApproveDebitTransactionRequestSchemaLocation :: !(Location) -- ^ /Required/ "location"
  , prepareApproveDebitTransactionRequestSchemaType :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , prepareApproveDebitTransactionRequestSchemaUrgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , prepareApproveDebitTransactionRequestSchemaRequestDetails :: !(Maybe ApproveRequestDetailsSchema) -- ^ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareApproveDebitTransactionRequestSchema
instance A.FromJSON PrepareApproveDebitTransactionRequestSchema where
  parseJSON = A.withObject "PrepareApproveDebitTransactionRequestSchema" $ \o ->
    PrepareApproveDebitTransactionRequestSchema
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:? "requestDetails")

-- | ToJSON PrepareApproveDebitTransactionRequestSchema
instance A.ToJSON PrepareApproveDebitTransactionRequestSchema where
  toJSON PrepareApproveDebitTransactionRequestSchema {..} =
   _omitNulls
      [ "location" .= prepareApproveDebitTransactionRequestSchemaLocation
      , "type" .= prepareApproveDebitTransactionRequestSchemaType
      , "urgency" .= prepareApproveDebitTransactionRequestSchemaUrgency
      , "requestDetails" .= prepareApproveDebitTransactionRequestSchemaRequestDetails
      ]


-- | Construct a value of type 'PrepareApproveDebitTransactionRequestSchema' (by applying it's required fields, if any)
mkPrepareApproveDebitTransactionRequestSchema
  :: Location -- ^ 'prepareApproveDebitTransactionRequestSchemaLocation' 
  -> E'Type -- ^ 'prepareApproveDebitTransactionRequestSchemaType': The type of the transaction
  -> E'Urgency -- ^ 'prepareApproveDebitTransactionRequestSchemaUrgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PrepareApproveDebitTransactionRequestSchema
mkPrepareApproveDebitTransactionRequestSchema prepareApproveDebitTransactionRequestSchemaLocation prepareApproveDebitTransactionRequestSchemaType prepareApproveDebitTransactionRequestSchemaUrgency =
  PrepareApproveDebitTransactionRequestSchema
  { prepareApproveDebitTransactionRequestSchemaLocation
  , prepareApproveDebitTransactionRequestSchemaType
  , prepareApproveDebitTransactionRequestSchemaUrgency
  , prepareApproveDebitTransactionRequestSchemaRequestDetails = Nothing
  }

-- ** PrepareBurnTransactionRequestSchema
-- | PrepareBurnTransactionRequestSchema
data PrepareBurnTransactionRequestSchema = PrepareBurnTransactionRequestSchema
  { prepareBurnTransactionRequestSchemaLocation :: !(Location) -- ^ /Required/ "location"
  , prepareBurnTransactionRequestSchemaType :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , prepareBurnTransactionRequestSchemaUrgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , prepareBurnTransactionRequestSchemaRequestDetails :: !(Maybe BurnRequestDetailsSchema) -- ^ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareBurnTransactionRequestSchema
instance A.FromJSON PrepareBurnTransactionRequestSchema where
  parseJSON = A.withObject "PrepareBurnTransactionRequestSchema" $ \o ->
    PrepareBurnTransactionRequestSchema
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:? "requestDetails")

-- | ToJSON PrepareBurnTransactionRequestSchema
instance A.ToJSON PrepareBurnTransactionRequestSchema where
  toJSON PrepareBurnTransactionRequestSchema {..} =
   _omitNulls
      [ "location" .= prepareBurnTransactionRequestSchemaLocation
      , "type" .= prepareBurnTransactionRequestSchemaType
      , "urgency" .= prepareBurnTransactionRequestSchemaUrgency
      , "requestDetails" .= prepareBurnTransactionRequestSchemaRequestDetails
      ]


-- | Construct a value of type 'PrepareBurnTransactionRequestSchema' (by applying it's required fields, if any)
mkPrepareBurnTransactionRequestSchema
  :: Location -- ^ 'prepareBurnTransactionRequestSchemaLocation' 
  -> E'Type -- ^ 'prepareBurnTransactionRequestSchemaType': The type of the transaction
  -> E'Urgency -- ^ 'prepareBurnTransactionRequestSchemaUrgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PrepareBurnTransactionRequestSchema
mkPrepareBurnTransactionRequestSchema prepareBurnTransactionRequestSchemaLocation prepareBurnTransactionRequestSchemaType prepareBurnTransactionRequestSchemaUrgency =
  PrepareBurnTransactionRequestSchema
  { prepareBurnTransactionRequestSchemaLocation
  , prepareBurnTransactionRequestSchemaType
  , prepareBurnTransactionRequestSchemaUrgency
  , prepareBurnTransactionRequestSchemaRequestDetails = Nothing
  }

-- ** PrepareBurnTransactionRequestSchemaQrc721
-- | PrepareBurnTransactionRequestSchemaQrc721
data PrepareBurnTransactionRequestSchemaQrc721 = PrepareBurnTransactionRequestSchemaQrc721
  { prepareBurnTransactionRequestSchemaQrc721Location :: !(Location) -- ^ /Required/ "location"
  , prepareBurnTransactionRequestSchemaQrc721Type :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , prepareBurnTransactionRequestSchemaQrc721Urgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , prepareBurnTransactionRequestSchemaQrc721RequestDetails :: !(Maybe BurnRequestDetailsSchemaQrc721) -- ^ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareBurnTransactionRequestSchemaQrc721
instance A.FromJSON PrepareBurnTransactionRequestSchemaQrc721 where
  parseJSON = A.withObject "PrepareBurnTransactionRequestSchemaQrc721" $ \o ->
    PrepareBurnTransactionRequestSchemaQrc721
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:? "requestDetails")

-- | ToJSON PrepareBurnTransactionRequestSchemaQrc721
instance A.ToJSON PrepareBurnTransactionRequestSchemaQrc721 where
  toJSON PrepareBurnTransactionRequestSchemaQrc721 {..} =
   _omitNulls
      [ "location" .= prepareBurnTransactionRequestSchemaQrc721Location
      , "type" .= prepareBurnTransactionRequestSchemaQrc721Type
      , "urgency" .= prepareBurnTransactionRequestSchemaQrc721Urgency
      , "requestDetails" .= prepareBurnTransactionRequestSchemaQrc721RequestDetails
      ]


-- | Construct a value of type 'PrepareBurnTransactionRequestSchemaQrc721' (by applying it's required fields, if any)
mkPrepareBurnTransactionRequestSchemaQrc721
  :: Location -- ^ 'prepareBurnTransactionRequestSchemaQrc721Location' 
  -> E'Type -- ^ 'prepareBurnTransactionRequestSchemaQrc721Type': The type of the transaction
  -> E'Urgency -- ^ 'prepareBurnTransactionRequestSchemaQrc721Urgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PrepareBurnTransactionRequestSchemaQrc721
mkPrepareBurnTransactionRequestSchemaQrc721 prepareBurnTransactionRequestSchemaQrc721Location prepareBurnTransactionRequestSchemaQrc721Type prepareBurnTransactionRequestSchemaQrc721Urgency =
  PrepareBurnTransactionRequestSchemaQrc721
  { prepareBurnTransactionRequestSchemaQrc721Location
  , prepareBurnTransactionRequestSchemaQrc721Type
  , prepareBurnTransactionRequestSchemaQrc721Urgency
  , prepareBurnTransactionRequestSchemaQrc721RequestDetails = Nothing
  }

-- ** PrepareCreditTransactionRequestSchema
-- | PrepareCreditTransactionRequestSchema
data PrepareCreditTransactionRequestSchema = PrepareCreditTransactionRequestSchema
  { prepareCreditTransactionRequestSchemaLocation :: !(Location) -- ^ /Required/ "location"
  , prepareCreditTransactionRequestSchemaType :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , prepareCreditTransactionRequestSchemaUrgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , prepareCreditTransactionRequestSchemaRequestDetails :: !(Maybe CreditRequestDetailsSchema) -- ^ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareCreditTransactionRequestSchema
instance A.FromJSON PrepareCreditTransactionRequestSchema where
  parseJSON = A.withObject "PrepareCreditTransactionRequestSchema" $ \o ->
    PrepareCreditTransactionRequestSchema
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:? "requestDetails")

-- | ToJSON PrepareCreditTransactionRequestSchema
instance A.ToJSON PrepareCreditTransactionRequestSchema where
  toJSON PrepareCreditTransactionRequestSchema {..} =
   _omitNulls
      [ "location" .= prepareCreditTransactionRequestSchemaLocation
      , "type" .= prepareCreditTransactionRequestSchemaType
      , "urgency" .= prepareCreditTransactionRequestSchemaUrgency
      , "requestDetails" .= prepareCreditTransactionRequestSchemaRequestDetails
      ]


-- | Construct a value of type 'PrepareCreditTransactionRequestSchema' (by applying it's required fields, if any)
mkPrepareCreditTransactionRequestSchema
  :: Location -- ^ 'prepareCreditTransactionRequestSchemaLocation' 
  -> E'Type -- ^ 'prepareCreditTransactionRequestSchemaType': The type of the transaction
  -> E'Urgency -- ^ 'prepareCreditTransactionRequestSchemaUrgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PrepareCreditTransactionRequestSchema
mkPrepareCreditTransactionRequestSchema prepareCreditTransactionRequestSchemaLocation prepareCreditTransactionRequestSchemaType prepareCreditTransactionRequestSchemaUrgency =
  PrepareCreditTransactionRequestSchema
  { prepareCreditTransactionRequestSchemaLocation
  , prepareCreditTransactionRequestSchemaType
  , prepareCreditTransactionRequestSchemaUrgency
  , prepareCreditTransactionRequestSchemaRequestDetails = Nothing
  }

-- ** PrepareMintTransactionRequestSchemaQrc20
-- | PrepareMintTransactionRequestSchemaQrc20
data PrepareMintTransactionRequestSchemaQrc20 = PrepareMintTransactionRequestSchemaQrc20
  { prepareMintTransactionRequestSchemaQrc20Location :: !(Location) -- ^ /Required/ "location"
  , prepareMintTransactionRequestSchemaQrc20Type :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , prepareMintTransactionRequestSchemaQrc20Urgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , prepareMintTransactionRequestSchemaQrc20RequestDetails :: !(Maybe MintRequestDetailsSchemaQrc20) -- ^ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareMintTransactionRequestSchemaQrc20
instance A.FromJSON PrepareMintTransactionRequestSchemaQrc20 where
  parseJSON = A.withObject "PrepareMintTransactionRequestSchemaQrc20" $ \o ->
    PrepareMintTransactionRequestSchemaQrc20
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:? "requestDetails")

-- | ToJSON PrepareMintTransactionRequestSchemaQrc20
instance A.ToJSON PrepareMintTransactionRequestSchemaQrc20 where
  toJSON PrepareMintTransactionRequestSchemaQrc20 {..} =
   _omitNulls
      [ "location" .= prepareMintTransactionRequestSchemaQrc20Location
      , "type" .= prepareMintTransactionRequestSchemaQrc20Type
      , "urgency" .= prepareMintTransactionRequestSchemaQrc20Urgency
      , "requestDetails" .= prepareMintTransactionRequestSchemaQrc20RequestDetails
      ]


-- | Construct a value of type 'PrepareMintTransactionRequestSchemaQrc20' (by applying it's required fields, if any)
mkPrepareMintTransactionRequestSchemaQrc20
  :: Location -- ^ 'prepareMintTransactionRequestSchemaQrc20Location' 
  -> E'Type -- ^ 'prepareMintTransactionRequestSchemaQrc20Type': The type of the transaction
  -> E'Urgency -- ^ 'prepareMintTransactionRequestSchemaQrc20Urgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PrepareMintTransactionRequestSchemaQrc20
mkPrepareMintTransactionRequestSchemaQrc20 prepareMintTransactionRequestSchemaQrc20Location prepareMintTransactionRequestSchemaQrc20Type prepareMintTransactionRequestSchemaQrc20Urgency =
  PrepareMintTransactionRequestSchemaQrc20
  { prepareMintTransactionRequestSchemaQrc20Location
  , prepareMintTransactionRequestSchemaQrc20Type
  , prepareMintTransactionRequestSchemaQrc20Urgency
  , prepareMintTransactionRequestSchemaQrc20RequestDetails = Nothing
  }

-- ** PrepareMintTransactionRequestSchemaQrc721
-- | PrepareMintTransactionRequestSchemaQrc721
data PrepareMintTransactionRequestSchemaQrc721 = PrepareMintTransactionRequestSchemaQrc721
  { prepareMintTransactionRequestSchemaQrc721Location :: !(Location) -- ^ /Required/ "location"
  , prepareMintTransactionRequestSchemaQrc721Type :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , prepareMintTransactionRequestSchemaQrc721Urgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , prepareMintTransactionRequestSchemaQrc721RequestDetails :: !(Maybe MintRequestDetailsSchemaQrc721) -- ^ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareMintTransactionRequestSchemaQrc721
instance A.FromJSON PrepareMintTransactionRequestSchemaQrc721 where
  parseJSON = A.withObject "PrepareMintTransactionRequestSchemaQrc721" $ \o ->
    PrepareMintTransactionRequestSchemaQrc721
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:? "requestDetails")

-- | ToJSON PrepareMintTransactionRequestSchemaQrc721
instance A.ToJSON PrepareMintTransactionRequestSchemaQrc721 where
  toJSON PrepareMintTransactionRequestSchemaQrc721 {..} =
   _omitNulls
      [ "location" .= prepareMintTransactionRequestSchemaQrc721Location
      , "type" .= prepareMintTransactionRequestSchemaQrc721Type
      , "urgency" .= prepareMintTransactionRequestSchemaQrc721Urgency
      , "requestDetails" .= prepareMintTransactionRequestSchemaQrc721RequestDetails
      ]


-- | Construct a value of type 'PrepareMintTransactionRequestSchemaQrc721' (by applying it's required fields, if any)
mkPrepareMintTransactionRequestSchemaQrc721
  :: Location -- ^ 'prepareMintTransactionRequestSchemaQrc721Location' 
  -> E'Type -- ^ 'prepareMintTransactionRequestSchemaQrc721Type': The type of the transaction
  -> E'Urgency -- ^ 'prepareMintTransactionRequestSchemaQrc721Urgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PrepareMintTransactionRequestSchemaQrc721
mkPrepareMintTransactionRequestSchemaQrc721 prepareMintTransactionRequestSchemaQrc721Location prepareMintTransactionRequestSchemaQrc721Type prepareMintTransactionRequestSchemaQrc721Urgency =
  PrepareMintTransactionRequestSchemaQrc721
  { prepareMintTransactionRequestSchemaQrc721Location
  , prepareMintTransactionRequestSchemaQrc721Type
  , prepareMintTransactionRequestSchemaQrc721Urgency
  , prepareMintTransactionRequestSchemaQrc721RequestDetails = Nothing
  }

-- ** PrepareNativeTransactionRequestSchema
-- | PrepareNativeTransactionRequestSchema
data PrepareNativeTransactionRequestSchema = PrepareNativeTransactionRequestSchema
  { prepareNativeTransactionRequestSchemaType :: !(Maybe Text) -- ^ "type" - The type of the object
  , prepareNativeTransactionRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareNativeTransactionRequestSchema
instance A.FromJSON PrepareNativeTransactionRequestSchema where
  parseJSON = A.withObject "PrepareNativeTransactionRequestSchema" $ \o ->
    PrepareNativeTransactionRequestSchema
      <$> (o .:? "type")
      <*> (o .:? "location")

-- | ToJSON PrepareNativeTransactionRequestSchema
instance A.ToJSON PrepareNativeTransactionRequestSchema where
  toJSON PrepareNativeTransactionRequestSchema {..} =
   _omitNulls
      [ "type" .= prepareNativeTransactionRequestSchemaType
      , "location" .= prepareNativeTransactionRequestSchemaLocation
      ]


-- | Construct a value of type 'PrepareNativeTransactionRequestSchema' (by applying it's required fields, if any)
mkPrepareNativeTransactionRequestSchema
  :: PrepareNativeTransactionRequestSchema
mkPrepareNativeTransactionRequestSchema =
  PrepareNativeTransactionRequestSchema
  { prepareNativeTransactionRequestSchemaType = Nothing
  , prepareNativeTransactionRequestSchemaLocation = Nothing
  }

-- ** PreparePaymentTransactionRequestSchema
-- | PreparePaymentTransactionRequestSchema
data PreparePaymentTransactionRequestSchema = PreparePaymentTransactionRequestSchema
  { preparePaymentTransactionRequestSchemaLocation :: !(Location) -- ^ /Required/ "location"
  , preparePaymentTransactionRequestSchemaType :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , preparePaymentTransactionRequestSchemaUrgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , preparePaymentTransactionRequestSchemaRequestDetails :: !(PaymentRequestDetailsSchema) -- ^ /Required/ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PreparePaymentTransactionRequestSchema
instance A.FromJSON PreparePaymentTransactionRequestSchema where
  parseJSON = A.withObject "PreparePaymentTransactionRequestSchema" $ \o ->
    PreparePaymentTransactionRequestSchema
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:  "requestDetails")

-- | ToJSON PreparePaymentTransactionRequestSchema
instance A.ToJSON PreparePaymentTransactionRequestSchema where
  toJSON PreparePaymentTransactionRequestSchema {..} =
   _omitNulls
      [ "location" .= preparePaymentTransactionRequestSchemaLocation
      , "type" .= preparePaymentTransactionRequestSchemaType
      , "urgency" .= preparePaymentTransactionRequestSchemaUrgency
      , "requestDetails" .= preparePaymentTransactionRequestSchemaRequestDetails
      ]


-- | Construct a value of type 'PreparePaymentTransactionRequestSchema' (by applying it's required fields, if any)
mkPreparePaymentTransactionRequestSchema
  :: Location -- ^ 'preparePaymentTransactionRequestSchemaLocation' 
  -> E'Type -- ^ 'preparePaymentTransactionRequestSchemaType': The type of the transaction
  -> E'Urgency -- ^ 'preparePaymentTransactionRequestSchemaUrgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PaymentRequestDetailsSchema -- ^ 'preparePaymentTransactionRequestSchemaRequestDetails' 
  -> PreparePaymentTransactionRequestSchema
mkPreparePaymentTransactionRequestSchema preparePaymentTransactionRequestSchemaLocation preparePaymentTransactionRequestSchemaType preparePaymentTransactionRequestSchemaUrgency preparePaymentTransactionRequestSchemaRequestDetails =
  PreparePaymentTransactionRequestSchema
  { preparePaymentTransactionRequestSchemaLocation
  , preparePaymentTransactionRequestSchemaType
  , preparePaymentTransactionRequestSchemaUrgency
  , preparePaymentTransactionRequestSchemaRequestDetails
  }

-- ** PrepareRemoveSecondaryAccountTransactionRequestSchema
-- | PrepareRemoveSecondaryAccountTransactionRequestSchema
data PrepareRemoveSecondaryAccountTransactionRequestSchema = PrepareRemoveSecondaryAccountTransactionRequestSchema
  { prepareRemoveSecondaryAccountTransactionRequestSchemaRemoveSecondaryAccountDetailsSchema :: !(Maybe RemoveSecondaryAccountDetailsSchema) -- ^ "removeSecondaryAccountDetailsSchema"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareRemoveSecondaryAccountTransactionRequestSchema
instance A.FromJSON PrepareRemoveSecondaryAccountTransactionRequestSchema where
  parseJSON = A.withObject "PrepareRemoveSecondaryAccountTransactionRequestSchema" $ \o ->
    PrepareRemoveSecondaryAccountTransactionRequestSchema
      <$> (o .:? "removeSecondaryAccountDetailsSchema")

-- | ToJSON PrepareRemoveSecondaryAccountTransactionRequestSchema
instance A.ToJSON PrepareRemoveSecondaryAccountTransactionRequestSchema where
  toJSON PrepareRemoveSecondaryAccountTransactionRequestSchema {..} =
   _omitNulls
      [ "removeSecondaryAccountDetailsSchema" .= prepareRemoveSecondaryAccountTransactionRequestSchemaRemoveSecondaryAccountDetailsSchema
      ]


-- | Construct a value of type 'PrepareRemoveSecondaryAccountTransactionRequestSchema' (by applying it's required fields, if any)
mkPrepareRemoveSecondaryAccountTransactionRequestSchema
  :: PrepareRemoveSecondaryAccountTransactionRequestSchema
mkPrepareRemoveSecondaryAccountTransactionRequestSchema =
  PrepareRemoveSecondaryAccountTransactionRequestSchema
  { prepareRemoveSecondaryAccountTransactionRequestSchemaRemoveSecondaryAccountDetailsSchema = Nothing
  }

-- ** PrepareRequest
-- | PrepareRequest
data PrepareRequest = PrepareRequest
  { prepareRequestApiLookupPath :: !(Maybe Text) -- ^ "apiLookupPath"
  , prepareRequestSmartContractTag :: !(Maybe [SmartContractTag]) -- ^ "smartContractTag"
  , prepareRequestUrgency :: !(Maybe Text) -- ^ "urgency"
  , prepareRequestRequestDetails :: !(Maybe PrepareRequestDetails) -- ^ "requestDetails"
  , prepareRequestSmartContractAddress :: !(Maybe Text) -- ^ "smartContractAddress"
  , prepareRequestLocation :: !(Maybe Location) -- ^ "location"
  , prepareRequestType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareRequest
instance A.FromJSON PrepareRequest where
  parseJSON = A.withObject "PrepareRequest" $ \o ->
    PrepareRequest
      <$> (o .:? "apiLookupPath")
      <*> (o .:? "smartContractTag")
      <*> (o .:? "urgency")
      <*> (o .:? "requestDetails")
      <*> (o .:? "smartContractAddress")
      <*> (o .:? "location")
      <*> (o .:? "type")

-- | ToJSON PrepareRequest
instance A.ToJSON PrepareRequest where
  toJSON PrepareRequest {..} =
   _omitNulls
      [ "apiLookupPath" .= prepareRequestApiLookupPath
      , "smartContractTag" .= prepareRequestSmartContractTag
      , "urgency" .= prepareRequestUrgency
      , "requestDetails" .= prepareRequestRequestDetails
      , "smartContractAddress" .= prepareRequestSmartContractAddress
      , "location" .= prepareRequestLocation
      , "type" .= prepareRequestType
      ]


-- | Construct a value of type 'PrepareRequest' (by applying it's required fields, if any)
mkPrepareRequest
  :: PrepareRequest
mkPrepareRequest =
  PrepareRequest
  { prepareRequestApiLookupPath = Nothing
  , prepareRequestSmartContractTag = Nothing
  , prepareRequestUrgency = Nothing
  , prepareRequestRequestDetails = Nothing
  , prepareRequestSmartContractAddress = Nothing
  , prepareRequestLocation = Nothing
  , prepareRequestType = Nothing
  }

-- ** PrepareRequestDetails
-- | PrepareRequestDetails
data PrepareRequestDetails = PrepareRequestDetails
  { prepareRequestDetailsMandate :: !(Maybe [Mandate]) -- ^ "mandate"
  , prepareRequestDetailsAliasDetails :: !(Maybe AliasDetails) -- ^ "aliasDetails"
  , prepareRequestDetailsPagination :: !(Maybe Pagination) -- ^ "pagination"
  , prepareRequestDetailsOrigin :: !(Maybe [Origin]) -- ^ "origin"
  , prepareRequestDetailsDestination :: !(Maybe [Destination]) -- ^ "destination"
  , prepareRequestDetailsTokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  , prepareRequestDetailsBlockSearchType :: !(Maybe Text) -- ^ "blockSearchType"
  , prepareRequestDetailsPayer :: !(Maybe [Payer]) -- ^ "payer"
  , prepareRequestDetailsCollector :: !(Maybe Collector) -- ^ "collector"
  , prepareRequestDetailsPayee :: !(Maybe [Payee]) -- ^ "payee"
  , prepareRequestDetailsAdditionalOwner :: !(Maybe AdditionalOwner) -- ^ "additionalOwner"
  , prepareRequestDetailsOwner :: !(Maybe Owner) -- ^ "owner"
  , prepareRequestDetailsCreator :: !(Maybe Creator) -- ^ "creator"
  , prepareRequestDetailsReceiver :: !(Maybe [Receiver]) -- ^ "receiver"
  , prepareRequestDetailsTokenId :: !(Maybe Text) -- ^ "tokenId" - Unique identifier for the specific token
  , prepareRequestDetailsMessage :: !(Maybe Text) -- ^ "message"
  , prepareRequestDetailsLockDetails :: !(Maybe LockDetails) -- ^ "lockDetails"
  , prepareRequestDetailsBlockId :: !(Maybe Text) -- ^ "blockId"
  , prepareRequestDetailsAccountId :: !(Maybe Text) -- ^ "accountId" - The unique identifiers of the account
  , prepareRequestDetailsTokenUnit :: !(Maybe Text) -- ^ "tokenUnit" - The unit of this token
  , prepareRequestDetailsBeneficiary :: !(Maybe Beneficiary) -- ^ "beneficiary"
  , prepareRequestDetailsSender :: !(Maybe [Sender]) -- ^ "sender"
  , prepareRequestDetailsAccountDetails :: !(Maybe AccountDetails) -- ^ "accountDetails"
  , prepareRequestDetailsOverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  , prepareRequestDetailsTotalPaymentAmount :: !(Maybe Payment) -- ^ "totalPaymentAmount"
  , prepareRequestDetailsSignerAccount :: !(Maybe SignerAccount) -- ^ "signerAccount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareRequestDetails
instance A.FromJSON PrepareRequestDetails where
  parseJSON = A.withObject "PrepareRequestDetails" $ \o ->
    PrepareRequestDetails
      <$> (o .:? "mandate")
      <*> (o .:? "aliasDetails")
      <*> (o .:? "pagination")
      <*> (o .:? "origin")
      <*> (o .:? "destination")
      <*> (o .:? "tokenName")
      <*> (o .:? "blockSearchType")
      <*> (o .:? "payer")
      <*> (o .:? "collector")
      <*> (o .:? "payee")
      <*> (o .:? "additionalOwner")
      <*> (o .:? "owner")
      <*> (o .:? "creator")
      <*> (o .:? "receiver")
      <*> (o .:? "tokenId")
      <*> (o .:? "message")
      <*> (o .:? "lockDetails")
      <*> (o .:? "blockId")
      <*> (o .:? "accountId")
      <*> (o .:? "tokenUnit")
      <*> (o .:? "beneficiary")
      <*> (o .:? "sender")
      <*> (o .:? "accountDetails")
      <*> (o .:? "overledgerSigningType")
      <*> (o .:? "totalPaymentAmount")
      <*> (o .:? "signerAccount")

-- | ToJSON PrepareRequestDetails
instance A.ToJSON PrepareRequestDetails where
  toJSON PrepareRequestDetails {..} =
   _omitNulls
      [ "mandate" .= prepareRequestDetailsMandate
      , "aliasDetails" .= prepareRequestDetailsAliasDetails
      , "pagination" .= prepareRequestDetailsPagination
      , "origin" .= prepareRequestDetailsOrigin
      , "destination" .= prepareRequestDetailsDestination
      , "tokenName" .= prepareRequestDetailsTokenName
      , "blockSearchType" .= prepareRequestDetailsBlockSearchType
      , "payer" .= prepareRequestDetailsPayer
      , "collector" .= prepareRequestDetailsCollector
      , "payee" .= prepareRequestDetailsPayee
      , "additionalOwner" .= prepareRequestDetailsAdditionalOwner
      , "owner" .= prepareRequestDetailsOwner
      , "creator" .= prepareRequestDetailsCreator
      , "receiver" .= prepareRequestDetailsReceiver
      , "tokenId" .= prepareRequestDetailsTokenId
      , "message" .= prepareRequestDetailsMessage
      , "lockDetails" .= prepareRequestDetailsLockDetails
      , "blockId" .= prepareRequestDetailsBlockId
      , "accountId" .= prepareRequestDetailsAccountId
      , "tokenUnit" .= prepareRequestDetailsTokenUnit
      , "beneficiary" .= prepareRequestDetailsBeneficiary
      , "sender" .= prepareRequestDetailsSender
      , "accountDetails" .= prepareRequestDetailsAccountDetails
      , "overledgerSigningType" .= prepareRequestDetailsOverledgerSigningType
      , "totalPaymentAmount" .= prepareRequestDetailsTotalPaymentAmount
      , "signerAccount" .= prepareRequestDetailsSignerAccount
      ]


-- | Construct a value of type 'PrepareRequestDetails' (by applying it's required fields, if any)
mkPrepareRequestDetails
  :: PrepareRequestDetails
mkPrepareRequestDetails =
  PrepareRequestDetails
  { prepareRequestDetailsMandate = Nothing
  , prepareRequestDetailsAliasDetails = Nothing
  , prepareRequestDetailsPagination = Nothing
  , prepareRequestDetailsOrigin = Nothing
  , prepareRequestDetailsDestination = Nothing
  , prepareRequestDetailsTokenName = Nothing
  , prepareRequestDetailsBlockSearchType = Nothing
  , prepareRequestDetailsPayer = Nothing
  , prepareRequestDetailsCollector = Nothing
  , prepareRequestDetailsPayee = Nothing
  , prepareRequestDetailsAdditionalOwner = Nothing
  , prepareRequestDetailsOwner = Nothing
  , prepareRequestDetailsCreator = Nothing
  , prepareRequestDetailsReceiver = Nothing
  , prepareRequestDetailsTokenId = Nothing
  , prepareRequestDetailsMessage = Nothing
  , prepareRequestDetailsLockDetails = Nothing
  , prepareRequestDetailsBlockId = Nothing
  , prepareRequestDetailsAccountId = Nothing
  , prepareRequestDetailsTokenUnit = Nothing
  , prepareRequestDetailsBeneficiary = Nothing
  , prepareRequestDetailsSender = Nothing
  , prepareRequestDetailsAccountDetails = Nothing
  , prepareRequestDetailsOverledgerSigningType = Nothing
  , prepareRequestDetailsTotalPaymentAmount = Nothing
  , prepareRequestDetailsSignerAccount = Nothing
  }

-- ** PrepareSearchResponseSchema
-- | PrepareSearchResponseSchema
data PrepareSearchResponseSchema = PrepareSearchResponseSchema
  { prepareSearchResponseSchemaGatewayFee :: !(Maybe Fee) -- ^ "gatewayFee"
  , prepareSearchResponseSchemaRequestId :: !(Maybe Text) -- ^ "requestId" - The ID assigned to a preparation request in Overledger
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareSearchResponseSchema
instance A.FromJSON PrepareSearchResponseSchema where
  parseJSON = A.withObject "PrepareSearchResponseSchema" $ \o ->
    PrepareSearchResponseSchema
      <$> (o .:? "gatewayFee")
      <*> (o .:? "requestId")

-- | ToJSON PrepareSearchResponseSchema
instance A.ToJSON PrepareSearchResponseSchema where
  toJSON PrepareSearchResponseSchema {..} =
   _omitNulls
      [ "gatewayFee" .= prepareSearchResponseSchemaGatewayFee
      , "requestId" .= prepareSearchResponseSchemaRequestId
      ]


-- | Construct a value of type 'PrepareSearchResponseSchema' (by applying it's required fields, if any)
mkPrepareSearchResponseSchema
  :: PrepareSearchResponseSchema
mkPrepareSearchResponseSchema =
  PrepareSearchResponseSchema
  { prepareSearchResponseSchemaGatewayFee = Nothing
  , prepareSearchResponseSchemaRequestId = Nothing
  }

-- ** PrepareSearchSchema
-- | PrepareSearchSchema
data PrepareSearchSchema = PrepareSearchSchema
  { prepareSearchSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareSearchSchema
instance A.FromJSON PrepareSearchSchema where
  parseJSON = A.withObject "PrepareSearchSchema" $ \o ->
    PrepareSearchSchema
      <$> (o .:? "location")

-- | ToJSON PrepareSearchSchema
instance A.ToJSON PrepareSearchSchema where
  toJSON PrepareSearchSchema {..} =
   _omitNulls
      [ "location" .= prepareSearchSchemaLocation
      ]


-- | Construct a value of type 'PrepareSearchSchema' (by applying it's required fields, if any)
mkPrepareSearchSchema
  :: PrepareSearchSchema
mkPrepareSearchSchema =
  PrepareSearchSchema
  { prepareSearchSchemaLocation = Nothing
  }

-- ** PrepareSearchSmartContractRequestSchema
-- | PrepareSearchSmartContractRequestSchema
data PrepareSearchSmartContractRequestSchema = PrepareSearchSmartContractRequestSchema
  { prepareSearchSmartContractRequestSchemaRequestDetails :: !(Maybe SmartContractSearchRequestDetails) -- ^ "requestDetails"
  , prepareSearchSmartContractRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareSearchSmartContractRequestSchema
instance A.FromJSON PrepareSearchSmartContractRequestSchema where
  parseJSON = A.withObject "PrepareSearchSmartContractRequestSchema" $ \o ->
    PrepareSearchSmartContractRequestSchema
      <$> (o .:? "requestDetails")
      <*> (o .:? "location")

-- | ToJSON PrepareSearchSmartContractRequestSchema
instance A.ToJSON PrepareSearchSmartContractRequestSchema where
  toJSON PrepareSearchSmartContractRequestSchema {..} =
   _omitNulls
      [ "requestDetails" .= prepareSearchSmartContractRequestSchemaRequestDetails
      , "location" .= prepareSearchSmartContractRequestSchemaLocation
      ]


-- | Construct a value of type 'PrepareSearchSmartContractRequestSchema' (by applying it's required fields, if any)
mkPrepareSearchSmartContractRequestSchema
  :: PrepareSearchSmartContractRequestSchema
mkPrepareSearchSmartContractRequestSchema =
  PrepareSearchSmartContractRequestSchema
  { prepareSearchSmartContractRequestSchemaRequestDetails = Nothing
  , prepareSearchSmartContractRequestSchemaLocation = Nothing
  }

-- ** PrepareTransactionResponse
-- | PrepareTransactionResponse
data PrepareTransactionResponse = PrepareTransactionResponse
  { prepareTransactionResponseGatewayFee :: !(Maybe Fee) -- ^ "gatewayFee"
  , prepareTransactionResponseRequestId :: !(Maybe Text) -- ^ "requestId" - The ID assigned to a preparation request in Overledger
  , prepareTransactionResponseDltFee :: !(Maybe Fee) -- ^ "dltFee"
  , prepareTransactionResponseNativeData :: !(Maybe A.Value) -- ^ "nativeData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareTransactionResponse
instance A.FromJSON PrepareTransactionResponse where
  parseJSON = A.withObject "PrepareTransactionResponse" $ \o ->
    PrepareTransactionResponse
      <$> (o .:? "gatewayFee")
      <*> (o .:? "requestId")
      <*> (o .:? "dltFee")
      <*> (o .:? "nativeData")

-- | ToJSON PrepareTransactionResponse
instance A.ToJSON PrepareTransactionResponse where
  toJSON PrepareTransactionResponse {..} =
   _omitNulls
      [ "gatewayFee" .= prepareTransactionResponseGatewayFee
      , "requestId" .= prepareTransactionResponseRequestId
      , "dltFee" .= prepareTransactionResponseDltFee
      , "nativeData" .= prepareTransactionResponseNativeData
      ]


-- | Construct a value of type 'PrepareTransactionResponse' (by applying it's required fields, if any)
mkPrepareTransactionResponse
  :: PrepareTransactionResponse
mkPrepareTransactionResponse =
  PrepareTransactionResponse
  { prepareTransactionResponseGatewayFee = Nothing
  , prepareTransactionResponseRequestId = Nothing
  , prepareTransactionResponseDltFee = Nothing
  , prepareTransactionResponseNativeData = Nothing
  }

-- ** PrepareTransactionSmartContractInvokeRequestSchema
-- | PrepareTransactionSmartContractInvokeRequestSchema
data PrepareTransactionSmartContractInvokeRequestSchema = PrepareTransactionSmartContractInvokeRequestSchema
  { prepareTransactionSmartContractInvokeRequestSchemaLocation :: !(Location) -- ^ /Required/ "location"
  , prepareTransactionSmartContractInvokeRequestSchemaType :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , prepareTransactionSmartContractInvokeRequestSchemaUrgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , prepareTransactionSmartContractInvokeRequestSchemaRequestDetails :: !(Maybe SmartContractInvokeRequestDetailsSchema) -- ^ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareTransactionSmartContractInvokeRequestSchema
instance A.FromJSON PrepareTransactionSmartContractInvokeRequestSchema where
  parseJSON = A.withObject "PrepareTransactionSmartContractInvokeRequestSchema" $ \o ->
    PrepareTransactionSmartContractInvokeRequestSchema
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:? "requestDetails")

-- | ToJSON PrepareTransactionSmartContractInvokeRequestSchema
instance A.ToJSON PrepareTransactionSmartContractInvokeRequestSchema where
  toJSON PrepareTransactionSmartContractInvokeRequestSchema {..} =
   _omitNulls
      [ "location" .= prepareTransactionSmartContractInvokeRequestSchemaLocation
      , "type" .= prepareTransactionSmartContractInvokeRequestSchemaType
      , "urgency" .= prepareTransactionSmartContractInvokeRequestSchemaUrgency
      , "requestDetails" .= prepareTransactionSmartContractInvokeRequestSchemaRequestDetails
      ]


-- | Construct a value of type 'PrepareTransactionSmartContractInvokeRequestSchema' (by applying it's required fields, if any)
mkPrepareTransactionSmartContractInvokeRequestSchema
  :: Location -- ^ 'prepareTransactionSmartContractInvokeRequestSchemaLocation' 
  -> E'Type -- ^ 'prepareTransactionSmartContractInvokeRequestSchemaType': The type of the transaction
  -> E'Urgency -- ^ 'prepareTransactionSmartContractInvokeRequestSchemaUrgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PrepareTransactionSmartContractInvokeRequestSchema
mkPrepareTransactionSmartContractInvokeRequestSchema prepareTransactionSmartContractInvokeRequestSchemaLocation prepareTransactionSmartContractInvokeRequestSchemaType prepareTransactionSmartContractInvokeRequestSchemaUrgency =
  PrepareTransactionSmartContractInvokeRequestSchema
  { prepareTransactionSmartContractInvokeRequestSchemaLocation
  , prepareTransactionSmartContractInvokeRequestSchemaType
  , prepareTransactionSmartContractInvokeRequestSchemaUrgency
  , prepareTransactionSmartContractInvokeRequestSchemaRequestDetails = Nothing
  }

-- ** PrepareTransferTransactionRequestSchema
-- | PrepareTransferTransactionRequestSchema
data PrepareTransferTransactionRequestSchema = PrepareTransferTransactionRequestSchema
  { prepareTransferTransactionRequestSchemaLocation :: !(Location) -- ^ /Required/ "location"
  , prepareTransferTransactionRequestSchemaType :: !(E'Type) -- ^ /Required/ "type" - The type of the transaction
  , prepareTransferTransactionRequestSchemaUrgency :: !(E'Urgency) -- ^ /Required/ "urgency" - This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  , prepareTransferTransactionRequestSchemaRequestDetails :: !(Maybe TransferRequestDetailsSchema) -- ^ "requestDetails"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PrepareTransferTransactionRequestSchema
instance A.FromJSON PrepareTransferTransactionRequestSchema where
  parseJSON = A.withObject "PrepareTransferTransactionRequestSchema" $ \o ->
    PrepareTransferTransactionRequestSchema
      <$> (o .:  "location")
      <*> (o .:  "type")
      <*> (o .:  "urgency")
      <*> (o .:? "requestDetails")

-- | ToJSON PrepareTransferTransactionRequestSchema
instance A.ToJSON PrepareTransferTransactionRequestSchema where
  toJSON PrepareTransferTransactionRequestSchema {..} =
   _omitNulls
      [ "location" .= prepareTransferTransactionRequestSchemaLocation
      , "type" .= prepareTransferTransactionRequestSchemaType
      , "urgency" .= prepareTransferTransactionRequestSchemaUrgency
      , "requestDetails" .= prepareTransferTransactionRequestSchemaRequestDetails
      ]


-- | Construct a value of type 'PrepareTransferTransactionRequestSchema' (by applying it's required fields, if any)
mkPrepareTransferTransactionRequestSchema
  :: Location -- ^ 'prepareTransferTransactionRequestSchemaLocation' 
  -> E'Type -- ^ 'prepareTransferTransactionRequestSchemaType': The type of the transaction
  -> E'Urgency -- ^ 'prepareTransferTransactionRequestSchemaUrgency': This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
  -> PrepareTransferTransactionRequestSchema
mkPrepareTransferTransactionRequestSchema prepareTransferTransactionRequestSchemaLocation prepareTransferTransactionRequestSchemaType prepareTransferTransactionRequestSchemaUrgency =
  PrepareTransferTransactionRequestSchema
  { prepareTransferTransactionRequestSchemaLocation
  , prepareTransferTransactionRequestSchemaType
  , prepareTransferTransactionRequestSchemaUrgency
  , prepareTransferTransactionRequestSchemaRequestDetails = Nothing
  }

-- ** ReadAccountBalanceRequestSchema
-- | ReadAccountBalanceRequestSchema
data ReadAccountBalanceRequestSchema = ReadAccountBalanceRequestSchema
  { readAccountBalanceRequestSchemaRequestDetails :: !(Maybe A.Value) -- ^ "requestDetails"
  , readAccountBalanceRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadAccountBalanceRequestSchema
instance A.FromJSON ReadAccountBalanceRequestSchema where
  parseJSON = A.withObject "ReadAccountBalanceRequestSchema" $ \o ->
    ReadAccountBalanceRequestSchema
      <$> (o .:? "requestDetails")
      <*> (o .:? "location")

-- | ToJSON ReadAccountBalanceRequestSchema
instance A.ToJSON ReadAccountBalanceRequestSchema where
  toJSON ReadAccountBalanceRequestSchema {..} =
   _omitNulls
      [ "requestDetails" .= readAccountBalanceRequestSchemaRequestDetails
      , "location" .= readAccountBalanceRequestSchemaLocation
      ]


-- | Construct a value of type 'ReadAccountBalanceRequestSchema' (by applying it's required fields, if any)
mkReadAccountBalanceRequestSchema
  :: ReadAccountBalanceRequestSchema
mkReadAccountBalanceRequestSchema =
  ReadAccountBalanceRequestSchema
  { readAccountBalanceRequestSchemaRequestDetails = Nothing
  , readAccountBalanceRequestSchemaLocation = Nothing
  }

-- ** ReadApprovedAccountAllowanceRequestSchema
-- | ReadApprovedAccountAllowanceRequestSchema
data ReadApprovedAccountAllowanceRequestSchema = ReadApprovedAccountAllowanceRequestSchema
  { readApprovedAccountAllowanceRequestSchemaRequestDetails :: !(Maybe A.Value) -- ^ "requestDetails"
  , readApprovedAccountAllowanceRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadApprovedAccountAllowanceRequestSchema
instance A.FromJSON ReadApprovedAccountAllowanceRequestSchema where
  parseJSON = A.withObject "ReadApprovedAccountAllowanceRequestSchema" $ \o ->
    ReadApprovedAccountAllowanceRequestSchema
      <$> (o .:? "requestDetails")
      <*> (o .:? "location")

-- | ToJSON ReadApprovedAccountAllowanceRequestSchema
instance A.ToJSON ReadApprovedAccountAllowanceRequestSchema where
  toJSON ReadApprovedAccountAllowanceRequestSchema {..} =
   _omitNulls
      [ "requestDetails" .= readApprovedAccountAllowanceRequestSchemaRequestDetails
      , "location" .= readApprovedAccountAllowanceRequestSchemaLocation
      ]


-- | Construct a value of type 'ReadApprovedAccountAllowanceRequestSchema' (by applying it's required fields, if any)
mkReadApprovedAccountAllowanceRequestSchema
  :: ReadApprovedAccountAllowanceRequestSchema
mkReadApprovedAccountAllowanceRequestSchema =
  ReadApprovedAccountAllowanceRequestSchema
  { readApprovedAccountAllowanceRequestSchemaRequestDetails = Nothing
  , readApprovedAccountAllowanceRequestSchemaLocation = Nothing
  }

-- ** ReadApprovedAccountRequestDetailsSchema
-- | ReadApprovedAccountRequestDetailsSchema
data ReadApprovedAccountRequestDetailsSchema = ReadApprovedAccountRequestDetailsSchema
  { readApprovedAccountRequestDetailsSchemaTokenId :: !(Maybe Text) -- ^ "tokenId" - Id of the token
  , readApprovedAccountRequestDetailsSchemaTokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadApprovedAccountRequestDetailsSchema
instance A.FromJSON ReadApprovedAccountRequestDetailsSchema where
  parseJSON = A.withObject "ReadApprovedAccountRequestDetailsSchema" $ \o ->
    ReadApprovedAccountRequestDetailsSchema
      <$> (o .:? "tokenId")
      <*> (o .:? "tokenName")

-- | ToJSON ReadApprovedAccountRequestDetailsSchema
instance A.ToJSON ReadApprovedAccountRequestDetailsSchema where
  toJSON ReadApprovedAccountRequestDetailsSchema {..} =
   _omitNulls
      [ "tokenId" .= readApprovedAccountRequestDetailsSchemaTokenId
      , "tokenName" .= readApprovedAccountRequestDetailsSchemaTokenName
      ]


-- | Construct a value of type 'ReadApprovedAccountRequestDetailsSchema' (by applying it's required fields, if any)
mkReadApprovedAccountRequestDetailsSchema
  :: ReadApprovedAccountRequestDetailsSchema
mkReadApprovedAccountRequestDetailsSchema =
  ReadApprovedAccountRequestDetailsSchema
  { readApprovedAccountRequestDetailsSchemaTokenId = Nothing
  , readApprovedAccountRequestDetailsSchemaTokenName = Nothing
  }

-- ** ReadApprovedAccountRequestSchema
-- | ReadApprovedAccountRequestSchema
data ReadApprovedAccountRequestSchema = ReadApprovedAccountRequestSchema
  { readApprovedAccountRequestSchemaRequestDetails :: !(Maybe ReadApprovedAccountRequestDetailsSchema) -- ^ "requestDetails"
  , readApprovedAccountRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadApprovedAccountRequestSchema
instance A.FromJSON ReadApprovedAccountRequestSchema where
  parseJSON = A.withObject "ReadApprovedAccountRequestSchema" $ \o ->
    ReadApprovedAccountRequestSchema
      <$> (o .:? "requestDetails")
      <*> (o .:? "location")

-- | ToJSON ReadApprovedAccountRequestSchema
instance A.ToJSON ReadApprovedAccountRequestSchema where
  toJSON ReadApprovedAccountRequestSchema {..} =
   _omitNulls
      [ "requestDetails" .= readApprovedAccountRequestSchemaRequestDetails
      , "location" .= readApprovedAccountRequestSchemaLocation
      ]


-- | Construct a value of type 'ReadApprovedAccountRequestSchema' (by applying it's required fields, if any)
mkReadApprovedAccountRequestSchema
  :: ReadApprovedAccountRequestSchema
mkReadApprovedAccountRequestSchema =
  ReadApprovedAccountRequestSchema
  { readApprovedAccountRequestSchemaRequestDetails = Nothing
  , readApprovedAccountRequestSchemaLocation = Nothing
  }

-- ** ReadBalanceRequestDetailsSchema
-- | ReadBalanceRequestDetailsSchema
data ReadBalanceRequestDetailsSchema = ReadBalanceRequestDetailsSchema
  { readBalanceRequestDetailsSchemaTokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  , readBalanceRequestDetailsSchemaAccountId :: !(Maybe Text) -- ^ "accountId" - The unique identifiers of the account
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadBalanceRequestDetailsSchema
instance A.FromJSON ReadBalanceRequestDetailsSchema where
  parseJSON = A.withObject "ReadBalanceRequestDetailsSchema" $ \o ->
    ReadBalanceRequestDetailsSchema
      <$> (o .:? "tokenName")
      <*> (o .:? "accountId")

-- | ToJSON ReadBalanceRequestDetailsSchema
instance A.ToJSON ReadBalanceRequestDetailsSchema where
  toJSON ReadBalanceRequestDetailsSchema {..} =
   _omitNulls
      [ "tokenName" .= readBalanceRequestDetailsSchemaTokenName
      , "accountId" .= readBalanceRequestDetailsSchemaAccountId
      ]


-- | Construct a value of type 'ReadBalanceRequestDetailsSchema' (by applying it's required fields, if any)
mkReadBalanceRequestDetailsSchema
  :: ReadBalanceRequestDetailsSchema
mkReadBalanceRequestDetailsSchema =
  ReadBalanceRequestDetailsSchema
  { readBalanceRequestDetailsSchemaTokenName = Nothing
  , readBalanceRequestDetailsSchemaAccountId = Nothing
  }

-- ** ReadBalanceRequestSchema
-- | ReadBalanceRequestSchema
data ReadBalanceRequestSchema = ReadBalanceRequestSchema
  { readBalanceRequestSchemaRequestDetails :: !(Maybe ReadBalanceRequestDetailsSchema) -- ^ "requestDetails"
  , readBalanceRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadBalanceRequestSchema
instance A.FromJSON ReadBalanceRequestSchema where
  parseJSON = A.withObject "ReadBalanceRequestSchema" $ \o ->
    ReadBalanceRequestSchema
      <$> (o .:? "requestDetails")
      <*> (o .:? "location")

-- | ToJSON ReadBalanceRequestSchema
instance A.ToJSON ReadBalanceRequestSchema where
  toJSON ReadBalanceRequestSchema {..} =
   _omitNulls
      [ "requestDetails" .= readBalanceRequestSchemaRequestDetails
      , "location" .= readBalanceRequestSchemaLocation
      ]


-- | Construct a value of type 'ReadBalanceRequestSchema' (by applying it's required fields, if any)
mkReadBalanceRequestSchema
  :: ReadBalanceRequestSchema
mkReadBalanceRequestSchema =
  ReadBalanceRequestSchema
  { readBalanceRequestSchemaRequestDetails = Nothing
  , readBalanceRequestSchemaLocation = Nothing
  }

-- ** ReadContractOwnerRequestDetailsSchema
-- | ReadContractOwnerRequestDetailsSchema
data ReadContractOwnerRequestDetailsSchema = ReadContractOwnerRequestDetailsSchema
  { readContractOwnerRequestDetailsSchemaTokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadContractOwnerRequestDetailsSchema
instance A.FromJSON ReadContractOwnerRequestDetailsSchema where
  parseJSON = A.withObject "ReadContractOwnerRequestDetailsSchema" $ \o ->
    ReadContractOwnerRequestDetailsSchema
      <$> (o .:? "tokenName")

-- | ToJSON ReadContractOwnerRequestDetailsSchema
instance A.ToJSON ReadContractOwnerRequestDetailsSchema where
  toJSON ReadContractOwnerRequestDetailsSchema {..} =
   _omitNulls
      [ "tokenName" .= readContractOwnerRequestDetailsSchemaTokenName
      ]


-- | Construct a value of type 'ReadContractOwnerRequestDetailsSchema' (by applying it's required fields, if any)
mkReadContractOwnerRequestDetailsSchema
  :: ReadContractOwnerRequestDetailsSchema
mkReadContractOwnerRequestDetailsSchema =
  ReadContractOwnerRequestDetailsSchema
  { readContractOwnerRequestDetailsSchemaTokenName = Nothing
  }

-- ** ReadContractOwnerRequestSchema
-- | ReadContractOwnerRequestSchema
data ReadContractOwnerRequestSchema = ReadContractOwnerRequestSchema
  { readContractOwnerRequestSchemaRequestDetails :: !(Maybe ReadContractOwnerRequestDetailsSchema) -- ^ "requestDetails"
  , readContractOwnerRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadContractOwnerRequestSchema
instance A.FromJSON ReadContractOwnerRequestSchema where
  parseJSON = A.withObject "ReadContractOwnerRequestSchema" $ \o ->
    ReadContractOwnerRequestSchema
      <$> (o .:? "requestDetails")
      <*> (o .:? "location")

-- | ToJSON ReadContractOwnerRequestSchema
instance A.ToJSON ReadContractOwnerRequestSchema where
  toJSON ReadContractOwnerRequestSchema {..} =
   _omitNulls
      [ "requestDetails" .= readContractOwnerRequestSchemaRequestDetails
      , "location" .= readContractOwnerRequestSchemaLocation
      ]


-- | Construct a value of type 'ReadContractOwnerRequestSchema' (by applying it's required fields, if any)
mkReadContractOwnerRequestSchema
  :: ReadContractOwnerRequestSchema
mkReadContractOwnerRequestSchema =
  ReadContractOwnerRequestSchema
  { readContractOwnerRequestSchemaRequestDetails = Nothing
  , readContractOwnerRequestSchemaLocation = Nothing
  }

-- ** ReadTokenOwnerRequestDetailsSchema
-- | ReadTokenOwnerRequestDetailsSchema
data ReadTokenOwnerRequestDetailsSchema = ReadTokenOwnerRequestDetailsSchema
  { readTokenOwnerRequestDetailsSchemaTokenId :: !(Maybe Text) -- ^ "tokenId" - Id of the token
  , readTokenOwnerRequestDetailsSchemaTokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadTokenOwnerRequestDetailsSchema
instance A.FromJSON ReadTokenOwnerRequestDetailsSchema where
  parseJSON = A.withObject "ReadTokenOwnerRequestDetailsSchema" $ \o ->
    ReadTokenOwnerRequestDetailsSchema
      <$> (o .:? "tokenId")
      <*> (o .:? "tokenName")

-- | ToJSON ReadTokenOwnerRequestDetailsSchema
instance A.ToJSON ReadTokenOwnerRequestDetailsSchema where
  toJSON ReadTokenOwnerRequestDetailsSchema {..} =
   _omitNulls
      [ "tokenId" .= readTokenOwnerRequestDetailsSchemaTokenId
      , "tokenName" .= readTokenOwnerRequestDetailsSchemaTokenName
      ]


-- | Construct a value of type 'ReadTokenOwnerRequestDetailsSchema' (by applying it's required fields, if any)
mkReadTokenOwnerRequestDetailsSchema
  :: ReadTokenOwnerRequestDetailsSchema
mkReadTokenOwnerRequestDetailsSchema =
  ReadTokenOwnerRequestDetailsSchema
  { readTokenOwnerRequestDetailsSchemaTokenId = Nothing
  , readTokenOwnerRequestDetailsSchemaTokenName = Nothing
  }

-- ** ReadTokenOwnerRequestSchema
-- | ReadTokenOwnerRequestSchema
data ReadTokenOwnerRequestSchema = ReadTokenOwnerRequestSchema
  { readTokenOwnerRequestSchemaRequestDetails :: !(Maybe ReadTokenOwnerRequestDetailsSchema) -- ^ "requestDetails"
  , readTokenOwnerRequestSchemaLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ReadTokenOwnerRequestSchema
instance A.FromJSON ReadTokenOwnerRequestSchema where
  parseJSON = A.withObject "ReadTokenOwnerRequestSchema" $ \o ->
    ReadTokenOwnerRequestSchema
      <$> (o .:? "requestDetails")
      <*> (o .:? "location")

-- | ToJSON ReadTokenOwnerRequestSchema
instance A.ToJSON ReadTokenOwnerRequestSchema where
  toJSON ReadTokenOwnerRequestSchema {..} =
   _omitNulls
      [ "requestDetails" .= readTokenOwnerRequestSchemaRequestDetails
      , "location" .= readTokenOwnerRequestSchemaLocation
      ]


-- | Construct a value of type 'ReadTokenOwnerRequestSchema' (by applying it's required fields, if any)
mkReadTokenOwnerRequestSchema
  :: ReadTokenOwnerRequestSchema
mkReadTokenOwnerRequestSchema =
  ReadTokenOwnerRequestSchema
  { readTokenOwnerRequestSchemaRequestDetails = Nothing
  , readTokenOwnerRequestSchemaLocation = Nothing
  }

-- ** Receiver
-- | Receiver
-- The Destination of this transaction.
data Receiver = Receiver
  { receiverAccountId :: !(Maybe Text) -- ^ "accountId"
  , receiverTransfer :: !(Maybe Transfer) -- ^ "transfer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Receiver
instance A.FromJSON Receiver where
  parseJSON = A.withObject "Receiver" $ \o ->
    Receiver
      <$> (o .:? "accountId")
      <*> (o .:? "transfer")

-- | ToJSON Receiver
instance A.ToJSON Receiver where
  toJSON Receiver {..} =
   _omitNulls
      [ "accountId" .= receiverAccountId
      , "transfer" .= receiverTransfer
      ]


-- | Construct a value of type 'Receiver' (by applying it's required fields, if any)
mkReceiver
  :: Receiver
mkReceiver =
  Receiver
  { receiverAccountId = Nothing
  , receiverTransfer = Nothing
  }

-- ** RemoveSecondaryAccountDetailsSchema
-- | RemoveSecondaryAccountDetailsSchema
data RemoveSecondaryAccountDetailsSchema = RemoveSecondaryAccountDetailsSchema
  { removeSecondaryAccountDetailsSchemaOwner :: !(Maybe OwnerRemoveSecondarySchema) -- ^ "owner"
  , removeSecondaryAccountDetailsSchemaAdditionalOwner :: !(Maybe AdditionalOwnerRemoveSecondarySchema) -- ^ "additionalOwner"
  , removeSecondaryAccountDetailsSchemaMessage :: !(Maybe Text) -- ^ "message" - Any text-based element of the data payload
  , removeSecondaryAccountDetailsSchemaOverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RemoveSecondaryAccountDetailsSchema
instance A.FromJSON RemoveSecondaryAccountDetailsSchema where
  parseJSON = A.withObject "RemoveSecondaryAccountDetailsSchema" $ \o ->
    RemoveSecondaryAccountDetailsSchema
      <$> (o .:? "owner")
      <*> (o .:? "additionalOwner")
      <*> (o .:? "message")
      <*> (o .:? "overledgerSigningType")

-- | ToJSON RemoveSecondaryAccountDetailsSchema
instance A.ToJSON RemoveSecondaryAccountDetailsSchema where
  toJSON RemoveSecondaryAccountDetailsSchema {..} =
   _omitNulls
      [ "owner" .= removeSecondaryAccountDetailsSchemaOwner
      , "additionalOwner" .= removeSecondaryAccountDetailsSchemaAdditionalOwner
      , "message" .= removeSecondaryAccountDetailsSchemaMessage
      , "overledgerSigningType" .= removeSecondaryAccountDetailsSchemaOverledgerSigningType
      ]


-- | Construct a value of type 'RemoveSecondaryAccountDetailsSchema' (by applying it's required fields, if any)
mkRemoveSecondaryAccountDetailsSchema
  :: RemoveSecondaryAccountDetailsSchema
mkRemoveSecondaryAccountDetailsSchema =
  RemoveSecondaryAccountDetailsSchema
  { removeSecondaryAccountDetailsSchemaOwner = Nothing
  , removeSecondaryAccountDetailsSchemaAdditionalOwner = Nothing
  , removeSecondaryAccountDetailsSchemaMessage = Nothing
  , removeSecondaryAccountDetailsSchemaOverledgerSigningType = Nothing
  }

-- ** ResourceMonitoredAddressDetails
-- | ResourceMonitoredAddressDetails
data ResourceMonitoredAddressDetails = ResourceMonitoredAddressDetails
  { resourceMonitoredAddressDetailsAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoredAddressDetails
instance A.FromJSON ResourceMonitoredAddressDetails where
  parseJSON = A.withObject "ResourceMonitoredAddressDetails" $ \o ->
    ResourceMonitoredAddressDetails
      <$> (o .:? "addressId")

-- | ToJSON ResourceMonitoredAddressDetails
instance A.ToJSON ResourceMonitoredAddressDetails where
  toJSON ResourceMonitoredAddressDetails {..} =
   _omitNulls
      [ "addressId" .= resourceMonitoredAddressDetailsAddressId
      ]


-- | Construct a value of type 'ResourceMonitoredAddressDetails' (by applying it's required fields, if any)
mkResourceMonitoredAddressDetails
  :: ResourceMonitoredAddressDetails
mkResourceMonitoredAddressDetails =
  ResourceMonitoredAddressDetails
  { resourceMonitoredAddressDetailsAddressId = Nothing
  }

-- ** ResourceMonitoringAddressDetails
-- | ResourceMonitoringAddressDetails
data ResourceMonitoringAddressDetails = ResourceMonitoringAddressDetails
  { resourceMonitoringAddressDetailsAddressId :: !(Maybe Text) -- ^ "addressId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringAddressDetails
instance A.FromJSON ResourceMonitoringAddressDetails where
  parseJSON = A.withObject "ResourceMonitoringAddressDetails" $ \o ->
    ResourceMonitoringAddressDetails
      <$> (o .:? "addressId")

-- | ToJSON ResourceMonitoringAddressDetails
instance A.ToJSON ResourceMonitoringAddressDetails where
  toJSON ResourceMonitoringAddressDetails {..} =
   _omitNulls
      [ "addressId" .= resourceMonitoringAddressDetailsAddressId
      ]


-- | Construct a value of type 'ResourceMonitoringAddressDetails' (by applying it's required fields, if any)
mkResourceMonitoringAddressDetails
  :: ResourceMonitoringAddressDetails
mkResourceMonitoringAddressDetails =
  ResourceMonitoringAddressDetails
  { resourceMonitoringAddressDetailsAddressId = Nothing
  }

-- ** ResourceMonitoringAddressSchema
-- | ResourceMonitoringAddressSchema
data ResourceMonitoringAddressSchema = ResourceMonitoringAddressSchema
  { resourceMonitoringAddressSchemaAddressMonitoringDetails :: !(Maybe ResourceMonitoringAddressDetails) -- ^ "addressMonitoringDetails"
  , resourceMonitoringAddressSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringAddressSchema
instance A.FromJSON ResourceMonitoringAddressSchema where
  parseJSON = A.withObject "ResourceMonitoringAddressSchema" $ \o ->
    ResourceMonitoringAddressSchema
      <$> (o .:? "addressMonitoringDetails")
      <*> (o .:? "resourceMonitoring")

-- | ToJSON ResourceMonitoringAddressSchema
instance A.ToJSON ResourceMonitoringAddressSchema where
  toJSON ResourceMonitoringAddressSchema {..} =
   _omitNulls
      [ "addressMonitoringDetails" .= resourceMonitoringAddressSchemaAddressMonitoringDetails
      , "resourceMonitoring" .= resourceMonitoringAddressSchemaResourceMonitoring
      ]


-- | Construct a value of type 'ResourceMonitoringAddressSchema' (by applying it's required fields, if any)
mkResourceMonitoringAddressSchema
  :: ResourceMonitoringAddressSchema
mkResourceMonitoringAddressSchema =
  ResourceMonitoringAddressSchema
  { resourceMonitoringAddressSchemaAddressMonitoringDetails = Nothing
  , resourceMonitoringAddressSchemaResourceMonitoring = Nothing
  }

-- ** ResourceMonitoringDetails
-- | ResourceMonitoringDetails
data ResourceMonitoringDetails = ResourceMonitoringDetails
  { resourceMonitoringDetailsResourceMonitoringId :: !(Maybe Text) -- ^ "resourceMonitoringId"
  , resourceMonitoringDetailsLocation :: !(Maybe Location) -- ^ "location"
  , resourceMonitoringDetailsType :: !(Maybe Text) -- ^ "type"
  , resourceMonitoringDetailsTimestamp :: !(Maybe Text) -- ^ "timestamp"
  , resourceMonitoringDetailsStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringDetails
instance A.FromJSON ResourceMonitoringDetails where
  parseJSON = A.withObject "ResourceMonitoringDetails" $ \o ->
    ResourceMonitoringDetails
      <$> (o .:? "resourceMonitoringId")
      <*> (o .:? "location")
      <*> (o .:? "type")
      <*> (o .:? "timestamp")
      <*> (o .:? "status")

-- | ToJSON ResourceMonitoringDetails
instance A.ToJSON ResourceMonitoringDetails where
  toJSON ResourceMonitoringDetails {..} =
   _omitNulls
      [ "resourceMonitoringId" .= resourceMonitoringDetailsResourceMonitoringId
      , "location" .= resourceMonitoringDetailsLocation
      , "type" .= resourceMonitoringDetailsType
      , "timestamp" .= resourceMonitoringDetailsTimestamp
      , "status" .= resourceMonitoringDetailsStatus
      ]


-- | Construct a value of type 'ResourceMonitoringDetails' (by applying it's required fields, if any)
mkResourceMonitoringDetails
  :: ResourceMonitoringDetails
mkResourceMonitoringDetails =
  ResourceMonitoringDetails
  { resourceMonitoringDetailsResourceMonitoringId = Nothing
  , resourceMonitoringDetailsLocation = Nothing
  , resourceMonitoringDetailsType = Nothing
  , resourceMonitoringDetailsTimestamp = Nothing
  , resourceMonitoringDetailsStatus = Nothing
  }

-- ** ResourceMonitoringSmartContractEventDetails
-- | ResourceMonitoringSmartContractEventDetails
data ResourceMonitoringSmartContractEventDetails = ResourceMonitoringSmartContractEventDetails
  { resourceMonitoringSmartContractEventDetailsEventName :: !(Maybe Text) -- ^ "eventName"
  , resourceMonitoringSmartContractEventDetailsEventParameters :: !(Maybe Text) -- ^ "eventParameters"
  , resourceMonitoringSmartContractEventDetailsSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringSmartContractEventDetails
instance A.FromJSON ResourceMonitoringSmartContractEventDetails where
  parseJSON = A.withObject "ResourceMonitoringSmartContractEventDetails" $ \o ->
    ResourceMonitoringSmartContractEventDetails
      <$> (o .:? "eventName")
      <*> (o .:? "eventParameters")
      <*> (o .:? "smartContractId")

-- | ToJSON ResourceMonitoringSmartContractEventDetails
instance A.ToJSON ResourceMonitoringSmartContractEventDetails where
  toJSON ResourceMonitoringSmartContractEventDetails {..} =
   _omitNulls
      [ "eventName" .= resourceMonitoringSmartContractEventDetailsEventName
      , "eventParameters" .= resourceMonitoringSmartContractEventDetailsEventParameters
      , "smartContractId" .= resourceMonitoringSmartContractEventDetailsSmartContractId
      ]


-- | Construct a value of type 'ResourceMonitoringSmartContractEventDetails' (by applying it's required fields, if any)
mkResourceMonitoringSmartContractEventDetails
  :: ResourceMonitoringSmartContractEventDetails
mkResourceMonitoringSmartContractEventDetails =
  ResourceMonitoringSmartContractEventDetails
  { resourceMonitoringSmartContractEventDetailsEventName = Nothing
  , resourceMonitoringSmartContractEventDetailsEventParameters = Nothing
  , resourceMonitoringSmartContractEventDetailsSmartContractId = Nothing
  }

-- ** ResourceMonitoringSubscription
-- | ResourceMonitoringSubscription
data ResourceMonitoringSubscription = ResourceMonitoringSubscription
  { resourceMonitoringSubscriptionSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  , resourceMonitoringSubscriptionType :: !(Maybe Text) -- ^ "type"
  , resourceMonitoringSubscriptionCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringSubscription
instance A.FromJSON ResourceMonitoringSubscription where
  parseJSON = A.withObject "ResourceMonitoringSubscription" $ \o ->
    ResourceMonitoringSubscription
      <$> (o .:? "subscriptionId")
      <*> (o .:? "type")
      <*> (o .:? "callbackUrl")

-- | ToJSON ResourceMonitoringSubscription
instance A.ToJSON ResourceMonitoringSubscription where
  toJSON ResourceMonitoringSubscription {..} =
   _omitNulls
      [ "subscriptionId" .= resourceMonitoringSubscriptionSubscriptionId
      , "type" .= resourceMonitoringSubscriptionType
      , "callbackUrl" .= resourceMonitoringSubscriptionCallbackUrl
      ]


-- | Construct a value of type 'ResourceMonitoringSubscription' (by applying it's required fields, if any)
mkResourceMonitoringSubscription
  :: ResourceMonitoringSubscription
mkResourceMonitoringSubscription =
  ResourceMonitoringSubscription
  { resourceMonitoringSubscriptionSubscriptionId = Nothing
  , resourceMonitoringSubscriptionType = Nothing
  , resourceMonitoringSubscriptionCallbackUrl = Nothing
  }

-- ** ResourceMonitoringSubscriptionDetails
-- | ResourceMonitoringSubscriptionDetails
data ResourceMonitoringSubscriptionDetails = ResourceMonitoringSubscriptionDetails
  { resourceMonitoringSubscriptionDetailsIds :: !(Maybe [Text]) -- ^ "ids"
  , resourceMonitoringSubscriptionDetailsStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResourceMonitoringSubscriptionDetails
instance A.FromJSON ResourceMonitoringSubscriptionDetails where
  parseJSON = A.withObject "ResourceMonitoringSubscriptionDetails" $ \o ->
    ResourceMonitoringSubscriptionDetails
      <$> (o .:? "ids")
      <*> (o .:? "status")

-- | ToJSON ResourceMonitoringSubscriptionDetails
instance A.ToJSON ResourceMonitoringSubscriptionDetails where
  toJSON ResourceMonitoringSubscriptionDetails {..} =
   _omitNulls
      [ "ids" .= resourceMonitoringSubscriptionDetailsIds
      , "status" .= resourceMonitoringSubscriptionDetailsStatus
      ]


-- | Construct a value of type 'ResourceMonitoringSubscriptionDetails' (by applying it's required fields, if any)
mkResourceMonitoringSubscriptionDetails
  :: ResourceMonitoringSubscriptionDetails
mkResourceMonitoringSubscriptionDetails =
  ResourceMonitoringSubscriptionDetails
  { resourceMonitoringSubscriptionDetailsIds = Nothing
  , resourceMonitoringSubscriptionDetailsStatus = Nothing
  }

-- ** ScriptPubKey
-- | ScriptPubKey
data ScriptPubKey = ScriptPubKey
  { scriptPubKeyAddresses :: !(Maybe [Text]) -- ^ "addresses"
  , scriptPubKeyAsm :: !(Maybe Text) -- ^ "asm"
  , scriptPubKeyHex :: !(Maybe Text) -- ^ "hex"
  , scriptPubKeyType :: !(Maybe Text) -- ^ "type"
  , scriptPubKeyReqSigs :: !(Maybe Text) -- ^ "reqSigs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ScriptPubKey
instance A.FromJSON ScriptPubKey where
  parseJSON = A.withObject "ScriptPubKey" $ \o ->
    ScriptPubKey
      <$> (o .:? "addresses")
      <*> (o .:? "asm")
      <*> (o .:? "hex")
      <*> (o .:? "type")
      <*> (o .:? "reqSigs")

-- | ToJSON ScriptPubKey
instance A.ToJSON ScriptPubKey where
  toJSON ScriptPubKey {..} =
   _omitNulls
      [ "addresses" .= scriptPubKeyAddresses
      , "asm" .= scriptPubKeyAsm
      , "hex" .= scriptPubKeyHex
      , "type" .= scriptPubKeyType
      , "reqSigs" .= scriptPubKeyReqSigs
      ]


-- | Construct a value of type 'ScriptPubKey' (by applying it's required fields, if any)
mkScriptPubKey
  :: ScriptPubKey
mkScriptPubKey =
  ScriptPubKey
  { scriptPubKeyAddresses = Nothing
  , scriptPubKeyAsm = Nothing
  , scriptPubKeyHex = Nothing
  , scriptPubKeyType = Nothing
  , scriptPubKeyReqSigs = Nothing
  }

-- ** SecondaryAccountAdditionalOwnerSchema
-- | SecondaryAccountAdditionalOwnerSchema
data SecondaryAccountAdditionalOwnerSchema = SecondaryAccountAdditionalOwnerSchema
  { secondaryAccountAdditionalOwnerSchemaAccountId :: !(Maybe Text) -- ^ "accountId" - Unique Identifier of the owner
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecondaryAccountAdditionalOwnerSchema
instance A.FromJSON SecondaryAccountAdditionalOwnerSchema where
  parseJSON = A.withObject "SecondaryAccountAdditionalOwnerSchema" $ \o ->
    SecondaryAccountAdditionalOwnerSchema
      <$> (o .:? "accountId")

-- | ToJSON SecondaryAccountAdditionalOwnerSchema
instance A.ToJSON SecondaryAccountAdditionalOwnerSchema where
  toJSON SecondaryAccountAdditionalOwnerSchema {..} =
   _omitNulls
      [ "accountId" .= secondaryAccountAdditionalOwnerSchemaAccountId
      ]


-- | Construct a value of type 'SecondaryAccountAdditionalOwnerSchema' (by applying it's required fields, if any)
mkSecondaryAccountAdditionalOwnerSchema
  :: SecondaryAccountAdditionalOwnerSchema
mkSecondaryAccountAdditionalOwnerSchema =
  SecondaryAccountAdditionalOwnerSchema
  { secondaryAccountAdditionalOwnerSchemaAccountId = Nothing
  }

-- ** SecondaryAccountOwnerSchema
-- | SecondaryAccountOwnerSchema
data SecondaryAccountOwnerSchema = SecondaryAccountOwnerSchema
  { secondaryAccountOwnerSchemaAccountId :: !(Maybe Text) -- ^ "accountId" - Unique Identifier of the owner
  , secondaryAccountOwnerSchemaUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SecondaryAccountOwnerSchema
instance A.FromJSON SecondaryAccountOwnerSchema where
  parseJSON = A.withObject "SecondaryAccountOwnerSchema" $ \o ->
    SecondaryAccountOwnerSchema
      <$> (o .:? "accountId")
      <*> (o .:? "unit")

-- | ToJSON SecondaryAccountOwnerSchema
instance A.ToJSON SecondaryAccountOwnerSchema where
  toJSON SecondaryAccountOwnerSchema {..} =
   _omitNulls
      [ "accountId" .= secondaryAccountOwnerSchemaAccountId
      , "unit" .= secondaryAccountOwnerSchemaUnit
      ]


-- | Construct a value of type 'SecondaryAccountOwnerSchema' (by applying it's required fields, if any)
mkSecondaryAccountOwnerSchema
  :: SecondaryAccountOwnerSchema
mkSecondaryAccountOwnerSchema =
  SecondaryAccountOwnerSchema
  { secondaryAccountOwnerSchemaAccountId = Nothing
  , secondaryAccountOwnerSchemaUnit = Nothing
  }

-- ** Sender
-- | Sender
-- Where is this transaction coming from.
data Sender = Sender
  { senderAccountId :: !(Maybe Text) -- ^ "accountId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Sender
instance A.FromJSON Sender where
  parseJSON = A.withObject "Sender" $ \o ->
    Sender
      <$> (o .:? "accountId")

-- | ToJSON Sender
instance A.ToJSON Sender where
  toJSON Sender {..} =
   _omitNulls
      [ "accountId" .= senderAccountId
      ]


-- | Construct a value of type 'Sender' (by applying it's required fields, if any)
mkSender
  :: Sender
mkSender =
  Sender
  { senderAccountId = Nothing
  }

-- ** SignerAccount
-- | SignerAccount
data SignerAccount = SignerAccount
  { signerAccountAccountId :: !(Maybe Text) -- ^ "accountId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SignerAccount
instance A.FromJSON SignerAccount where
  parseJSON = A.withObject "SignerAccount" $ \o ->
    SignerAccount
      <$> (o .:? "accountId")

-- | ToJSON SignerAccount
instance A.ToJSON SignerAccount where
  toJSON SignerAccount {..} =
   _omitNulls
      [ "accountId" .= signerAccountAccountId
      ]


-- | Construct a value of type 'SignerAccount' (by applying it's required fields, if any)
mkSignerAccount
  :: SignerAccount
mkSignerAccount =
  SignerAccount
  { signerAccountAccountId = Nothing
  }

-- ** SmartContract
-- | SmartContract
-- Computer program storage in a DLT system where the outcome is recorded on the distributed ledger
data SmartContract = SmartContract
  { smartContractDetail :: !(Maybe Text) -- ^ "detail"
  , smartContractType :: !(Maybe Text) -- ^ "type" - Information on the object type
  , smartContractSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  , smartContractFunction :: !(Maybe Function) -- ^ "function"
  , smartContractExtraFields :: !(Maybe A.Value) -- ^ "extraFields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContract
instance A.FromJSON SmartContract where
  parseJSON = A.withObject "SmartContract" $ \o ->
    SmartContract
      <$> (o .:? "detail")
      <*> (o .:? "type")
      <*> (o .:? "smartContractId")
      <*> (o .:? "function")
      <*> (o .:? "extraFields")

-- | ToJSON SmartContract
instance A.ToJSON SmartContract where
  toJSON SmartContract {..} =
   _omitNulls
      [ "detail" .= smartContractDetail
      , "type" .= smartContractType
      , "smartContractId" .= smartContractSmartContractId
      , "function" .= smartContractFunction
      , "extraFields" .= smartContractExtraFields
      ]


-- | Construct a value of type 'SmartContract' (by applying it's required fields, if any)
mkSmartContract
  :: SmartContract
mkSmartContract =
  SmartContract
  { smartContractDetail = Nothing
  , smartContractType = Nothing
  , smartContractSmartContractId = Nothing
  , smartContractFunction = Nothing
  , smartContractExtraFields = Nothing
  }

-- ** SmartContractDestinationSchema
-- | SmartContractDestinationSchema
data SmartContractDestinationSchema = SmartContractDestinationSchema
  { smartContractDestinationSchemaDestinationId :: !(Maybe Text) -- ^ "destinationId"
  , smartContractDestinationSchemaSmartContract :: !(Maybe SmartContractSchema) -- ^ "smartContract"
  , smartContractDestinationSchemaPayment :: !(Maybe SmartContractPaymentSchema) -- ^ "payment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractDestinationSchema
instance A.FromJSON SmartContractDestinationSchema where
  parseJSON = A.withObject "SmartContractDestinationSchema" $ \o ->
    SmartContractDestinationSchema
      <$> (o .:? "destinationId")
      <*> (o .:? "smartContract")
      <*> (o .:? "payment")

-- | ToJSON SmartContractDestinationSchema
instance A.ToJSON SmartContractDestinationSchema where
  toJSON SmartContractDestinationSchema {..} =
   _omitNulls
      [ "destinationId" .= smartContractDestinationSchemaDestinationId
      , "smartContract" .= smartContractDestinationSchemaSmartContract
      , "payment" .= smartContractDestinationSchemaPayment
      ]


-- | Construct a value of type 'SmartContractDestinationSchema' (by applying it's required fields, if any)
mkSmartContractDestinationSchema
  :: SmartContractDestinationSchema
mkSmartContractDestinationSchema =
  SmartContractDestinationSchema
  { smartContractDestinationSchemaDestinationId = Nothing
  , smartContractDestinationSchemaSmartContract = Nothing
  , smartContractDestinationSchemaPayment = Nothing
  }

-- ** SmartContractEventHistory
-- | SmartContractEventHistory
data SmartContractEventHistory = SmartContractEventHistory
  { smartContractEventHistoryEventId :: !(Maybe Text) -- ^ "eventId"
  , smartContractEventHistoryEventName :: !(Maybe Text) -- ^ "eventName"
  , smartContractEventHistoryEventParameters :: !(Maybe Text) -- ^ "eventParameters"
  , smartContractEventHistoryTransactionId :: !(Maybe Text) -- ^ "transactionId"
  , smartContractEventHistoryTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractEventHistory
instance A.FromJSON SmartContractEventHistory where
  parseJSON = A.withObject "SmartContractEventHistory" $ \o ->
    SmartContractEventHistory
      <$> (o .:? "eventId")
      <*> (o .:? "eventName")
      <*> (o .:? "eventParameters")
      <*> (o .:? "transactionId")
      <*> (o .:? "timestamp")

-- | ToJSON SmartContractEventHistory
instance A.ToJSON SmartContractEventHistory where
  toJSON SmartContractEventHistory {..} =
   _omitNulls
      [ "eventId" .= smartContractEventHistoryEventId
      , "eventName" .= smartContractEventHistoryEventName
      , "eventParameters" .= smartContractEventHistoryEventParameters
      , "transactionId" .= smartContractEventHistoryTransactionId
      , "timestamp" .= smartContractEventHistoryTimestamp
      ]


-- | Construct a value of type 'SmartContractEventHistory' (by applying it's required fields, if any)
mkSmartContractEventHistory
  :: SmartContractEventHistory
mkSmartContractEventHistory =
  SmartContractEventHistory
  { smartContractEventHistoryEventId = Nothing
  , smartContractEventHistoryEventName = Nothing
  , smartContractEventHistoryEventParameters = Nothing
  , smartContractEventHistoryTransactionId = Nothing
  , smartContractEventHistoryTimestamp = Nothing
  }

-- ** SmartContractFunctionSchema
-- | SmartContractFunctionSchema
data SmartContractFunctionSchema = SmartContractFunctionSchema
  { smartContractFunctionSchemaName :: !(Maybe Text) -- ^ "name"
  , smartContractFunctionSchemaInputParameters :: !(Maybe [SmartContractInputParameterSchema]) -- ^ "inputParameters"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractFunctionSchema
instance A.FromJSON SmartContractFunctionSchema where
  parseJSON = A.withObject "SmartContractFunctionSchema" $ \o ->
    SmartContractFunctionSchema
      <$> (o .:? "name")
      <*> (o .:? "inputParameters")

-- | ToJSON SmartContractFunctionSchema
instance A.ToJSON SmartContractFunctionSchema where
  toJSON SmartContractFunctionSchema {..} =
   _omitNulls
      [ "name" .= smartContractFunctionSchemaName
      , "inputParameters" .= smartContractFunctionSchemaInputParameters
      ]


-- | Construct a value of type 'SmartContractFunctionSchema' (by applying it's required fields, if any)
mkSmartContractFunctionSchema
  :: SmartContractFunctionSchema
mkSmartContractFunctionSchema =
  SmartContractFunctionSchema
  { smartContractFunctionSchemaName = Nothing
  , smartContractFunctionSchemaInputParameters = Nothing
  }

-- ** SmartContractInputParameterSchema
-- | SmartContractInputParameterSchema
data SmartContractInputParameterSchema = SmartContractInputParameterSchema
  { smartContractInputParameterSchemaType :: !(Maybe Text) -- ^ "type"
  , smartContractInputParameterSchemaValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractInputParameterSchema
instance A.FromJSON SmartContractInputParameterSchema where
  parseJSON = A.withObject "SmartContractInputParameterSchema" $ \o ->
    SmartContractInputParameterSchema
      <$> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON SmartContractInputParameterSchema
instance A.ToJSON SmartContractInputParameterSchema where
  toJSON SmartContractInputParameterSchema {..} =
   _omitNulls
      [ "type" .= smartContractInputParameterSchemaType
      , "value" .= smartContractInputParameterSchemaValue
      ]


-- | Construct a value of type 'SmartContractInputParameterSchema' (by applying it's required fields, if any)
mkSmartContractInputParameterSchema
  :: SmartContractInputParameterSchema
mkSmartContractInputParameterSchema =
  SmartContractInputParameterSchema
  { smartContractInputParameterSchemaType = Nothing
  , smartContractInputParameterSchemaValue = Nothing
  }

-- ** SmartContractInvokeRequestDetailsSchema
-- | SmartContractInvokeRequestDetailsSchema
data SmartContractInvokeRequestDetailsSchema = SmartContractInvokeRequestDetailsSchema
  { smartContractInvokeRequestDetailsSchemaDestination :: !(Maybe [SmartContractDestinationSchema]) -- ^ "destination"
  , smartContractInvokeRequestDetailsSchemaOrigin :: !(Maybe [SmartContractRequestDetailsOrigin]) -- ^ "origin"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractInvokeRequestDetailsSchema
instance A.FromJSON SmartContractInvokeRequestDetailsSchema where
  parseJSON = A.withObject "SmartContractInvokeRequestDetailsSchema" $ \o ->
    SmartContractInvokeRequestDetailsSchema
      <$> (o .:? "destination")
      <*> (o .:? "origin")

-- | ToJSON SmartContractInvokeRequestDetailsSchema
instance A.ToJSON SmartContractInvokeRequestDetailsSchema where
  toJSON SmartContractInvokeRequestDetailsSchema {..} =
   _omitNulls
      [ "destination" .= smartContractInvokeRequestDetailsSchemaDestination
      , "origin" .= smartContractInvokeRequestDetailsSchemaOrigin
      ]


-- | Construct a value of type 'SmartContractInvokeRequestDetailsSchema' (by applying it's required fields, if any)
mkSmartContractInvokeRequestDetailsSchema
  :: SmartContractInvokeRequestDetailsSchema
mkSmartContractInvokeRequestDetailsSchema =
  SmartContractInvokeRequestDetailsSchema
  { smartContractInvokeRequestDetailsSchemaDestination = Nothing
  , smartContractInvokeRequestDetailsSchemaOrigin = Nothing
  }

-- ** SmartContractMonitoringDetailsSchema
-- | SmartContractMonitoringDetailsSchema
data SmartContractMonitoringDetailsSchema = SmartContractMonitoringDetailsSchema
  { smartContractMonitoringDetailsSchemaSmartContractEventDetails :: !(Maybe ResourceMonitoringSmartContractEventDetails) -- ^ "smartContractEventDetails"
  , smartContractMonitoringDetailsSchemaLocation :: !(Maybe Location) -- ^ "location"
  , smartContractMonitoringDetailsSchemaSmartContractEventHistory :: !(Maybe [SmartContractEventHistory]) -- ^ "smartContractEventHistory"
  , smartContractMonitoringDetailsSchemaType :: !(Maybe Text) -- ^ "type"
  , smartContractMonitoringDetailsSchemaStatus :: !(Maybe Status) -- ^ "status"
  , smartContractMonitoringDetailsSchemaTimestamp :: !(Maybe Text) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractMonitoringDetailsSchema
instance A.FromJSON SmartContractMonitoringDetailsSchema where
  parseJSON = A.withObject "SmartContractMonitoringDetailsSchema" $ \o ->
    SmartContractMonitoringDetailsSchema
      <$> (o .:? "smartContractEventDetails")
      <*> (o .:? "location")
      <*> (o .:? "smartContractEventHistory")
      <*> (o .:? "type")
      <*> (o .:? "status")
      <*> (o .:? "timestamp")

-- | ToJSON SmartContractMonitoringDetailsSchema
instance A.ToJSON SmartContractMonitoringDetailsSchema where
  toJSON SmartContractMonitoringDetailsSchema {..} =
   _omitNulls
      [ "smartContractEventDetails" .= smartContractMonitoringDetailsSchemaSmartContractEventDetails
      , "location" .= smartContractMonitoringDetailsSchemaLocation
      , "smartContractEventHistory" .= smartContractMonitoringDetailsSchemaSmartContractEventHistory
      , "type" .= smartContractMonitoringDetailsSchemaType
      , "status" .= smartContractMonitoringDetailsSchemaStatus
      , "timestamp" .= smartContractMonitoringDetailsSchemaTimestamp
      ]


-- | Construct a value of type 'SmartContractMonitoringDetailsSchema' (by applying it's required fields, if any)
mkSmartContractMonitoringDetailsSchema
  :: SmartContractMonitoringDetailsSchema
mkSmartContractMonitoringDetailsSchema =
  SmartContractMonitoringDetailsSchema
  { smartContractMonitoringDetailsSchemaSmartContractEventDetails = Nothing
  , smartContractMonitoringDetailsSchemaLocation = Nothing
  , smartContractMonitoringDetailsSchemaSmartContractEventHistory = Nothing
  , smartContractMonitoringDetailsSchemaType = Nothing
  , smartContractMonitoringDetailsSchemaStatus = Nothing
  , smartContractMonitoringDetailsSchemaTimestamp = Nothing
  }

-- ** SmartContractMonitoringSchema
-- | SmartContractMonitoringSchema
data SmartContractMonitoringSchema = SmartContractMonitoringSchema
  { smartContractMonitoringSchemaSmartContractEventMonitoringDetails :: !(Maybe ResourceMonitoringSmartContractEventDetails) -- ^ "smartContractEventMonitoringDetails"
  , smartContractMonitoringSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractMonitoringSchema
instance A.FromJSON SmartContractMonitoringSchema where
  parseJSON = A.withObject "SmartContractMonitoringSchema" $ \o ->
    SmartContractMonitoringSchema
      <$> (o .:? "smartContractEventMonitoringDetails")
      <*> (o .:? "resourceMonitoring")

-- | ToJSON SmartContractMonitoringSchema
instance A.ToJSON SmartContractMonitoringSchema where
  toJSON SmartContractMonitoringSchema {..} =
   _omitNulls
      [ "smartContractEventMonitoringDetails" .= smartContractMonitoringSchemaSmartContractEventMonitoringDetails
      , "resourceMonitoring" .= smartContractMonitoringSchemaResourceMonitoring
      ]


-- | Construct a value of type 'SmartContractMonitoringSchema' (by applying it's required fields, if any)
mkSmartContractMonitoringSchema
  :: SmartContractMonitoringSchema
mkSmartContractMonitoringSchema =
  SmartContractMonitoringSchema
  { smartContractMonitoringSchemaSmartContractEventMonitoringDetails = Nothing
  , smartContractMonitoringSchemaResourceMonitoring = Nothing
  }

-- ** SmartContractOutputParameterSchema
-- | SmartContractOutputParameterSchema
data SmartContractOutputParameterSchema = SmartContractOutputParameterSchema
  { smartContractOutputParameterSchemaType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractOutputParameterSchema
instance A.FromJSON SmartContractOutputParameterSchema where
  parseJSON = A.withObject "SmartContractOutputParameterSchema" $ \o ->
    SmartContractOutputParameterSchema
      <$> (o .:? "type")

-- | ToJSON SmartContractOutputParameterSchema
instance A.ToJSON SmartContractOutputParameterSchema where
  toJSON SmartContractOutputParameterSchema {..} =
   _omitNulls
      [ "type" .= smartContractOutputParameterSchemaType
      ]


-- | Construct a value of type 'SmartContractOutputParameterSchema' (by applying it's required fields, if any)
mkSmartContractOutputParameterSchema
  :: SmartContractOutputParameterSchema
mkSmartContractOutputParameterSchema =
  SmartContractOutputParameterSchema
  { smartContractOutputParameterSchemaType = Nothing
  }

-- ** SmartContractPaymentSchema
-- | SmartContractPaymentSchema
data SmartContractPaymentSchema = SmartContractPaymentSchema
  { smartContractPaymentSchemaAmount :: !(Maybe Text) -- ^ "amount"
  , smartContractPaymentSchemaUnit :: !(Maybe Text) -- ^ "unit"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractPaymentSchema
instance A.FromJSON SmartContractPaymentSchema where
  parseJSON = A.withObject "SmartContractPaymentSchema" $ \o ->
    SmartContractPaymentSchema
      <$> (o .:? "amount")
      <*> (o .:? "unit")

-- | ToJSON SmartContractPaymentSchema
instance A.ToJSON SmartContractPaymentSchema where
  toJSON SmartContractPaymentSchema {..} =
   _omitNulls
      [ "amount" .= smartContractPaymentSchemaAmount
      , "unit" .= smartContractPaymentSchemaUnit
      ]


-- | Construct a value of type 'SmartContractPaymentSchema' (by applying it's required fields, if any)
mkSmartContractPaymentSchema
  :: SmartContractPaymentSchema
mkSmartContractPaymentSchema =
  SmartContractPaymentSchema
  { smartContractPaymentSchemaAmount = Nothing
  , smartContractPaymentSchemaUnit = Nothing
  }

-- ** SmartContractReadFunctionSchema
-- | SmartContractReadFunctionSchema
data SmartContractReadFunctionSchema = SmartContractReadFunctionSchema
  { smartContractReadFunctionSchemaName :: !(Maybe Text) -- ^ "name"
  , smartContractReadFunctionSchemaFunctionId :: !(Maybe Text) -- ^ "functionId"
  , smartContractReadFunctionSchemaInputParameters :: !(Maybe [SmartContractInputParameterSchema]) -- ^ "inputParameters"
  , smartContractReadFunctionSchemaOutputParameters :: !(Maybe [SmartContractInputParameterSchema]) -- ^ "outputParameters"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractReadFunctionSchema
instance A.FromJSON SmartContractReadFunctionSchema where
  parseJSON = A.withObject "SmartContractReadFunctionSchema" $ \o ->
    SmartContractReadFunctionSchema
      <$> (o .:? "name")
      <*> (o .:? "functionId")
      <*> (o .:? "inputParameters")
      <*> (o .:? "outputParameters")

-- | ToJSON SmartContractReadFunctionSchema
instance A.ToJSON SmartContractReadFunctionSchema where
  toJSON SmartContractReadFunctionSchema {..} =
   _omitNulls
      [ "name" .= smartContractReadFunctionSchemaName
      , "functionId" .= smartContractReadFunctionSchemaFunctionId
      , "inputParameters" .= smartContractReadFunctionSchemaInputParameters
      , "outputParameters" .= smartContractReadFunctionSchemaOutputParameters
      ]


-- | Construct a value of type 'SmartContractReadFunctionSchema' (by applying it's required fields, if any)
mkSmartContractReadFunctionSchema
  :: SmartContractReadFunctionSchema
mkSmartContractReadFunctionSchema =
  SmartContractReadFunctionSchema
  { smartContractReadFunctionSchemaName = Nothing
  , smartContractReadFunctionSchemaFunctionId = Nothing
  , smartContractReadFunctionSchemaInputParameters = Nothing
  , smartContractReadFunctionSchemaOutputParameters = Nothing
  }

-- ** SmartContractReadSchema
-- | SmartContractReadSchema
-- Computer program storage in a DLT system where the outcome is recorded on the distributed ledger
data SmartContractReadSchema = SmartContractReadSchema
  { smartContractReadSchemaSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  , smartContractReadSchemaFunction :: !(Maybe SmartContractReadFunctionSchema) -- ^ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractReadSchema
instance A.FromJSON SmartContractReadSchema where
  parseJSON = A.withObject "SmartContractReadSchema" $ \o ->
    SmartContractReadSchema
      <$> (o .:? "smartContractId")
      <*> (o .:? "function")

-- | ToJSON SmartContractReadSchema
instance A.ToJSON SmartContractReadSchema where
  toJSON SmartContractReadSchema {..} =
   _omitNulls
      [ "smartContractId" .= smartContractReadSchemaSmartContractId
      , "function" .= smartContractReadSchemaFunction
      ]


-- | Construct a value of type 'SmartContractReadSchema' (by applying it's required fields, if any)
mkSmartContractReadSchema
  :: SmartContractReadSchema
mkSmartContractReadSchema =
  SmartContractReadSchema
  { smartContractReadSchemaSmartContractId = Nothing
  , smartContractReadSchemaFunction = Nothing
  }

-- ** SmartContractRequestDetailsOrigin
-- | SmartContractRequestDetailsOrigin
data SmartContractRequestDetailsOrigin = SmartContractRequestDetailsOrigin
  { smartContractRequestDetailsOriginOriginId :: !(Maybe Text) -- ^ "originId"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractRequestDetailsOrigin
instance A.FromJSON SmartContractRequestDetailsOrigin where
  parseJSON = A.withObject "SmartContractRequestDetailsOrigin" $ \o ->
    SmartContractRequestDetailsOrigin
      <$> (o .:? "originId")

-- | ToJSON SmartContractRequestDetailsOrigin
instance A.ToJSON SmartContractRequestDetailsOrigin where
  toJSON SmartContractRequestDetailsOrigin {..} =
   _omitNulls
      [ "originId" .= smartContractRequestDetailsOriginOriginId
      ]


-- | Construct a value of type 'SmartContractRequestDetailsOrigin' (by applying it's required fields, if any)
mkSmartContractRequestDetailsOrigin
  :: SmartContractRequestDetailsOrigin
mkSmartContractRequestDetailsOrigin =
  SmartContractRequestDetailsOrigin
  { smartContractRequestDetailsOriginOriginId = Nothing
  }

-- ** SmartContractSchema
-- | SmartContractSchema
data SmartContractSchema = SmartContractSchema
  { smartContractSchemaFunction :: !(Maybe SmartContractFunctionSchema) -- ^ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSchema
instance A.FromJSON SmartContractSchema where
  parseJSON = A.withObject "SmartContractSchema" $ \o ->
    SmartContractSchema
      <$> (o .:? "function")

-- | ToJSON SmartContractSchema
instance A.ToJSON SmartContractSchema where
  toJSON SmartContractSchema {..} =
   _omitNulls
      [ "function" .= smartContractSchemaFunction
      ]


-- | Construct a value of type 'SmartContractSchema' (by applying it's required fields, if any)
mkSmartContractSchema
  :: SmartContractSchema
mkSmartContractSchema =
  SmartContractSchema
  { smartContractSchemaFunction = Nothing
  }

-- ** SmartContractSearchDestinationSchema
-- | SmartContractSearchDestinationSchema
data SmartContractSearchDestinationSchema = SmartContractSearchDestinationSchema
  { smartContractSearchDestinationSchemaSmartContract :: !(Maybe SmartContractSearchSchema) -- ^ "smartContract"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSearchDestinationSchema
instance A.FromJSON SmartContractSearchDestinationSchema where
  parseJSON = A.withObject "SmartContractSearchDestinationSchema" $ \o ->
    SmartContractSearchDestinationSchema
      <$> (o .:? "smartContract")

-- | ToJSON SmartContractSearchDestinationSchema
instance A.ToJSON SmartContractSearchDestinationSchema where
  toJSON SmartContractSearchDestinationSchema {..} =
   _omitNulls
      [ "smartContract" .= smartContractSearchDestinationSchemaSmartContract
      ]


-- | Construct a value of type 'SmartContractSearchDestinationSchema' (by applying it's required fields, if any)
mkSmartContractSearchDestinationSchema
  :: SmartContractSearchDestinationSchema
mkSmartContractSearchDestinationSchema =
  SmartContractSearchDestinationSchema
  { smartContractSearchDestinationSchemaSmartContract = Nothing
  }

-- ** SmartContractSearchFunctionSchema
-- | SmartContractSearchFunctionSchema
data SmartContractSearchFunctionSchema = SmartContractSearchFunctionSchema
  { smartContractSearchFunctionSchemaName :: !(Maybe Text) -- ^ "name"
  , smartContractSearchFunctionSchemaInputParameters :: !(Maybe [SmartContractInputParameterSchema]) -- ^ "inputParameters"
  , smartContractSearchFunctionSchemaOutputParameters :: !(Maybe [SmartContractOutputParameterSchema]) -- ^ "outputParameters"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSearchFunctionSchema
instance A.FromJSON SmartContractSearchFunctionSchema where
  parseJSON = A.withObject "SmartContractSearchFunctionSchema" $ \o ->
    SmartContractSearchFunctionSchema
      <$> (o .:? "name")
      <*> (o .:? "inputParameters")
      <*> (o .:? "outputParameters")

-- | ToJSON SmartContractSearchFunctionSchema
instance A.ToJSON SmartContractSearchFunctionSchema where
  toJSON SmartContractSearchFunctionSchema {..} =
   _omitNulls
      [ "name" .= smartContractSearchFunctionSchemaName
      , "inputParameters" .= smartContractSearchFunctionSchemaInputParameters
      , "outputParameters" .= smartContractSearchFunctionSchemaOutputParameters
      ]


-- | Construct a value of type 'SmartContractSearchFunctionSchema' (by applying it's required fields, if any)
mkSmartContractSearchFunctionSchema
  :: SmartContractSearchFunctionSchema
mkSmartContractSearchFunctionSchema =
  SmartContractSearchFunctionSchema
  { smartContractSearchFunctionSchemaName = Nothing
  , smartContractSearchFunctionSchemaInputParameters = Nothing
  , smartContractSearchFunctionSchemaOutputParameters = Nothing
  }

-- ** SmartContractSearchRequestDetails
-- | SmartContractSearchRequestDetails
data SmartContractSearchRequestDetails = SmartContractSearchRequestDetails
  { smartContractSearchRequestDetailsDestination :: !(Maybe [SmartContractSearchDestinationSchema]) -- ^ "destination"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSearchRequestDetails
instance A.FromJSON SmartContractSearchRequestDetails where
  parseJSON = A.withObject "SmartContractSearchRequestDetails" $ \o ->
    SmartContractSearchRequestDetails
      <$> (o .:? "destination")

-- | ToJSON SmartContractSearchRequestDetails
instance A.ToJSON SmartContractSearchRequestDetails where
  toJSON SmartContractSearchRequestDetails {..} =
   _omitNulls
      [ "destination" .= smartContractSearchRequestDetailsDestination
      ]


-- | Construct a value of type 'SmartContractSearchRequestDetails' (by applying it's required fields, if any)
mkSmartContractSearchRequestDetails
  :: SmartContractSearchRequestDetails
mkSmartContractSearchRequestDetails =
  SmartContractSearchRequestDetails
  { smartContractSearchRequestDetailsDestination = Nothing
  }

-- ** SmartContractSearchSchema
-- | SmartContractSearchSchema
data SmartContractSearchSchema = SmartContractSearchSchema
  { smartContractSearchSchemaSmartContractId :: !(Maybe Text) -- ^ "smartContractId"
  , smartContractSearchSchemaFunction :: !(Maybe SmartContractSearchFunctionSchema) -- ^ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractSearchSchema
instance A.FromJSON SmartContractSearchSchema where
  parseJSON = A.withObject "SmartContractSearchSchema" $ \o ->
    SmartContractSearchSchema
      <$> (o .:? "smartContractId")
      <*> (o .:? "function")

-- | ToJSON SmartContractSearchSchema
instance A.ToJSON SmartContractSearchSchema where
  toJSON SmartContractSearchSchema {..} =
   _omitNulls
      [ "smartContractId" .= smartContractSearchSchemaSmartContractId
      , "function" .= smartContractSearchSchemaFunction
      ]


-- | Construct a value of type 'SmartContractSearchSchema' (by applying it's required fields, if any)
mkSmartContractSearchSchema
  :: SmartContractSearchSchema
mkSmartContractSearchSchema =
  SmartContractSearchSchema
  { smartContractSearchSchemaSmartContractId = Nothing
  , smartContractSearchSchemaFunction = Nothing
  }

-- ** SmartContractTag
-- | SmartContractTag
data SmartContractTag = SmartContractTag
  { smartContractTagName :: !(Maybe Text) -- ^ "name"
  , smartContractTagFunctionName :: !(Maybe Text) -- ^ "functionName"
  , smartContractTagEventName :: !(Maybe Text) -- ^ "eventName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SmartContractTag
instance A.FromJSON SmartContractTag where
  parseJSON = A.withObject "SmartContractTag" $ \o ->
    SmartContractTag
      <$> (o .:? "name")
      <*> (o .:? "functionName")
      <*> (o .:? "eventName")

-- | ToJSON SmartContractTag
instance A.ToJSON SmartContractTag where
  toJSON SmartContractTag {..} =
   _omitNulls
      [ "name" .= smartContractTagName
      , "functionName" .= smartContractTagFunctionName
      , "eventName" .= smartContractTagEventName
      ]


-- | Construct a value of type 'SmartContractTag' (by applying it's required fields, if any)
mkSmartContractTag
  :: SmartContractTag
mkSmartContractTag =
  SmartContractTag
  { smartContractTagName = Nothing
  , smartContractTagFunctionName = Nothing
  , smartContractTagEventName = Nothing
  }

-- ** Status
-- | Status
data Status = Status
  { statusDescription :: !(Maybe Text) -- ^ "description" - The description of an object
  , statusCode :: !(Maybe Text) -- ^ "code" - The code of an object
  , statusMessage :: !(Maybe Text) -- ^ "message" - The message of an object
  , statusValue :: !(Maybe Text) -- ^ "value" - The value of an object
  , statusTimestamp :: !(Maybe Text) -- ^ "timestamp"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Status
instance A.FromJSON Status where
  parseJSON = A.withObject "Status" $ \o ->
    Status
      <$> (o .:? "description")
      <*> (o .:? "code")
      <*> (o .:? "message")
      <*> (o .:? "value")
      <*> (o .:? "timestamp")

-- | ToJSON Status
instance A.ToJSON Status where
  toJSON Status {..} =
   _omitNulls
      [ "description" .= statusDescription
      , "code" .= statusCode
      , "message" .= statusMessage
      , "value" .= statusValue
      , "timestamp" .= statusTimestamp
      ]


-- | Construct a value of type 'Status' (by applying it's required fields, if any)
mkStatus
  :: Status
mkStatus =
  Status
  { statusDescription = Nothing
  , statusCode = Nothing
  , statusMessage = Nothing
  , statusValue = Nothing
  , statusTimestamp = Nothing
  }

-- ** StatusUpdateMonitoringRequestSchema
-- | StatusUpdateMonitoringRequestSchema
data StatusUpdateMonitoringRequestSchema = StatusUpdateMonitoringRequestSchema
  { statusUpdateMonitoringRequestSchemaStatusUpdate :: !(Maybe StatusUpdateSchema) -- ^ "statusUpdate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StatusUpdateMonitoringRequestSchema
instance A.FromJSON StatusUpdateMonitoringRequestSchema where
  parseJSON = A.withObject "StatusUpdateMonitoringRequestSchema" $ \o ->
    StatusUpdateMonitoringRequestSchema
      <$> (o .:? "statusUpdate")

-- | ToJSON StatusUpdateMonitoringRequestSchema
instance A.ToJSON StatusUpdateMonitoringRequestSchema where
  toJSON StatusUpdateMonitoringRequestSchema {..} =
   _omitNulls
      [ "statusUpdate" .= statusUpdateMonitoringRequestSchemaStatusUpdate
      ]


-- | Construct a value of type 'StatusUpdateMonitoringRequestSchema' (by applying it's required fields, if any)
mkStatusUpdateMonitoringRequestSchema
  :: StatusUpdateMonitoringRequestSchema
mkStatusUpdateMonitoringRequestSchema =
  StatusUpdateMonitoringRequestSchema
  { statusUpdateMonitoringRequestSchemaStatusUpdate = Nothing
  }

-- ** StatusUpdateSchema
-- | StatusUpdateSchema
data StatusUpdateSchema = StatusUpdateSchema
  { statusUpdateSchemaValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StatusUpdateSchema
instance A.FromJSON StatusUpdateSchema where
  parseJSON = A.withObject "StatusUpdateSchema" $ \o ->
    StatusUpdateSchema
      <$> (o .:? "value")

-- | ToJSON StatusUpdateSchema
instance A.ToJSON StatusUpdateSchema where
  toJSON StatusUpdateSchema {..} =
   _omitNulls
      [ "value" .= statusUpdateSchemaValue
      ]


-- | Construct a value of type 'StatusUpdateSchema' (by applying it's required fields, if any)
mkStatusUpdateSchema
  :: StatusUpdateSchema
mkStatusUpdateSchema =
  StatusUpdateSchema
  { statusUpdateSchemaValue = Nothing
  }

-- ** TierFunctionDTO
-- | TierFunctionDTO
data TierFunctionDTO = TierFunctionDTO
  { tierFunctionDTOFunctionName :: !(Maybe Text) -- ^ "functionName"
  , tierFunctionDTOApi :: !(Maybe Text) -- ^ "api"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TierFunctionDTO
instance A.FromJSON TierFunctionDTO where
  parseJSON = A.withObject "TierFunctionDTO" $ \o ->
    TierFunctionDTO
      <$> (o .:? "functionName")
      <*> (o .:? "api")

-- | ToJSON TierFunctionDTO
instance A.ToJSON TierFunctionDTO where
  toJSON TierFunctionDTO {..} =
   _omitNulls
      [ "functionName" .= tierFunctionDTOFunctionName
      , "api" .= tierFunctionDTOApi
      ]


-- | Construct a value of type 'TierFunctionDTO' (by applying it's required fields, if any)
mkTierFunctionDTO
  :: TierFunctionDTO
mkTierFunctionDTO =
  TierFunctionDTO
  { tierFunctionDTOFunctionName = Nothing
  , tierFunctionDTOApi = Nothing
  }

-- ** TokenReadQRC20Response
-- | TokenReadQRC20Response
data TokenReadQRC20Response = TokenReadQRC20Response
  { tokenReadQRC20ResponseResponseDetails :: !(Maybe [TokenReadResponseDetails]) -- ^ "responseDetails"
  , tokenReadQRC20ResponseRequestId :: !(Maybe Text) -- ^ "requestId" - The ID assigned to a preparation request in Overledger
  , tokenReadQRC20ResponseLocation :: !(Maybe Location) -- ^ "location"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenReadQRC20Response
instance A.FromJSON TokenReadQRC20Response where
  parseJSON = A.withObject "TokenReadQRC20Response" $ \o ->
    TokenReadQRC20Response
      <$> (o .:? "responseDetails")
      <*> (o .:? "requestId")
      <*> (o .:? "location")

-- | ToJSON TokenReadQRC20Response
instance A.ToJSON TokenReadQRC20Response where
  toJSON TokenReadQRC20Response {..} =
   _omitNulls
      [ "responseDetails" .= tokenReadQRC20ResponseResponseDetails
      , "requestId" .= tokenReadQRC20ResponseRequestId
      , "location" .= tokenReadQRC20ResponseLocation
      ]


-- | Construct a value of type 'TokenReadQRC20Response' (by applying it's required fields, if any)
mkTokenReadQRC20Response
  :: TokenReadQRC20Response
mkTokenReadQRC20Response =
  TokenReadQRC20Response
  { tokenReadQRC20ResponseResponseDetails = Nothing
  , tokenReadQRC20ResponseRequestId = Nothing
  , tokenReadQRC20ResponseLocation = Nothing
  }

-- ** TokenReadQRC721Response
-- | TokenReadQRC721Response
data TokenReadQRC721Response = TokenReadQRC721Response
  { tokenReadQRC721ResponseTokenName :: !(Maybe Text) -- ^ "tokenName" - Name of the token
  , tokenReadQRC721ResponseResponseDetails :: !(Maybe TokenReadResponseDetails) -- ^ "responseDetails"
  , tokenReadQRC721ResponseLocation :: !(Maybe Location) -- ^ "location"
  , tokenReadQRC721ResponseRequestId :: !(Maybe Text) -- ^ "requestId" - The ID assigned to a preparation request in Overledger
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenReadQRC721Response
instance A.FromJSON TokenReadQRC721Response where
  parseJSON = A.withObject "TokenReadQRC721Response" $ \o ->
    TokenReadQRC721Response
      <$> (o .:? "tokenName")
      <*> (o .:? "responseDetails")
      <*> (o .:? "location")
      <*> (o .:? "requestId")

-- | ToJSON TokenReadQRC721Response
instance A.ToJSON TokenReadQRC721Response where
  toJSON TokenReadQRC721Response {..} =
   _omitNulls
      [ "tokenName" .= tokenReadQRC721ResponseTokenName
      , "responseDetails" .= tokenReadQRC721ResponseResponseDetails
      , "location" .= tokenReadQRC721ResponseLocation
      , "requestId" .= tokenReadQRC721ResponseRequestId
      ]


-- | Construct a value of type 'TokenReadQRC721Response' (by applying it's required fields, if any)
mkTokenReadQRC721Response
  :: TokenReadQRC721Response
mkTokenReadQRC721Response =
  TokenReadQRC721Response
  { tokenReadQRC721ResponseTokenName = Nothing
  , tokenReadQRC721ResponseResponseDetails = Nothing
  , tokenReadQRC721ResponseLocation = Nothing
  , tokenReadQRC721ResponseRequestId = Nothing
  }

-- ** TokenReadResponseDetails
-- | TokenReadResponseDetails
data TokenReadResponseDetails = TokenReadResponseDetails
  { tokenReadResponseDetailsName :: !(Maybe Text) -- ^ "name"
  , tokenReadResponseDetailsType :: !(Maybe Text) -- ^ "type"
  , tokenReadResponseDetailsValue :: !(Maybe A.Value) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TokenReadResponseDetails
instance A.FromJSON TokenReadResponseDetails where
  parseJSON = A.withObject "TokenReadResponseDetails" $ \o ->
    TokenReadResponseDetails
      <$> (o .:? "name")
      <*> (o .:? "type")
      <*> (o .:? "value")

-- | ToJSON TokenReadResponseDetails
instance A.ToJSON TokenReadResponseDetails where
  toJSON TokenReadResponseDetails {..} =
   _omitNulls
      [ "name" .= tokenReadResponseDetailsName
      , "type" .= tokenReadResponseDetailsType
      , "value" .= tokenReadResponseDetailsValue
      ]


-- | Construct a value of type 'TokenReadResponseDetails' (by applying it's required fields, if any)
mkTokenReadResponseDetails
  :: TokenReadResponseDetails
mkTokenReadResponseDetails =
  TokenReadResponseDetails
  { tokenReadResponseDetailsName = Nothing
  , tokenReadResponseDetailsType = Nothing
  , tokenReadResponseDetailsValue = Nothing
  }

-- ** Transaction
-- | Transaction
-- Smallest unit of a work process related to interactions with distributed ledgers
data Transaction = Transaction
  { transactionSignature :: !(Maybe [Text]) -- ^ "signature" - The signatures of this transaction
  , transactionOrigin :: !(Maybe [Origin]) -- ^ "origin"
  , transactionFee :: !(Maybe Fee) -- ^ "fee"
  , transactionDestination :: !(Maybe [Destination]) -- ^ "destination"
  , transactionSigned :: !(Maybe Text) -- ^ "signed"
  , transactionTotalPaymentAmount :: !(Maybe [Payment]) -- ^ "totalPaymentAmount"
  , transactionMessage :: !(Maybe Text) -- ^ "message" - Any text-based element of the data payload
  , transactionTransactionId :: !(Maybe Text) -- ^ "transactionId" - The unique identifier of the transaction on this DLN
  , transactionEncoded :: !(Maybe [Text]) -- ^ "encoded"
  , transactionExtraFields :: !(Maybe A.Value) -- ^ "extraFields"
  , transactionNativeData :: !(Maybe A.Value) -- ^ "nativeData"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Transaction
instance A.FromJSON Transaction where
  parseJSON = A.withObject "Transaction" $ \o ->
    Transaction
      <$> (o .:? "signature")
      <*> (o .:? "origin")
      <*> (o .:? "fee")
      <*> (o .:? "destination")
      <*> (o .:? "signed")
      <*> (o .:? "totalPaymentAmount")
      <*> (o .:? "message")
      <*> (o .:? "transactionId")
      <*> (o .:? "encoded")
      <*> (o .:? "extraFields")
      <*> (o .:? "nativeData")

-- | ToJSON Transaction
instance A.ToJSON Transaction where
  toJSON Transaction {..} =
   _omitNulls
      [ "signature" .= transactionSignature
      , "origin" .= transactionOrigin
      , "fee" .= transactionFee
      , "destination" .= transactionDestination
      , "signed" .= transactionSigned
      , "totalPaymentAmount" .= transactionTotalPaymentAmount
      , "message" .= transactionMessage
      , "transactionId" .= transactionTransactionId
      , "encoded" .= transactionEncoded
      , "extraFields" .= transactionExtraFields
      , "nativeData" .= transactionNativeData
      ]


-- | Construct a value of type 'Transaction' (by applying it's required fields, if any)
mkTransaction
  :: Transaction
mkTransaction =
  Transaction
  { transactionSignature = Nothing
  , transactionOrigin = Nothing
  , transactionFee = Nothing
  , transactionDestination = Nothing
  , transactionSigned = Nothing
  , transactionTotalPaymentAmount = Nothing
  , transactionMessage = Nothing
  , transactionTransactionId = Nothing
  , transactionEncoded = Nothing
  , transactionExtraFields = Nothing
  , transactionNativeData = Nothing
  }

-- ** Transfer
-- | Transfer
data Transfer = Transfer
  { transferTokenId :: !(Maybe Text) -- ^ "tokenId"
  , transferTokenName :: !(Maybe Text) -- ^ "tokenName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Transfer
instance A.FromJSON Transfer where
  parseJSON = A.withObject "Transfer" $ \o ->
    Transfer
      <$> (o .:? "tokenId")
      <*> (o .:? "tokenName")

-- | ToJSON Transfer
instance A.ToJSON Transfer where
  toJSON Transfer {..} =
   _omitNulls
      [ "tokenId" .= transferTokenId
      , "tokenName" .= transferTokenName
      ]


-- | Construct a value of type 'Transfer' (by applying it's required fields, if any)
mkTransfer
  :: Transfer
mkTransfer =
  Transfer
  { transferTokenId = Nothing
  , transferTokenName = Nothing
  }

-- ** TransferRequestDetailsSchema
-- | TransferRequestDetailsSchema
data TransferRequestDetailsSchema = TransferRequestDetailsSchema
  { transferRequestDetailsSchemaDestination :: !(Maybe [DestinationTransferSchema]) -- ^ "destination"
  , transferRequestDetailsSchemaMessage :: !(Maybe Text) -- ^ "message"
  , transferRequestDetailsSchemaOverledgerSigningType :: !(Maybe Text) -- ^ "overledgerSigningType"
  , transferRequestDetailsSchemaOrigin :: !(Maybe [OriginTransferSchema]) -- ^ "origin"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransferRequestDetailsSchema
instance A.FromJSON TransferRequestDetailsSchema where
  parseJSON = A.withObject "TransferRequestDetailsSchema" $ \o ->
    TransferRequestDetailsSchema
      <$> (o .:? "destination")
      <*> (o .:? "message")
      <*> (o .:? "overledgerSigningType")
      <*> (o .:? "origin")

-- | ToJSON TransferRequestDetailsSchema
instance A.ToJSON TransferRequestDetailsSchema where
  toJSON TransferRequestDetailsSchema {..} =
   _omitNulls
      [ "destination" .= transferRequestDetailsSchemaDestination
      , "message" .= transferRequestDetailsSchemaMessage
      , "overledgerSigningType" .= transferRequestDetailsSchemaOverledgerSigningType
      , "origin" .= transferRequestDetailsSchemaOrigin
      ]


-- | Construct a value of type 'TransferRequestDetailsSchema' (by applying it's required fields, if any)
mkTransferRequestDetailsSchema
  :: TransferRequestDetailsSchema
mkTransferRequestDetailsSchema =
  TransferRequestDetailsSchema
  { transferRequestDetailsSchemaDestination = Nothing
  , transferRequestDetailsSchemaMessage = Nothing
  , transferRequestDetailsSchemaOverledgerSigningType = Nothing
  , transferRequestDetailsSchemaOrigin = Nothing
  }

-- ** TransferSchema
-- | TransferSchema
data TransferSchema = TransferSchema
  { transferSchemaTokenId :: !(Maybe Text) -- ^ "tokenId"
  , transferSchemaTokenName :: !(Maybe Text) -- ^ "tokenName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TransferSchema
instance A.FromJSON TransferSchema where
  parseJSON = A.withObject "TransferSchema" $ \o ->
    TransferSchema
      <$> (o .:? "tokenId")
      <*> (o .:? "tokenName")

-- | ToJSON TransferSchema
instance A.ToJSON TransferSchema where
  toJSON TransferSchema {..} =
   _omitNulls
      [ "tokenId" .= transferSchemaTokenId
      , "tokenName" .= transferSchemaTokenName
      ]


-- | Construct a value of type 'TransferSchema' (by applying it's required fields, if any)
mkTransferSchema
  :: TransferSchema
mkTransferSchema =
  TransferSchema
  { transferSchemaTokenId = Nothing
  , transferSchemaTokenName = Nothing
  }

-- ** UTXODestination
-- | UTXODestination
data UTXODestination = UTXODestination
  { uTXODestinationDestinationId :: !(Maybe Text) -- ^ "destinationId"
  , uTXODestinationSmartContract :: !(Maybe UTXOSmartContract) -- ^ "smartContract"
  , uTXODestinationPayment :: !(Maybe Payment) -- ^ "payment"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UTXODestination
instance A.FromJSON UTXODestination where
  parseJSON = A.withObject "UTXODestination" $ \o ->
    UTXODestination
      <$> (o .:? "destinationId")
      <*> (o .:? "smartContract")
      <*> (o .:? "payment")

-- | ToJSON UTXODestination
instance A.ToJSON UTXODestination where
  toJSON UTXODestination {..} =
   _omitNulls
      [ "destinationId" .= uTXODestinationDestinationId
      , "smartContract" .= uTXODestinationSmartContract
      , "payment" .= uTXODestinationPayment
      ]


-- | Construct a value of type 'UTXODestination' (by applying it's required fields, if any)
mkUTXODestination
  :: UTXODestination
mkUTXODestination =
  UTXODestination
  { uTXODestinationDestinationId = Nothing
  , uTXODestinationSmartContract = Nothing
  , uTXODestinationPayment = Nothing
  }

-- ** UTXONativeData
-- | UTXONativeData
data UTXONativeData = UTXONativeData
  { uTXONativeDataVout :: !(Maybe [Vout]) -- ^ "vout"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UTXONativeData
instance A.FromJSON UTXONativeData where
  parseJSON = A.withObject "UTXONativeData" $ \o ->
    UTXONativeData
      <$> (o .:? "vout")

-- | ToJSON UTXONativeData
instance A.ToJSON UTXONativeData where
  toJSON UTXONativeData {..} =
   _omitNulls
      [ "vout" .= uTXONativeDataVout
      ]


-- | Construct a value of type 'UTXONativeData' (by applying it's required fields, if any)
mkUTXONativeData
  :: UTXONativeData
mkUTXONativeData =
  UTXONativeData
  { uTXONativeDataVout = Nothing
  }

-- ** UTXOSmartContract
-- | UTXOSmartContract
data UTXOSmartContract = UTXOSmartContract
  { uTXOSmartContractType :: !(Maybe Text) -- ^ "type"
  , uTXOSmartContractDetail :: !(Maybe Text) -- ^ "detail"
  , uTXOSmartContractExtraFields :: !(Maybe ExtraFields) -- ^ "extraFields"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UTXOSmartContract
instance A.FromJSON UTXOSmartContract where
  parseJSON = A.withObject "UTXOSmartContract" $ \o ->
    UTXOSmartContract
      <$> (o .:? "type")
      <*> (o .:? "detail")
      <*> (o .:? "extraFields")

-- | ToJSON UTXOSmartContract
instance A.ToJSON UTXOSmartContract where
  toJSON UTXOSmartContract {..} =
   _omitNulls
      [ "type" .= uTXOSmartContractType
      , "detail" .= uTXOSmartContractDetail
      , "extraFields" .= uTXOSmartContractExtraFields
      ]


-- | Construct a value of type 'UTXOSmartContract' (by applying it's required fields, if any)
mkUTXOSmartContract
  :: UTXOSmartContract
mkUTXOSmartContract =
  UTXOSmartContract
  { uTXOSmartContractType = Nothing
  , uTXOSmartContractDetail = Nothing
  , uTXOSmartContractExtraFields = Nothing
  }

-- ** UpdateAddressMonitoringSchema
-- | UpdateAddressMonitoringSchema
data UpdateAddressMonitoringSchema = UpdateAddressMonitoringSchema
  { updateAddressMonitoringSchemaAddressMonitoringDetails :: !(Maybe ResourceMonitoringAddressDetails) -- ^ "addressMonitoringDetails"
  , updateAddressMonitoringSchemaResourceMonitoring :: !(Maybe ResourceMonitoringDetails) -- ^ "resourceMonitoring"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateAddressMonitoringSchema
instance A.FromJSON UpdateAddressMonitoringSchema where
  parseJSON = A.withObject "UpdateAddressMonitoringSchema" $ \o ->
    UpdateAddressMonitoringSchema
      <$> (o .:? "addressMonitoringDetails")
      <*> (o .:? "resourceMonitoring")

-- | ToJSON UpdateAddressMonitoringSchema
instance A.ToJSON UpdateAddressMonitoringSchema where
  toJSON UpdateAddressMonitoringSchema {..} =
   _omitNulls
      [ "addressMonitoringDetails" .= updateAddressMonitoringSchemaAddressMonitoringDetails
      , "resourceMonitoring" .= updateAddressMonitoringSchemaResourceMonitoring
      ]


-- | Construct a value of type 'UpdateAddressMonitoringSchema' (by applying it's required fields, if any)
mkUpdateAddressMonitoringSchema
  :: UpdateAddressMonitoringSchema
mkUpdateAddressMonitoringSchema =
  UpdateAddressMonitoringSchema
  { updateAddressMonitoringSchemaAddressMonitoringDetails = Nothing
  , updateAddressMonitoringSchemaResourceMonitoring = Nothing
  }

-- ** UpdateWebhookSubscriptionRequestSchema
-- | UpdateWebhookSubscriptionRequestSchema
data UpdateWebhookSubscriptionRequestSchema = UpdateWebhookSubscriptionRequestSchema
  { updateWebhookSubscriptionRequestSchemaStatusUpdate :: !(Maybe WebhookStatusUpdateSchema) -- ^ "statusUpdate"
  , updateWebhookSubscriptionRequestSchemaCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UpdateWebhookSubscriptionRequestSchema
instance A.FromJSON UpdateWebhookSubscriptionRequestSchema where
  parseJSON = A.withObject "UpdateWebhookSubscriptionRequestSchema" $ \o ->
    UpdateWebhookSubscriptionRequestSchema
      <$> (o .:? "statusUpdate")
      <*> (o .:? "callbackUrl")

-- | ToJSON UpdateWebhookSubscriptionRequestSchema
instance A.ToJSON UpdateWebhookSubscriptionRequestSchema where
  toJSON UpdateWebhookSubscriptionRequestSchema {..} =
   _omitNulls
      [ "statusUpdate" .= updateWebhookSubscriptionRequestSchemaStatusUpdate
      , "callbackUrl" .= updateWebhookSubscriptionRequestSchemaCallbackUrl
      ]


-- | Construct a value of type 'UpdateWebhookSubscriptionRequestSchema' (by applying it's required fields, if any)
mkUpdateWebhookSubscriptionRequestSchema
  :: UpdateWebhookSubscriptionRequestSchema
mkUpdateWebhookSubscriptionRequestSchema =
  UpdateWebhookSubscriptionRequestSchema
  { updateWebhookSubscriptionRequestSchemaStatusUpdate = Nothing
  , updateWebhookSubscriptionRequestSchemaCallbackUrl = Nothing
  }

-- ** Vout
-- | Vout
data Vout = Vout
  { voutScriptPubKey :: !(Maybe ScriptPubKey) -- ^ "scriptPubKey"
  , voutValue :: !(Maybe Double) -- ^ "value"
  , voutN :: !(Maybe Double) -- ^ "n"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Vout
instance A.FromJSON Vout where
  parseJSON = A.withObject "Vout" $ \o ->
    Vout
      <$> (o .:? "scriptPubKey")
      <*> (o .:? "value")
      <*> (o .:? "n")

-- | ToJSON Vout
instance A.ToJSON Vout where
  toJSON Vout {..} =
   _omitNulls
      [ "scriptPubKey" .= voutScriptPubKey
      , "value" .= voutValue
      , "n" .= voutN
      ]


-- | Construct a value of type 'Vout' (by applying it's required fields, if any)
mkVout
  :: Vout
mkVout =
  Vout
  { voutScriptPubKey = Nothing
  , voutValue = Nothing
  , voutN = Nothing
  }

-- ** WebhookStatusUpdateSchema
-- | WebhookStatusUpdateSchema
data WebhookStatusUpdateSchema = WebhookStatusUpdateSchema
  { webhookStatusUpdateSchemaValue :: !(Maybe Text) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookStatusUpdateSchema
instance A.FromJSON WebhookStatusUpdateSchema where
  parseJSON = A.withObject "WebhookStatusUpdateSchema" $ \o ->
    WebhookStatusUpdateSchema
      <$> (o .:? "value")

-- | ToJSON WebhookStatusUpdateSchema
instance A.ToJSON WebhookStatusUpdateSchema where
  toJSON WebhookStatusUpdateSchema {..} =
   _omitNulls
      [ "value" .= webhookStatusUpdateSchemaValue
      ]


-- | Construct a value of type 'WebhookStatusUpdateSchema' (by applying it's required fields, if any)
mkWebhookStatusUpdateSchema
  :: WebhookStatusUpdateSchema
mkWebhookStatusUpdateSchema =
  WebhookStatusUpdateSchema
  { webhookStatusUpdateSchemaValue = Nothing
  }

-- ** WebhookSubscriptionDetails
-- | WebhookSubscriptionDetails
data WebhookSubscriptionDetails = WebhookSubscriptionDetails
  { webhookSubscriptionDetailsIds :: !(Maybe [Text]) -- ^ "ids"
  , webhookSubscriptionDetailsStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookSubscriptionDetails
instance A.FromJSON WebhookSubscriptionDetails where
  parseJSON = A.withObject "WebhookSubscriptionDetails" $ \o ->
    WebhookSubscriptionDetails
      <$> (o .:? "ids")
      <*> (o .:? "status")

-- | ToJSON WebhookSubscriptionDetails
instance A.ToJSON WebhookSubscriptionDetails where
  toJSON WebhookSubscriptionDetails {..} =
   _omitNulls
      [ "ids" .= webhookSubscriptionDetailsIds
      , "status" .= webhookSubscriptionDetailsStatus
      ]


-- | Construct a value of type 'WebhookSubscriptionDetails' (by applying it's required fields, if any)
mkWebhookSubscriptionDetails
  :: WebhookSubscriptionDetails
mkWebhookSubscriptionDetails =
  WebhookSubscriptionDetails
  { webhookSubscriptionDetailsIds = Nothing
  , webhookSubscriptionDetailsStatus = Nothing
  }

-- ** WebhookSubscriptionDetailsSchema
-- | WebhookSubscriptionDetailsSchema
data WebhookSubscriptionDetailsSchema = WebhookSubscriptionDetailsSchema
  { webhookSubscriptionDetailsSchemaIds :: !(Maybe [Text]) -- ^ "ids"
  , webhookSubscriptionDetailsSchemaStatus :: !(Maybe Status) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookSubscriptionDetailsSchema
instance A.FromJSON WebhookSubscriptionDetailsSchema where
  parseJSON = A.withObject "WebhookSubscriptionDetailsSchema" $ \o ->
    WebhookSubscriptionDetailsSchema
      <$> (o .:? "ids")
      <*> (o .:? "status")

-- | ToJSON WebhookSubscriptionDetailsSchema
instance A.ToJSON WebhookSubscriptionDetailsSchema where
  toJSON WebhookSubscriptionDetailsSchema {..} =
   _omitNulls
      [ "ids" .= webhookSubscriptionDetailsSchemaIds
      , "status" .= webhookSubscriptionDetailsSchemaStatus
      ]


-- | Construct a value of type 'WebhookSubscriptionDetailsSchema' (by applying it's required fields, if any)
mkWebhookSubscriptionDetailsSchema
  :: WebhookSubscriptionDetailsSchema
mkWebhookSubscriptionDetailsSchema =
  WebhookSubscriptionDetailsSchema
  { webhookSubscriptionDetailsSchemaIds = Nothing
  , webhookSubscriptionDetailsSchemaStatus = Nothing
  }

-- ** WebhookSubscriptionStatusUpdateResponse
-- | WebhookSubscriptionStatusUpdateResponse
data WebhookSubscriptionStatusUpdateResponse = WebhookSubscriptionStatusUpdateResponse
  { webhookSubscriptionStatusUpdateResponseSubscriptionDetails :: !(Maybe WebhookSubscriptionDetails) -- ^ "subscriptionDetails"
  , webhookSubscriptionStatusUpdateResponseCallbackUrl :: !(Maybe Text) -- ^ "callbackUrl"
  , webhookSubscriptionStatusUpdateResponseSubscriptionId :: !(Maybe Text) -- ^ "subscriptionId"
  , webhookSubscriptionStatusUpdateResponseType :: !(Maybe Text) -- ^ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON WebhookSubscriptionStatusUpdateResponse
instance A.FromJSON WebhookSubscriptionStatusUpdateResponse where
  parseJSON = A.withObject "WebhookSubscriptionStatusUpdateResponse" $ \o ->
    WebhookSubscriptionStatusUpdateResponse
      <$> (o .:? "subscriptionDetails")
      <*> (o .:? "callbackUrl")
      <*> (o .:? "subscriptionId")
      <*> (o .:? "type")

-- | ToJSON WebhookSubscriptionStatusUpdateResponse
instance A.ToJSON WebhookSubscriptionStatusUpdateResponse where
  toJSON WebhookSubscriptionStatusUpdateResponse {..} =
   _omitNulls
      [ "subscriptionDetails" .= webhookSubscriptionStatusUpdateResponseSubscriptionDetails
      , "callbackUrl" .= webhookSubscriptionStatusUpdateResponseCallbackUrl
      , "subscriptionId" .= webhookSubscriptionStatusUpdateResponseSubscriptionId
      , "type" .= webhookSubscriptionStatusUpdateResponseType
      ]


-- | Construct a value of type 'WebhookSubscriptionStatusUpdateResponse' (by applying it's required fields, if any)
mkWebhookSubscriptionStatusUpdateResponse
  :: WebhookSubscriptionStatusUpdateResponse
mkWebhookSubscriptionStatusUpdateResponse =
  WebhookSubscriptionStatusUpdateResponse
  { webhookSubscriptionStatusUpdateResponseSubscriptionDetails = Nothing
  , webhookSubscriptionStatusUpdateResponseCallbackUrl = Nothing
  , webhookSubscriptionStatusUpdateResponseSubscriptionId = Nothing
  , webhookSubscriptionStatusUpdateResponseType = Nothing
  }


-- * Enums


-- ** E'ContractType

-- | Enum of 'Text'
data E'ContractType
  = E'ContractType'ERC20 -- ^ @"ERC20"@
  | E'ContractType'QRC20 -- ^ @"QRC20"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ContractType where toJSON = A.toJSON . fromE'ContractType
instance A.FromJSON E'ContractType where parseJSON o = P.either P.fail (pure . P.id) . toE'ContractType =<< A.parseJSON o
instance WH.ToHttpApiData E'ContractType where toQueryParam = WH.toQueryParam . fromE'ContractType
instance WH.FromHttpApiData E'ContractType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ContractType
instance MimeRender MimeMultipartFormData E'ContractType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ContractType' enum
fromE'ContractType :: E'ContractType -> Text
fromE'ContractType = \case
  E'ContractType'ERC20 -> "ERC20"
  E'ContractType'QRC20 -> "QRC20"

-- | parse 'E'ContractType' enum
toE'ContractType :: Text -> P.Either String E'ContractType
toE'ContractType = \case
  "ERC20" -> P.Right E'ContractType'ERC20
  "QRC20" -> P.Right E'ContractType'QRC20
  s -> P.Left $ "toE'ContractType: enum parse failure: " P.++ P.show s


-- ** E'OverledgerSigningType

-- | Enum of 'Text' .
-- The method of signing used to submit the transaction
data E'OverledgerSigningType
  = E'OverledgerSigningType'Overledger_javascript_library -- ^ @"overledger-javascript-library"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'OverledgerSigningType where toJSON = A.toJSON . fromE'OverledgerSigningType
instance A.FromJSON E'OverledgerSigningType where parseJSON o = P.either P.fail (pure . P.id) . toE'OverledgerSigningType =<< A.parseJSON o
instance WH.ToHttpApiData E'OverledgerSigningType where toQueryParam = WH.toQueryParam . fromE'OverledgerSigningType
instance WH.FromHttpApiData E'OverledgerSigningType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'OverledgerSigningType
instance MimeRender MimeMultipartFormData E'OverledgerSigningType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'OverledgerSigningType' enum
fromE'OverledgerSigningType :: E'OverledgerSigningType -> Text
fromE'OverledgerSigningType = \case
  E'OverledgerSigningType'Overledger_javascript_library -> "overledger-javascript-library"

-- | parse 'E'OverledgerSigningType' enum
toE'OverledgerSigningType :: Text -> P.Either String E'OverledgerSigningType
toE'OverledgerSigningType = \case
  "overledger-javascript-library" -> P.Right E'OverledgerSigningType'Overledger_javascript_library
  s -> P.Left $ "toE'OverledgerSigningType: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' .
-- The type of the transaction
data E'Type
  = E'Type'Payment -- ^ @"Payment"@
  | E'Type'Transfer -- ^ @"Transfer"@
  | E'Type'Contract_Invoke -- ^ @"Contract Invoke"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Payment -> "Payment"
  E'Type'Transfer -> "Transfer"
  E'Type'Contract_Invoke -> "Contract Invoke"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "Payment" -> P.Right E'Type'Payment
  "Transfer" -> P.Right E'Type'Transfer
  "Contract Invoke" -> P.Right E'Type'Contract_Invoke
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Urgency

-- | Enum of 'Text' .
-- This value defines how fast a transaction is processed on a network. A faster processing requirement will result in higher fees. If the urgency field is not provided, the default setting is normal
data E'Urgency
  = E'Urgency'Normal -- ^ @"Normal"@
  | E'Urgency'Fast -- ^ @"Fast"@
  | E'Urgency'Urgent -- ^ @"Urgent"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Urgency where toJSON = A.toJSON . fromE'Urgency
instance A.FromJSON E'Urgency where parseJSON o = P.either P.fail (pure . P.id) . toE'Urgency =<< A.parseJSON o
instance WH.ToHttpApiData E'Urgency where toQueryParam = WH.toQueryParam . fromE'Urgency
instance WH.FromHttpApiData E'Urgency where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Urgency
instance MimeRender MimeMultipartFormData E'Urgency where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Urgency' enum
fromE'Urgency :: E'Urgency -> Text
fromE'Urgency = \case
  E'Urgency'Normal -> "Normal"
  E'Urgency'Fast -> "Fast"
  E'Urgency'Urgent -> "Urgent"

-- | parse 'E'Urgency' enum
toE'Urgency :: Text -> P.Either String E'Urgency
toE'Urgency = \case
  "Normal" -> P.Right E'Urgency'Normal
  "Fast" -> P.Right E'Urgency'Fast
  "Urgent" -> P.Right E'Urgency'Urgent
  s -> P.Left $ "toE'Urgency: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthOAuthOAuth2SecurityScheme
data AuthOAuthOAuth2SecurityScheme =
  AuthOAuthOAuth2SecurityScheme Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthOAuthOAuth2SecurityScheme where
  applyAuthMethod _ a@(AuthOAuthOAuth2SecurityScheme secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", "Bearer " <> secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


